<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>INET Framework for OMNeT++/OMNEST: TCPBaseAlg Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">INET Framework for OMNeT++/OMNEST</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_t_c_p_base_alg.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">TCPBaseAlg Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="TCPBaseAlg" --><!-- doxytag: inherits="TCPAlgorithm" -->
<p><code>#include &lt;TCPBaseAlg.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TCPBaseAlg:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_t_c_p_base_alg.png" usemap="#TCPBaseAlg_map" alt=""/>
  <map id="TCPBaseAlg_map" name="TCPBaseAlg_map">
<area href="class_t_c_p_algorithm.html" alt="TCPAlgorithm" shape="rect" coords="83,0,239,24"/>
<area href="class_t_c_p_no_congestion_control.html" alt="TCPNoCongestionControl" shape="rect" coords="0,112,156,136"/>
<area href="class_t_c_p_tahoe_reno_family.html" alt="TCPTahoeRenoFamily" shape="rect" coords="166,112,322,136"/>
<area href="class_t_c_p_new_reno.html" alt="TCPNewReno" shape="rect" coords="0,168,156,192"/>
<area href="class_t_c_p_reno.html" alt="TCPReno" shape="rect" coords="166,168,322,192"/>
<area href="class_t_c_p_tahoe.html" alt="TCPTahoe" shape="rect" coords="332,168,488,192"/>
</map>
 </div></div>

<p><a href="class_t_c_p_base_alg-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a2f8265b680a8cee124f685b19919ab03">TCPBaseAlg</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a5929dfe85238f1ceccd0f5dd578d4b18">~TCPBaseAlg</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#ae6147731689fcc4c5c79f4cc539c6b7f">initialize</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a2cbb83fb79f28eaea3d33acb13526e11">established</a> (bool active)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#acf011bd6523207a40e179f1f9f4f448d">connectionClosed</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a9008afe23db553e45b37d9811f7af110">processTimer</a> (cMessage *timer, <a class="el" href="_t_c_p_connection_8h.html#a9187fb8d597fec5e53124ffe46c7e85e">TCPEventCode</a> &amp;event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#adeb5f45e211987af985c94992dc3350f">sendCommandInvoked</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#aa49a6c59e453685907e24dc671e3561d">receivedOutOfOrderSegment</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a772c3712679d50b0598957665b14acc9">receiveSeqChanged</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a55a32a0e93c6417adb091ee162f225e2">receivedDataAck</a> (uint32 firstSeqAcked)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#ad198abc5a259c9b1660ec149aae3b11d">receivedDuplicateAck</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a8d57787d474f4a317bffa76c8f13ef3a">receivedAckForDataNotYetSent</a> (uint32 seq)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#ae40c0a08732c067048a9183945153ec1">ackSent</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a8bbd5e8c6d8b139da0cbc44a3274c9fa">dataSent</a> (uint32 fromseq)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#aa781a26258eb0504bfff79468079e1b8">restartRexmitTimer</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a5fc842a3f9c5297e9ba795843bf0cabb">startRexmitTimer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a31986bf6db565ab455f818eafb01320e">rttMeasurementComplete</a> (simtime_t tSent, simtime_t tAcked)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a7515afa05f1ae81306d10824d4940a54">rttMeasurementCompleteUsingTS</a> (uint32 echoedTS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a28c072f575629d0c5ec6478edd3bb7e5">sendData</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cMessage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#afc54d88f3abc5f0956e1d4d6c3d5c206">cancelEvent</a> (cMessage *msg)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Process REXMIT, PERSIST, DELAYED-ACK and KEEP-ALIVE timers</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#ac8a305a437d4eafd1689204e50af8870">processRexmitTimer</a> (<a class="el" href="_t_c_p_connection_8h.html#a9187fb8d597fec5e53124ffe46c7e85e">TCPEventCode</a> &amp;event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a69a0d60fa083b9a3b03e8f80d3c53e6f">processPersistTimer</a> (<a class="el" href="_t_c_p_connection_8h.html#a9187fb8d597fec5e53124ffe46c7e85e">TCPEventCode</a> &amp;event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#ad5f7c065fdf27a650a7c711cf8e31766">processDelayedAckTimer</a> (<a class="el" href="_t_c_p_connection_8h.html#a9187fb8d597fec5e53124ffe46c7e85e">TCPEventCode</a> &amp;event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a586dd4192388dc907ab36ae4aec4c3d5">processKeepAliveTimer</a> (<a class="el" href="_t_c_p_connection_8h.html#a9187fb8d597fec5e53124ffe46c7e85e">TCPEventCode</a> &amp;event)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_c_p_base_alg_state_variables.html">TCPBaseAlgStateVariables</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cMessage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a2413e27953b03ff929b26b62e9dfe8b0">rexmitTimer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cMessage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a16b5813e073593fcf194859387efaef3">persistTimer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cMessage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#aba8d2462619e5aa1106b992c3361c3fb">delayedAckTimer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cMessage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a7eee3af489bedb3010ff637fe848d232">keepAliveTimer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cOutVector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a9e6f430f3a5463137d416627f4282d64">cwndVector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cOutVector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#adcb49cda42179c795cf3c12ed42b3f31">ssthreshVector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cOutVector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#ad4718c9463f32652274f266cf0959575">rttVector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cOutVector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a08ecae944120c1a57b4d0349fef1f98b">srttVector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cOutVector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a27e1885fc2811db6bb92761d99168c26">rttvarVector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cOutVector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a81f6ee9e817cc9225e00ce2945c5e4bf">rtoVector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cOutVector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p_base_alg.html#a0558fe41bf7f4318f5739a472b8e95fd">numRtosVector</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Includes basic <a class="el" href="class_t_c_p.html">TCP</a> algorithms: adaptive retransmission, PERSIST timer, keep-alive, delayed acks -- EXCLUDING congestion control. Congestion control is implemented in subclasses such as TCPTahoeAlg or TCPRenoAlg.</p>
<p>Implements:</p>
<ul>
<li>delayed ACK algorithm (RFC 1122)</li>
<li>Jacobson's and Karn's algorithms for adaptive retransmission</li>
<li>Nagle's algorithm (RFC 896) to prevent silly window syndrome</li>
<li>Increased Initial Window (RFC 3390)</li>
<li>PERSIST timer</li>
</ul>
<p>To be done:</p>
<ul>
<li>KEEP-ALIVE timer</li>
</ul>
<p>Note: currently the timers and time calculations are done in double and NOT in Unix (200ms or 500ms) ticks. It's possible to write another <a class="el" href="class_t_c_p_algorithm.html">TCPAlgorithm</a> which uses ticks (or rather, factor out timer handling to separate methods, and redefine only those).</p>
<p>Congestion window is set to SMSS when the connection is established, and not touched after that. Subclasses may redefine any of the virtual functions here to add their congestion control code. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2f8265b680a8cee124f685b19919ab03"></a><!-- doxytag: member="TCPBaseAlg::TCPBaseAlg" ref="a2f8265b680a8cee124f685b19919ab03" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TCPBaseAlg::TCPBaseAlg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ctor. </p>
<div class="fragment"><pre class="fragment">                       : <a class="code" href="class_t_c_p_algorithm.html#a19b1c2dde3f3283b3fbcb538a8d3a356">TCPAlgorithm</a>(),
  <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>((<a class="code" href="class_t_c_p_base_alg_state_variables.html">TCPBaseAlgStateVariables</a> *&amp;)<a class="code" href="class_t_c_p_algorithm.html#add50c340ebfd641323eb3cdee685885c">TCPAlgorithm::state</a>)
{
    <a class="code" href="class_t_c_p_base_alg.html#a2413e27953b03ff929b26b62e9dfe8b0">rexmitTimer</a> = <a class="code" href="class_t_c_p_base_alg.html#a16b5813e073593fcf194859387efaef3">persistTimer</a> = <a class="code" href="class_t_c_p_base_alg.html#aba8d2462619e5aa1106b992c3361c3fb">delayedAckTimer</a> = <a class="code" href="class_t_c_p_base_alg.html#a7eee3af489bedb3010ff637fe848d232">keepAliveTimer</a> = NULL;
    <a class="code" href="class_t_c_p_base_alg.html#a9e6f430f3a5463137d416627f4282d64">cwndVector</a> = <a class="code" href="class_t_c_p_base_alg.html#adcb49cda42179c795cf3c12ed42b3f31">ssthreshVector</a> = <a class="code" href="class_t_c_p_base_alg.html#ad4718c9463f32652274f266cf0959575">rttVector</a> = <a class="code" href="class_t_c_p_base_alg.html#a08ecae944120c1a57b4d0349fef1f98b">srttVector</a> = <a class="code" href="class_t_c_p_base_alg.html#a27e1885fc2811db6bb92761d99168c26">rttvarVector</a> = <a class="code" href="class_t_c_p_base_alg.html#a81f6ee9e817cc9225e00ce2945c5e4bf">rtoVector</a> = <a class="code" href="class_t_c_p_base_alg.html#a0558fe41bf7f4318f5739a472b8e95fd">numRtosVector</a> = NULL;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5929dfe85238f1ceccd0f5dd578d4b18"></a><!-- doxytag: member="TCPBaseAlg::~TCPBaseAlg" ref="a5929dfe85238f1ceccd0f5dd578d4b18" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TCPBaseAlg::~TCPBaseAlg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Virtual dtor. </p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// Note: don&#39;t delete &quot;state&quot; here, it&#39;ll be deleted from TCPConnection</span>

    <span class="comment">// cancel and delete timers</span>
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#a2413e27953b03ff929b26b62e9dfe8b0">rexmitTimer</a>)     <span class="keyword">delete</span> <a class="code" href="class_t_c_p_base_alg.html#afc54d88f3abc5f0956e1d4d6c3d5c206">cancelEvent</a>(<a class="code" href="class_t_c_p_base_alg.html#a2413e27953b03ff929b26b62e9dfe8b0">rexmitTimer</a>);
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#a16b5813e073593fcf194859387efaef3">persistTimer</a>)    <span class="keyword">delete</span> <a class="code" href="class_t_c_p_base_alg.html#afc54d88f3abc5f0956e1d4d6c3d5c206">cancelEvent</a>(<a class="code" href="class_t_c_p_base_alg.html#a16b5813e073593fcf194859387efaef3">persistTimer</a>);
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#aba8d2462619e5aa1106b992c3361c3fb">delayedAckTimer</a>) <span class="keyword">delete</span> <a class="code" href="class_t_c_p_base_alg.html#afc54d88f3abc5f0956e1d4d6c3d5c206">cancelEvent</a>(<a class="code" href="class_t_c_p_base_alg.html#aba8d2462619e5aa1106b992c3361c3fb">delayedAckTimer</a>);
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#a7eee3af489bedb3010ff637fe848d232">keepAliveTimer</a>)  <span class="keyword">delete</span> <a class="code" href="class_t_c_p_base_alg.html#afc54d88f3abc5f0956e1d4d6c3d5c206">cancelEvent</a>(<a class="code" href="class_t_c_p_base_alg.html#a7eee3af489bedb3010ff637fe848d232">keepAliveTimer</a>);

    <span class="comment">// delete statistics objects</span>
    <span class="keyword">delete</span> <a class="code" href="class_t_c_p_base_alg.html#a9e6f430f3a5463137d416627f4282d64">cwndVector</a>;
    <span class="keyword">delete</span> <a class="code" href="class_t_c_p_base_alg.html#adcb49cda42179c795cf3c12ed42b3f31">ssthreshVector</a>;
    <span class="keyword">delete</span> <a class="code" href="class_t_c_p_base_alg.html#ad4718c9463f32652274f266cf0959575">rttVector</a>;
    <span class="keyword">delete</span> <a class="code" href="class_t_c_p_base_alg.html#a08ecae944120c1a57b4d0349fef1f98b">srttVector</a>;
    <span class="keyword">delete</span> <a class="code" href="class_t_c_p_base_alg.html#a27e1885fc2811db6bb92761d99168c26">rttvarVector</a>;
    <span class="keyword">delete</span> <a class="code" href="class_t_c_p_base_alg.html#a81f6ee9e817cc9225e00ce2945c5e4bf">rtoVector</a>;
    <span class="keyword">delete</span> <a class="code" href="class_t_c_p_base_alg.html#a0558fe41bf7f4318f5739a472b8e95fd">numRtosVector</a>;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae40c0a08732c067048a9183945153ec1"></a><!-- doxytag: member="TCPBaseAlg::ackSent" ref="ae40c0a08732c067048a9183945153ec1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::ackSent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called after we sent an ACK. This hook can be used to cancel the delayed-ACK timer. </p>

<p>Implements <a class="el" href="class_t_c_p_algorithm.html#ab60e458026100386119cc556ab856462">TCPAlgorithm</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a5d47c2c046bb9fe704be153bb0731e9a">full_sized_segment_counter</a> = 0; <span class="comment">// reset counter</span>
    <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#ac945d97e6a37246ca8cf3648e01a8a26">ack_now</a> = <span class="keyword">false</span>; <span class="comment">// reset flag</span>
    <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#abfbcb8fed25793f011ff32a6dc6ee722">last_ack_sent</a> = <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a5b9de18a3fb71fab5a540f98173b12b1">rcv_nxt</a>; <span class="comment">// update last_ack_sent, needed for TS option</span>
    <span class="comment">// if delayed ACK timer is running, cancel it</span>
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#aba8d2462619e5aa1106b992c3361c3fb">delayedAckTimer</a>-&gt;isScheduled())
        <a class="code" href="class_t_c_p_base_alg.html#afc54d88f3abc5f0956e1d4d6c3d5c206">cancelEvent</a>(<a class="code" href="class_t_c_p_base_alg.html#aba8d2462619e5aa1106b992c3361c3fb">delayedAckTimer</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="afc54d88f3abc5f0956e1d4d6c3d5c206"></a><!-- doxytag: member="TCPBaseAlg::cancelEvent" ref="afc54d88f3abc5f0956e1d4d6c3d5c206" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cMessage* TCPBaseAlg::cancelEvent </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Utility function </p>

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#ae40c0a08732c067048a9183945153ec1">ackSent()</a>, <a class="el" href="class_t_c_p_base_alg.html#acf011bd6523207a40e179f1f9f4f448d">connectionClosed()</a>, <a class="el" href="class_t_c_p_base_alg.html#a55a32a0e93c6417adb091ee162f225e2">receivedDataAck()</a>, <a class="el" href="class_t_c_p_base_alg.html#aa781a26258eb0504bfff79468079e1b8">restartRexmitTimer()</a>, and <a class="el" href="class_t_c_p_base_alg.html#a5929dfe85238f1ceccd0f5dd578d4b18">~TCPBaseAlg()</a>.</p>
<div class="fragment"><pre class="fragment">{<span class="keywordflow">return</span> <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a5c9318d9fe504d7e5779a5b2eab87e09">getTcpMain</a>()-&gt;cancelEvent(msg);}
</pre></div>
</div>
</div>
<a class="anchor" id="acf011bd6523207a40e179f1f9f4f448d"></a><!-- doxytag: member="TCPBaseAlg::connectionClosed" ref="acf011bd6523207a40e179f1f9f4f448d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::connectionClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called when the connection closes, it should cancel all running timers. </p>

<p>Implements <a class="el" href="class_t_c_p_algorithm.html#a8f85fd7e065ed30ddaa1e741781130ae">TCPAlgorithm</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_t_c_p_base_alg.html#afc54d88f3abc5f0956e1d4d6c3d5c206">cancelEvent</a>(<a class="code" href="class_t_c_p_base_alg.html#a2413e27953b03ff929b26b62e9dfe8b0">rexmitTimer</a>);
    <a class="code" href="class_t_c_p_base_alg.html#afc54d88f3abc5f0956e1d4d6c3d5c206">cancelEvent</a>(<a class="code" href="class_t_c_p_base_alg.html#a16b5813e073593fcf194859387efaef3">persistTimer</a>);
    <a class="code" href="class_t_c_p_base_alg.html#afc54d88f3abc5f0956e1d4d6c3d5c206">cancelEvent</a>(<a class="code" href="class_t_c_p_base_alg.html#aba8d2462619e5aa1106b992c3361c3fb">delayedAckTimer</a>);
    <a class="code" href="class_t_c_p_base_alg.html#afc54d88f3abc5f0956e1d4d6c3d5c206">cancelEvent</a>(<a class="code" href="class_t_c_p_base_alg.html#a7eee3af489bedb3010ff637fe848d232">keepAliveTimer</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8bbd5e8c6d8b139da0cbc44a3274c9fa"></a><!-- doxytag: member="TCPBaseAlg::dataSent" ref="a8bbd5e8c6d8b139da0cbc44a3274c9fa" args="(uint32 fromseq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::dataSent </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>fromseq</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called after we sent data. This hook can be used to schedule the retransmission timer, to start round-trip time measurement, etc. The argument is the seqno of the first byte sent. </p>

<p>Implements <a class="el" href="class_t_c_p_algorithm.html#aab20913df04bb33389d7949a502ae0d6">TCPAlgorithm</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// if retransmission timer not running, schedule it</span>
    <span class="keywordflow">if</span> (!<a class="code" href="class_t_c_p_base_alg.html#a2413e27953b03ff929b26b62e9dfe8b0">rexmitTimer</a>-&gt;isScheduled())
    {
        <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;Starting REXMIT timer\n&quot;</span>;
        <a class="code" href="class_t_c_p_base_alg.html#a5fc842a3f9c5297e9ba795843bf0cabb">startRexmitTimer</a>();
    }

    <span class="keywordflow">if</span> (!<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#aea39bfb1176d367d349fb4efcbbe807f">ts_enabled</a>)
    {
        <span class="comment">// start round-trip time measurement (if not already running)</span>
        <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab60db2ccc468ad30634014bb035246e0" title="time when rtseq was sent (0 if RTT measurement is not running)">rtseq_sendtime</a>==0)
        {
            <span class="comment">// remember this sequence number and when it was sent</span>
            <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a1f7c0b7477430b752550a4778afc913e" title="round-trip time measurements">rtseq</a> = fromseq;
            <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab60db2ccc468ad30634014bb035246e0" title="time when rtseq was sent (0 if RTT measurement is not running)">rtseq_sendtime</a> = simTime();
            <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;Starting rtt measurement on seq=&quot;</span> &lt;&lt; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a1f7c0b7477430b752550a4778afc913e" title="round-trip time measurements">rtseq</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
        }
    }

    <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a8ac5ae9db4029d0f8a6cff75297fa2c8">time_last_data_sent</a> = simTime();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2cbb83fb79f28eaea3d33acb13526e11"></a><!-- doxytag: member="TCPBaseAlg::established" ref="a2cbb83fb79f28eaea3d33acb13526e11" args="(bool active)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::established </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called when the connection is going to ESTABLISHED from SYN_SENT or SYN_RCVD. This is a place to initialize some variables (e.g. set cwnd to the MSS learned during connection setup). If we are on the active side, here we also have to finish the 3-way connection setup procedure by sending an ACK, possibly piggybacked on data. </p>

<p>Implements <a class="el" href="class_t_c_p_algorithm.html#a2d051b6a9e2a9fccfa6f8b64bb8c647d">TCPAlgorithm</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// initialize cwnd (we may learn SMSS during connection setup)</span>

    <span class="comment">// RFC 3390, page 2: &quot;The upper bound for the initial window is given more precisely in</span>
    <span class="comment">// (1):</span>
    <span class="comment">//</span>
    <span class="comment">//   min (4*MSS, max (2*MSS, 4380 bytes))                        (1)</span>
    <span class="comment">//</span>
    <span class="comment">// Note: Sending a 1500 byte packet indicates a maximum segment size</span>
    <span class="comment">// (MSS) of 1460 bytes (assuming no IP or TCP options).  Therefore,</span>
    <span class="comment">// limiting the initial window&#39;s MSS to 4380 bytes allows the sender to</span>
    <span class="comment">// transmit three segments initially in the common case when using 1500</span>
    <span class="comment">// byte packets.</span>
    <span class="comment">//</span>
    <span class="comment">// Equivalently, the upper bound for the initial window size is based on</span>
    <span class="comment">// the MSS, as follows:</span>
    <span class="comment">//</span>
    <span class="comment">//   If (MSS &lt;= 1095 bytes)</span>
    <span class="comment">//     then win &lt;= 4 * MSS;</span>
    <span class="comment">//   If (1095 bytes &lt; MSS &lt; 2190 bytes)</span>
    <span class="comment">//     then win &lt;= 4380;</span>
    <span class="comment">//   If (2190 bytes &lt;= MSS)</span>
    <span class="comment">//     then win &lt;= 2 * MSS;</span>
    <span class="comment">//</span>
    <span class="comment">// This increased initial window is optional: a TCP MAY start with a</span>
    <span class="comment">// larger initial window.  However, we expect that most general-purpose</span>
    <span class="comment">// TCP implementations would choose to use the larger initial congestion</span>
    <span class="comment">// window given in equation (1) above.</span>
    <span class="comment">//</span>
    <span class="comment">// This upper bound for the initial window size represents a change from</span>
    <span class="comment">// RFC 2581 [RFC2581], which specified that the congestion window be</span>
    <span class="comment">// initialized to one or two segments.</span>
    <span class="comment">// (...)</span>
    <span class="comment">// If the SYN or SYN/ACK is</span>
    <span class="comment">// lost, the initial window used by a sender after a correctly</span>
    <span class="comment">// transmitted SYN MUST be one segment consisting of MSS bytes.&quot;</span>
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a7c3d5a7916b1d457f6065c488684d1d5">increased_IW_enabled</a> &amp;&amp; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#abfce4d61e489f5c73d2f73aa072814e6">syn_rexmit_count</a>==0)
    {
        <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a36b9d4c46519bcd7a094462c68881ce9">snd_cwnd</a> = <a class="code" href="_s_c_t_p_association_8h.html#ad61931b1ae6b8e5bb714e2e6744f4470">std::min</a>(4 * <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a2d9952d560079e7a0cf44f2308ac564f">snd_mss</a>, <a class="code" href="_s_c_t_p_association_8h.html#afdb84bd44c7cbd3fc9cbe1e3bf07d948">std::max</a>(2 * <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a2d9952d560079e7a0cf44f2308ac564f">snd_mss</a>, (uint32)4380));
        <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;Enabled Increased Initial Window, CWND is set to: &quot;</span> &lt;&lt; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a36b9d4c46519bcd7a094462c68881ce9">snd_cwnd</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
    }
    <span class="comment">// RFC 2001, page 3:</span>
    <span class="comment">// &quot; 1.  Initialization for a given connection sets cwnd to one segment</span>
    <span class="comment">// and ssthresh to 65535 bytes.&quot;</span>
    <span class="keywordflow">else</span>
        <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a36b9d4c46519bcd7a094462c68881ce9">snd_cwnd</a> = <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a2d9952d560079e7a0cf44f2308ac564f">snd_mss</a>; <span class="comment">// RFC 2001</span>

    <span class="keywordflow">if</span> (active)
    {
        <span class="comment">// finish connection setup with ACK (possibly piggybacked on data)</span>
        <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;Completing connection setup by sending ACK (possibly piggybacked on data)\n&quot;</span>;
        <span class="keywordflow">if</span> (!<a class="code" href="class_t_c_p_base_alg.html#a28c072f575629d0c5ec6478edd3bb7e5">sendData</a>()) <span class="comment">// FIXME TODO - This condition is never true because the buffer is empty (at this time) therefore the first ACK is never piggyback on data</span>
            <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a60ee5bc5b391d621e7e684857e195151">sendAck</a>();
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae6147731689fcc4c5c79f4cc539c6b7f"></a><!-- doxytag: member="TCPBaseAlg::initialize" ref="ae6147731689fcc4c5c79f4cc539c6b7f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create timers, etc. </p>

<p>Reimplemented from <a class="el" href="class_t_c_p_algorithm.html#a0b15a6a2f11c4a482ecec6208f5ee23d">TCPAlgorithm</a>.</p>

<p>Reimplemented in <a class="el" href="class_t_c_p_no_congestion_control.html#a3d875b56a5442cb63a6b37da45efdc9d">TCPNoCongestionControl</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_t_c_p_base_alg.html#ae6147731689fcc4c5c79f4cc539c6b7f">TCPAlgorithm::initialize</a>();

    <a class="code" href="class_t_c_p_base_alg.html#a2413e27953b03ff929b26b62e9dfe8b0">rexmitTimer</a> = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;REXMIT&quot;</span>);
    <a class="code" href="class_t_c_p_base_alg.html#a16b5813e073593fcf194859387efaef3">persistTimer</a> = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;PERSIST&quot;</span>);
    <a class="code" href="class_t_c_p_base_alg.html#aba8d2462619e5aa1106b992c3361c3fb">delayedAckTimer</a> = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;DELAYEDACK&quot;</span>);
    <a class="code" href="class_t_c_p_base_alg.html#a7eee3af489bedb3010ff637fe848d232">keepAliveTimer</a> = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;KEEPALIVE&quot;</span>);

    <a class="code" href="class_t_c_p_base_alg.html#a2413e27953b03ff929b26b62e9dfe8b0">rexmitTimer</a>-&gt;setContextPointer(<a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>);
    <a class="code" href="class_t_c_p_base_alg.html#a16b5813e073593fcf194859387efaef3">persistTimer</a>-&gt;setContextPointer(<a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>);
    <a class="code" href="class_t_c_p_base_alg.html#aba8d2462619e5aa1106b992c3361c3fb">delayedAckTimer</a>-&gt;setContextPointer(<a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>);
    <a class="code" href="class_t_c_p_base_alg.html#a7eee3af489bedb3010ff637fe848d232">keepAliveTimer</a>-&gt;setContextPointer(<a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>);

    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a5c9318d9fe504d7e5779a5b2eab87e09">getTcpMain</a>()-&gt;<a class="code" href="class_t_c_p.html#a06c667b3923f435daac7800488097d04">recordStatistics</a>)
    {
        <a class="code" href="class_t_c_p_base_alg.html#a9e6f430f3a5463137d416627f4282d64">cwndVector</a> = <span class="keyword">new</span> cOutVector(<span class="stringliteral">&quot;cwnd&quot;</span>);
        <a class="code" href="class_t_c_p_base_alg.html#adcb49cda42179c795cf3c12ed42b3f31">ssthreshVector</a> = <span class="keyword">new</span> cOutVector(<span class="stringliteral">&quot;ssthresh&quot;</span>);
        <a class="code" href="class_t_c_p_base_alg.html#ad4718c9463f32652274f266cf0959575">rttVector</a> = <span class="keyword">new</span> cOutVector(<span class="stringliteral">&quot;measured RTT&quot;</span>);
        <a class="code" href="class_t_c_p_base_alg.html#a08ecae944120c1a57b4d0349fef1f98b">srttVector</a> = <span class="keyword">new</span> cOutVector(<span class="stringliteral">&quot;smoothed RTT&quot;</span>);
        <a class="code" href="class_t_c_p_base_alg.html#a27e1885fc2811db6bb92761d99168c26">rttvarVector</a> = <span class="keyword">new</span> cOutVector(<span class="stringliteral">&quot;RTTVAR&quot;</span>);
        <a class="code" href="class_t_c_p_base_alg.html#a81f6ee9e817cc9225e00ce2945c5e4bf">rtoVector</a> = <span class="keyword">new</span> cOutVector(<span class="stringliteral">&quot;RTO&quot;</span>);
        <a class="code" href="class_t_c_p_base_alg.html#a0558fe41bf7f4318f5739a472b8e95fd">numRtosVector</a> = <span class="keyword">new</span> cOutVector(<span class="stringliteral">&quot;numRTOs&quot;</span>);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad5f7c065fdf27a650a7c711cf8e31766"></a><!-- doxytag: member="TCPBaseAlg::processDelayedAckTimer" ref="ad5f7c065fdf27a650a7c711cf8e31766" args="(TCPEventCode &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::processDelayedAckTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_c_p_connection_8h.html#a9187fb8d597fec5e53124ffe46c7e85e">TCPEventCode</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#a9008afe23db553e45b37d9811f7af110">processTimer()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#ac945d97e6a37246ca8cf3648e01a8a26">ack_now</a> = <span class="keyword">true</span>;
    <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a60ee5bc5b391d621e7e684857e195151">sendAck</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a586dd4192388dc907ab36ae4aec4c3d5"></a><!-- doxytag: member="TCPBaseAlg::processKeepAliveTimer" ref="a586dd4192388dc907ab36ae4aec4c3d5" args="(TCPEventCode &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::processKeepAliveTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_c_p_connection_8h.html#a9187fb8d597fec5e53124ffe46c7e85e">TCPEventCode</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#a9008afe23db553e45b37d9811f7af110">processTimer()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// TBD</span>
    <span class="comment">// RFC 1122, page 102:</span>
    <span class="comment">// &quot;A &quot;keep-alive&quot; mechanism periodically probes the other</span>
    <span class="comment">// end of a connection when the connection is otherwise</span>
    <span class="comment">// idle, even when there is no data to be sent.  The TCP</span>
    <span class="comment">// specification does not include a keep-alive mechanism</span>
    <span class="comment">// because it could:  (1) cause perfectly good connections</span>
    <span class="comment">// to break during transient Internet failures; (2)</span>
    <span class="comment">// consume unnecessary bandwidth (&quot;if no one is using the</span>
    <span class="comment">// connection, who cares if it is still good?&quot;); and (3)</span>
    <span class="comment">// cost money for an Internet path that charges for</span>
    <span class="comment">// packets.&quot;</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a69a0d60fa083b9a3b03e8f80d3c53e6f"></a><!-- doxytag: member="TCPBaseAlg::processPersistTimer" ref="a69a0d60fa083b9a3b03e8f80d3c53e6f" args="(TCPEventCode &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::processPersistTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_c_p_connection_8h.html#a9187fb8d597fec5e53124ffe46c7e85e">TCPEventCode</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#a9008afe23db553e45b37d9811f7af110">processTimer()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// setup and restart the PERSIST timer</span>
    <span class="comment">// FIXME Calculation of PERSIST timer is not as simple as done here!</span>
    <span class="comment">// It depends on RTT calculations and is bounded to 5-60 seconds.</span>
    <span class="comment">// This simplified PERSIST timer calculation generates values</span>
    <span class="comment">// as presented in [Stevens, W.R.: TCP/IP Illustrated, Volume 1, chapter 22.2]</span>
    <span class="comment">// (5, 5, 6, 12, 24, 48, 60, 60, 60...)</span>
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a7085c1927953cb936117333c70b189ca" title="persist factor">persist_factor</a> == 0)
        <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a7085c1927953cb936117333c70b189ca" title="persist factor">persist_factor</a>++;
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a7085c1927953cb936117333c70b189ca" title="persist factor">persist_factor</a> &lt; 64)
        <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a7085c1927953cb936117333c70b189ca" title="persist factor">persist_factor</a> = <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a7085c1927953cb936117333c70b189ca" title="persist factor">persist_factor</a>*2;
    <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ac544a14e6f1287c41195fa8054c272c0" title="current persist timeout">persist_timeout</a> = <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a7085c1927953cb936117333c70b189ca" title="persist factor">persist_factor</a> * 1.5; <span class="comment">// 1.5 is a factor for typical LAN connection [Stevens, W.R.: TCP/IP Ill. Vol. 1, chapter 22.2]</span>

    <span class="comment">// PERSIST timer is bounded to 5-60 seconds</span>
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ac544a14e6f1287c41195fa8054c272c0" title="current persist timeout">persist_timeout</a> &lt; <a class="code" href="flavours_2_t_c_p_base_alg_8cc.html#a71179b5d2b5f89f72c3f808d3af2d3e2">MIN_PERSIST_TIMEOUT</a>)
        <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab7f8905d9eceedd3bdb9afc7da73ccec" title="current retransmission timeout (aka RTO)">rexmit_timeout</a> = <a class="code" href="flavours_2_t_c_p_base_alg_8cc.html#a71179b5d2b5f89f72c3f808d3af2d3e2">MIN_PERSIST_TIMEOUT</a>;
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ac544a14e6f1287c41195fa8054c272c0" title="current persist timeout">persist_timeout</a> &gt; <a class="code" href="flavours_2_t_c_p_base_alg_8cc.html#ad6333c802406519cad9a94d67e1efd6e">MAX_PERSIST_TIMEOUT</a>)
        <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab7f8905d9eceedd3bdb9afc7da73ccec" title="current retransmission timeout (aka RTO)">rexmit_timeout</a> = <a class="code" href="flavours_2_t_c_p_base_alg_8cc.html#ad6333c802406519cad9a94d67e1efd6e">MAX_PERSIST_TIMEOUT</a>;
    <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a60c9fb67af21fc9c1cee62369a8a1486">scheduleTimeout</a>(<a class="code" href="class_t_c_p_base_alg.html#a16b5813e073593fcf194859387efaef3">persistTimer</a>, <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ac544a14e6f1287c41195fa8054c272c0" title="current persist timeout">persist_timeout</a>);

    <span class="comment">// sending persist probe</span>
    <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#ab07a8b0ce79c80e9baf75c3e82f56937">sendProbe</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac8a305a437d4eafd1689204e50af8870"></a><!-- doxytag: member="TCPBaseAlg::processRexmitTimer" ref="ac8a305a437d4eafd1689204e50af8870" args="(TCPEventCode &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::processRexmitTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_c_p_connection_8h.html#a9187fb8d597fec5e53124ffe46c7e85e">TCPEventCode</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="class_t_c_p_new_reno.html#a0ccc1ba18d31b873fab51b8e429aaae1">TCPNewReno</a>, <a class="el" href="class_t_c_p_no_congestion_control.html#acce4963470b581797181af3f924a6433">TCPNoCongestionControl</a>, <a class="el" href="class_t_c_p_reno.html#a8200e1aeef42d932ef24f447beaf25f5">TCPReno</a>, and <a class="el" href="class_t_c_p_tahoe.html#a7e4ea81dbdbfd0eb8321ccf653a6eb00">TCPTahoe</a>.</p>

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#a9008afe23db553e45b37d9811f7af110">processTimer()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;TCB: &quot;</span> &lt;&lt; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a24c5be81ae8c22877d69716f534c3556">info</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

    <span class="comment">//&quot;</span>
    <span class="comment">// For any state if the retransmission timeout expires on a segment in</span>
    <span class="comment">// the retransmission queue, send the segment at the front of the</span>
    <span class="comment">// retransmission queue again, reinitialize the retransmission timer,</span>
    <span class="comment">// and return.</span>
    <span class="comment">//&quot;</span>
    <span class="comment">// Also: abort connection after max 12 retries.</span>
    <span class="comment">//</span>
    <span class="comment">// However, retransmission is actually more complicated than that</span>
    <span class="comment">// in RFC 793 above, we&#39;ll leave it to subclasses (e.g. TCPTahoe, TCPReno).</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (++<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a6957d344e4656f8f815052fda321638b" title="retransmit count">rexmit_count</a> &gt; <a class="code" href="flavours_2_t_c_p_base_alg_8cc.html#ae1c90ad29f7385e9c624af5f695227d9">MAX_REXMIT_COUNT</a>)
    {
        <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;Retransmission count exceeds &quot;</span> &lt;&lt; <a class="code" href="flavours_2_t_c_p_base_alg_8cc.html#ae1c90ad29f7385e9c624af5f695227d9">MAX_REXMIT_COUNT</a> &lt;&lt; <span class="stringliteral">&quot;, aborting connection\n&quot;</span>;
        <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a264eb196b44591ed68422a9e70dab680">signalConnectionTimeout</a>();
        <span class="keyword">event</span> = <a class="code" href="_t_c_p_connection_8h.html#a9187fb8d597fec5e53124ffe46c7e85ea2cc18190ce98d4997975fa624a8e147d">TCP_E_ABORT</a>;  <span class="comment">// TBD maybe rather introduce a TCP_E_TIMEDOUT event</span>
        <span class="keywordflow">return</span>;
    }

    <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;Performing retransmission #&quot;</span> &lt;&lt; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a6957d344e4656f8f815052fda321638b" title="retransmit count">rexmit_count</a>
          &lt;&lt; <span class="stringliteral">&quot;; increasing RTO from &quot;</span> &lt;&lt; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab7f8905d9eceedd3bdb9afc7da73ccec" title="current retransmission timeout (aka RTO)">rexmit_timeout</a> &lt;&lt; <span class="stringliteral">&quot;s &quot;</span>;

    <span class="comment">//</span>
    <span class="comment">// Karn&#39;s algorithm is implemented below:</span>
    <span class="comment">//  (1) don&#39;t measure RTT for retransmitted packets.</span>
    <span class="comment">//  (2) RTO should be doubled after retransmission (&quot;exponential back-off&quot;)</span>
    <span class="comment">//</span>

    <span class="comment">// restart the retransmission timer with twice the latest RTO value, or with the max, whichever is smaller</span>
    <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab7f8905d9eceedd3bdb9afc7da73ccec" title="current retransmission timeout (aka RTO)">rexmit_timeout</a> += <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab7f8905d9eceedd3bdb9afc7da73ccec" title="current retransmission timeout (aka RTO)">rexmit_timeout</a>;
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab7f8905d9eceedd3bdb9afc7da73ccec" title="current retransmission timeout (aka RTO)">rexmit_timeout</a> &gt; <a class="code" href="flavours_2_t_c_p_base_alg_8cc.html#a0770bb727a65bd2bd84b4581d95ca364">MAX_REXMIT_TIMEOUT</a>)
        <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab7f8905d9eceedd3bdb9afc7da73ccec" title="current retransmission timeout (aka RTO)">rexmit_timeout</a> = <a class="code" href="flavours_2_t_c_p_base_alg_8cc.html#a0770bb727a65bd2bd84b4581d95ca364">MAX_REXMIT_TIMEOUT</a>;
    <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a60c9fb67af21fc9c1cee62369a8a1486">scheduleTimeout</a>(<a class="code" href="class_t_c_p_base_alg.html#a2413e27953b03ff929b26b62e9dfe8b0">rexmitTimer</a>, <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab7f8905d9eceedd3bdb9afc7da73ccec" title="current retransmission timeout (aka RTO)">rexmit_timeout</a>);

    <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot; to &quot;</span> &lt;&lt; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab7f8905d9eceedd3bdb9afc7da73ccec" title="current retransmission timeout (aka RTO)">rexmit_timeout</a> &lt;&lt; <span class="stringliteral">&quot;s, and cancelling RTT measurement\n&quot;</span>;

    <span class="comment">// cancel round-trip time measurement</span>
    <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab60db2ccc468ad30634014bb035246e0" title="time when rtseq was sent (0 if RTT measurement is not running)">rtseq_sendtime</a> = 0;

    <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a2ef2adf2cb914469916fd62a99962cf5" title="number of RTOs">numRtos</a>++;
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#a0558fe41bf7f4318f5739a472b8e95fd">numRtosVector</a>)
        <a class="code" href="class_t_c_p_base_alg.html#a0558fe41bf7f4318f5739a472b8e95fd">numRtosVector</a>-&gt;record(<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a2ef2adf2cb914469916fd62a99962cf5" title="number of RTOs">numRtos</a>);

    <span class="comment">// if sacked_enabled reset sack related flags</span>
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a47c0467054bd0209efc992c63d5d4d04">sack_enabled</a>)
    {
        <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a7de9df6b234a7dabb5b5e7eb7520734d">rexmitQueue</a>-&gt;<a class="code" href="class_t_c_p_s_a_c_k_rexmit_queue.html#adfa5c6f04f91b16f9c98258f6ede0052">resetSackedBit</a>();
        <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a7de9df6b234a7dabb5b5e7eb7520734d">rexmitQueue</a>-&gt;<a class="code" href="class_t_c_p_s_a_c_k_rexmit_queue.html#afe96b5040346953484decf38ab2644e5">resetRexmittedBit</a>();

        <span class="comment">// RFC 3517, page 8: &quot;If an RTO occurs during loss recovery as specified in this document,</span>
        <span class="comment">// RecoveryPoint MUST be set to HighData.  Further, the new value of</span>
        <span class="comment">// RecoveryPoint MUST be preserved and the loss recovery algorithm</span>
        <span class="comment">// outlined in this document MUST be terminated.  In addition, a new</span>
        <span class="comment">// recovery phase (as described in section 5) MUST NOT be initiated</span>
        <span class="comment">// until HighACK is greater than or equal to the new value of</span>
        <span class="comment">// RecoveryPoint.&quot;</span>
        <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a69fd5385780f1352abd11bbbc2c2c2ef">lossRecovery</a>)
        {
            <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a4bf93e62de5a888f200f3bce908913af">recoveryPoint</a> = <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a220683addcd800e00fc59f348b40cff2">snd_max</a>; <span class="comment">// HighData = snd_max</span>
            <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;Loss Recovery terminated.\n&quot;</span>;
            <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a69fd5385780f1352abd11bbbc2c2c2ef">lossRecovery</a> = <span class="keyword">false</span>;
        }
    }

    <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a8ac5ae9db4029d0f8a6cff75297fa2c8">time_last_data_sent</a> = simTime();

    <span class="comment">//</span>
    <span class="comment">// Leave congestion window management and actual retransmission to</span>
    <span class="comment">// subclasses (e.g. TCPTahoe, TCPReno).</span>
    <span class="comment">//</span>
    <span class="comment">// That is, subclasses will redefine this method, call us, then perform</span>
    <span class="comment">// window adjustments and do the retransmission as they like.</span>
    <span class="comment">//</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9008afe23db553e45b37d9811f7af110"></a><!-- doxytag: member="TCPBaseAlg::processTimer" ref="a9008afe23db553e45b37d9811f7af110" args="(cMessage *timer, TCPEventCode &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::processTimer </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_c_p_connection_8h.html#a9187fb8d597fec5e53124ffe46c7e85e">TCPEventCode</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Process REXMIT, PERSIST, DELAYED-ACK and KEEP-ALIVE timers. </p>

<p>Implements <a class="el" href="class_t_c_p_algorithm.html#afa586de40374ffd9830981fff79cf96c">TCPAlgorithm</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (timer==<a class="code" href="class_t_c_p_base_alg.html#a2413e27953b03ff929b26b62e9dfe8b0">rexmitTimer</a>)
        <a class="code" href="class_t_c_p_base_alg.html#ac8a305a437d4eafd1689204e50af8870">processRexmitTimer</a>(event);
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (timer==<a class="code" href="class_t_c_p_base_alg.html#a16b5813e073593fcf194859387efaef3">persistTimer</a>)
        <a class="code" href="class_t_c_p_base_alg.html#a69a0d60fa083b9a3b03e8f80d3c53e6f">processPersistTimer</a>(event);
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (timer==<a class="code" href="class_t_c_p_base_alg.html#aba8d2462619e5aa1106b992c3361c3fb">delayedAckTimer</a>)
        <a class="code" href="class_t_c_p_base_alg.html#ad5f7c065fdf27a650a7c711cf8e31766">processDelayedAckTimer</a>(event);
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (timer==<a class="code" href="class_t_c_p_base_alg.html#a7eee3af489bedb3010ff637fe848d232">keepAliveTimer</a>)
        <a class="code" href="class_t_c_p_base_alg.html#a586dd4192388dc907ab36ae4aec4c3d5">processKeepAliveTimer</a>(event);
    <span class="keywordflow">else</span>
        <span class="keywordflow">throw</span> cRuntimeError(timer, <span class="stringliteral">&quot;unrecognized timer&quot;</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8d57787d474f4a317bffa76c8f13ef3a"></a><!-- doxytag: member="TCPBaseAlg::receivedAckForDataNotYetSent" ref="a8d57787d474f4a317bffa76c8f13ef3a" args="(uint32 seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::receivedAckForDataNotYetSent </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called after we received an ACK for data not yet sent. According to RFC 793 this function should send an ACK. </p>

<p>Implements <a class="el" href="class_t_c_p_algorithm.html#a113d03b1de3e1b788ae95635d69e064d">TCPAlgorithm</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// Note: In this case no immediate ACK will be send because not mentioned</span>
    <span class="comment">// in [Stevens, W.R.: TCP/IP Illustrated, Volume 2, page 861].</span>
    <span class="comment">// To force immediate ACK use:</span>
        <span class="comment">// state-&gt;ack_now = true;</span>
        <span class="comment">// tcpEV &lt;&lt; &quot;ACK acks something not yet sent, sending immediate ACK\n&quot;;</span>
    <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;ACK acks something not yet sent, sending ACK\n&quot;</span>;
    <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a60ee5bc5b391d621e7e684857e195151">sendAck</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a55a32a0e93c6417adb091ee162f225e2"></a><!-- doxytag: member="TCPBaseAlg::receivedDataAck" ref="a55a32a0e93c6417adb091ee162f225e2" args="(uint32 firstSeqAcked)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::receivedDataAck </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>firstSeqAcked</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called after we received an ACK which acked some data (that is, we could advance snd_una). At this point the state variables (snd_una, snd_wnd) have already been updated. The argument firstSeqAcked is the previous snd_una value, that is, the number of bytes acked is (snd_una-firstSeqAcked). The dupack counter still reflects the old value (needed for Reno and NewReno); it'll be reset to 0 after this call returns. </p>

<p>Implements <a class="el" href="class_t_c_p_algorithm.html#abe5d8e8c02ba34cd5c50eca71824b81e">TCPAlgorithm</a>.</p>

<p>Reimplemented in <a class="el" href="class_t_c_p_new_reno.html#a634da20c5ad064882d2c87f6f5ff1301">TCPNewReno</a>, <a class="el" href="class_t_c_p_no_congestion_control.html#a9e68b13f66146c853c5032476138a123">TCPNoCongestionControl</a>, <a class="el" href="class_t_c_p_reno.html#a346296d9fcd3056d1add56d2f03dd391">TCPReno</a>, and <a class="el" href="class_t_c_p_tahoe.html#ab0f1ac1b45b76e45ad5b0ff24faaac80">TCPTahoe</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (!<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#aea39bfb1176d367d349fb4efcbbe807f">ts_enabled</a>)
    {
        <span class="comment">// if round-trip time measurement is running, check if rtseq has been acked</span>
        <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab60db2ccc468ad30634014bb035246e0" title="time when rtseq was sent (0 if RTT measurement is not running)">rtseq_sendtime</a>!=0 &amp;&amp; <a class="code" href="_t_c_p_segment_8h.html#aa2e84a0093c6f222b12a4b443c7278eb">seqLess</a>(<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a1f7c0b7477430b752550a4778afc913e" title="round-trip time measurements">rtseq</a>, <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a3a8a7f455c793cf894e22d4d72dbdc93">snd_una</a>))
        {
            <span class="comment">// print value</span>
            <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;Round-trip time measured on rtseq=&quot;</span> &lt;&lt; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a1f7c0b7477430b752550a4778afc913e" title="round-trip time measurements">rtseq</a> &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>
                  &lt;&lt; floor((simTime() - <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab60db2ccc468ad30634014bb035246e0" title="time when rtseq was sent (0 if RTT measurement is not running)">rtseq_sendtime</a>)*1000+0.5) &lt;&lt; <span class="stringliteral">&quot;ms\n&quot;</span>;

            <a class="code" href="class_t_c_p_base_alg.html#a31986bf6db565ab455f818eafb01320e">rttMeasurementComplete</a>(<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab60db2ccc468ad30634014bb035246e0" title="time when rtseq was sent (0 if RTT measurement is not running)">rtseq_sendtime</a>, simTime()); <span class="comment">// update RTT variables with new value</span>

            <span class="comment">// measurement finished</span>
            <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab60db2ccc468ad30634014bb035246e0" title="time when rtseq was sent (0 if RTT measurement is not running)">rtseq_sendtime</a> = 0;
        }
    }

    <span class="comment">//</span>
    <span class="comment">// handling of retransmission timer: if the ACK is for the last segment sent</span>
    <span class="comment">// (no data in flight), cancel the timer, otherwise restart the timer</span>
    <span class="comment">// with the current RTO value.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a3a8a7f455c793cf894e22d4d72dbdc93">snd_una</a>==<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a220683addcd800e00fc59f348b40cff2">snd_max</a>)
    {
        <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#a2413e27953b03ff929b26b62e9dfe8b0">rexmitTimer</a>-&gt;isScheduled())
        {
            <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;ACK acks all outstanding segments, cancel REXMIT timer\n&quot;</span>;
            <a class="code" href="class_t_c_p_base_alg.html#afc54d88f3abc5f0956e1d4d6c3d5c206">cancelEvent</a>(<a class="code" href="class_t_c_p_base_alg.html#a2413e27953b03ff929b26b62e9dfe8b0">rexmitTimer</a>);
        }
        <span class="keywordflow">else</span>
            <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;There were no outstanding segments, nothing new in this ACK.\n&quot;</span>;
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;ACK acks some but not all outstanding segments (&quot;</span>
              &lt;&lt; (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a220683addcd800e00fc59f348b40cff2">snd_max</a> - <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a3a8a7f455c793cf894e22d4d72dbdc93">snd_una</a>) &lt;&lt; <span class="stringliteral">&quot; bytes outstanding), &quot;</span>
              &lt;&lt; <span class="stringliteral">&quot;restarting REXMIT timer\n&quot;</span>;
        <a class="code" href="class_t_c_p_base_alg.html#afc54d88f3abc5f0956e1d4d6c3d5c206">cancelEvent</a>(<a class="code" href="class_t_c_p_base_alg.html#a2413e27953b03ff929b26b62e9dfe8b0">rexmitTimer</a>);
        <a class="code" href="class_t_c_p_base_alg.html#a5fc842a3f9c5297e9ba795843bf0cabb">startRexmitTimer</a>();
    }

    <span class="comment">//</span>
    <span class="comment">// handling of PERSIST timer:</span>
    <span class="comment">// If data sender received a zero-sized window, check retransmission timer.</span>
    <span class="comment">//  If retransmission timer is not scheduled, start PERSIST timer if not already</span>
    <span class="comment">//  running.</span>
    <span class="comment">//</span>
    <span class="comment">// If data sender received a non zero-sized window, check PERSIST timer.</span>
    <span class="comment">//  If PERSIST timer is scheduled, cancel PERSIST timer.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#aef29087f473f09bfb53eca0f652386d4">snd_wnd</a>==0) <span class="comment">// received zero-sized window?</span>
    {
        <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#a2413e27953b03ff929b26b62e9dfe8b0">rexmitTimer</a>-&gt;isScheduled())
        {
            <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#a16b5813e073593fcf194859387efaef3">persistTimer</a>-&gt;isScheduled())
            {
                <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;Received zero-sized window and REXMIT timer is running therefore PERSIST timer is canceled.\n&quot;</span>;
                <a class="code" href="class_t_c_p_base_alg.html#afc54d88f3abc5f0956e1d4d6c3d5c206">cancelEvent</a>(<a class="code" href="class_t_c_p_base_alg.html#a16b5813e073593fcf194859387efaef3">persistTimer</a>);
                <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a7085c1927953cb936117333c70b189ca" title="persist factor">persist_factor</a> = 0;
            }
            <span class="keywordflow">else</span>
                <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;Received zero-sized window and REXMIT timer is running therefore PERSIST timer is not started.\n&quot;</span>;
        }
        <span class="keywordflow">else</span>
        {
            <span class="keywordflow">if</span> (!<a class="code" href="class_t_c_p_base_alg.html#a16b5813e073593fcf194859387efaef3">persistTimer</a>-&gt;isScheduled())
            {
                <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;Received zero-sized window therefore PERSIST timer is started.\n&quot;</span>;
                <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a60c9fb67af21fc9c1cee62369a8a1486">scheduleTimeout</a>(<a class="code" href="class_t_c_p_base_alg.html#a16b5813e073593fcf194859387efaef3">persistTimer</a>, <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ac544a14e6f1287c41195fa8054c272c0" title="current persist timeout">persist_timeout</a>);
            }
            <span class="keywordflow">else</span>
                <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;Received zero-sized window and PERSIST timer is already running.\n&quot;</span>;
        }
    }
    <span class="keywordflow">else</span> <span class="comment">// received non zero-sized window?</span>
    {
        <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#a16b5813e073593fcf194859387efaef3">persistTimer</a>-&gt;isScheduled())
        {
            <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;Received non zero-sized window therefore PERSIST timer is canceled.\n&quot;</span>;
            <a class="code" href="class_t_c_p_base_alg.html#afc54d88f3abc5f0956e1d4d6c3d5c206">cancelEvent</a>(<a class="code" href="class_t_c_p_base_alg.html#a16b5813e073593fcf194859387efaef3">persistTimer</a>);
            <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a7085c1927953cb936117333c70b189ca" title="persist factor">persist_factor</a> = 0;
        }
    }

    <span class="comment">//</span>
    <span class="comment">// Leave congestion window management and possible sending data to</span>
    <span class="comment">// subclasses (e.g. TCPTahoe, TCPReno).</span>
    <span class="comment">//</span>
    <span class="comment">// That is, subclasses will redefine this method, call us, then perform</span>
    <span class="comment">// window adjustments and send data (if there&#39;s room in the window).</span>
    <span class="comment">//</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad198abc5a259c9b1660ec149aae3b11d"></a><!-- doxytag: member="TCPBaseAlg::receivedDuplicateAck" ref="ad198abc5a259c9b1660ec149aae3b11d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::receivedDuplicateAck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called after we received a duplicate ACK (that is: ackNo==snd_una, no data in segment, segment doesn't carry window update, and also, we have unacked data). The dupack counter got already updated when calling this method (i.e. dupack==1 on first duplicate ACK.) </p>

<p>Implements <a class="el" href="class_t_c_p_algorithm.html#a83a8916731ff5ce73e5d4f05d8ae6d30">TCPAlgorithm</a>.</p>

<p>Reimplemented in <a class="el" href="class_t_c_p_new_reno.html#a6ce5b0435826f11b9a459b66d7e8aee8">TCPNewReno</a>, <a class="el" href="class_t_c_p_reno.html#adcf0d263e1c1551648ff9b52dff8326f">TCPReno</a>, and <a class="el" href="class_t_c_p_tahoe.html#a5c9cd2ff02da7ddc8c1578b0e6a81236">TCPTahoe</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;Duplicate ACK #&quot;</span> &lt;&lt; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#ae3ddd98e68751df8e6a8f4c0c7081f28">dupacks</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

    <span class="keywordtype">bool</span> fullSegmentsOnly = <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#ad0a43b2fd46e7659e79c3cfd90c926a2">nagle_enabled</a> &amp;&amp; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a3a8a7f455c793cf894e22d4d72dbdc93">snd_una</a>!=<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a220683addcd800e00fc59f348b40cff2">snd_max</a>;
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#ae3ddd98e68751df8e6a8f4c0c7081f28">dupacks</a> &lt; <a class="code" href="_t_c_p_connection_8h.html#a6d22725191167fb4feaacff2c1291afd">DUPTHRESH</a> &amp;&amp; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a406b24dd2a997eae7618c762dfe2e48d">limited_transmit_enabled</a>) <span class="comment">// DUPTRESH = 3</span>
        <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a35768c6517e5f25424a13d1e80892b32">sendOneNewSegment</a>(fullSegmentsOnly, <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a36b9d4c46519bcd7a094462c68881ce9">snd_cwnd</a>); <span class="comment">// RFC 3042</span>

    <span class="comment">//</span>
    <span class="comment">// Leave to subclasses (e.g. TCPTahoe, TCPReno) whatever they want to do</span>
    <span class="comment">// on duplicate Acks.</span>
    <span class="comment">//</span>
    <span class="comment">// That is, subclasses will redefine this method, call us, then perform</span>
    <span class="comment">// whatever action they want to do on dupAcks (e.g. retransmitting one segment).</span>
    <span class="comment">//</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa49a6c59e453685907e24dc671e3561d"></a><!-- doxytag: member="TCPBaseAlg::receivedOutOfOrderSegment" ref="aa49a6c59e453685907e24dc671e3561d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::receivedOutOfOrderSegment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called after receiving data which are in the window, but not at its left edge (seq!=rcv_nxt). This indicates that either segments got re-ordered in the way, or one segment was lost. RFC 1122 and RFC 2001 recommend sending an immediate ACK here (Fast Retransmit relies on that). </p>

<p>Implements <a class="el" href="class_t_c_p_algorithm.html#a10903af17a26011a95b6745eb80f65ed">TCPAlgorithm</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#ac945d97e6a37246ca8cf3648e01a8a26">ack_now</a> = <span class="keyword">true</span>;
    <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;Out-of-order segment, sending immediate ACK\n&quot;</span>;
    <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a60ee5bc5b391d621e7e684857e195151">sendAck</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a772c3712679d50b0598957665b14acc9"></a><!-- doxytag: member="TCPBaseAlg::receiveSeqChanged" ref="a772c3712679d50b0598957665b14acc9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::receiveSeqChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called after rcv_nxt got advanced, either because we received in-sequence data ("text" in RFC 793 lingo) or a FIN. At this point, rcv_nxt has already been updated. This method should take care to send or schedule an ACK some time. </p>

<p>Implements <a class="el" href="class_t_c_p_algorithm.html#abb6b842fa0651f13c99b30adebcc0e03">TCPAlgorithm</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// If we send a data segment already (with the updated seqNo) there is no need to send an additional ACK</span>
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a5d47c2c046bb9fe704be153bb0731e9a">full_sized_segment_counter</a> == 0 &amp;&amp; !<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#ac945d97e6a37246ca8cf3648e01a8a26">ack_now</a> &amp;&amp; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#abfbcb8fed25793f011ff32a6dc6ee722">last_ack_sent</a> == <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a5b9de18a3fb71fab5a540f98173b12b1">rcv_nxt</a> &amp;&amp; !<a class="code" href="class_t_c_p_base_alg.html#aba8d2462619e5aa1106b992c3361c3fb">delayedAckTimer</a>-&gt;isScheduled()) <span class="comment">// ackSent?</span>
    {
        <span class="comment">// tcpEV &lt;&lt; &quot;ACK has already been sent (possibly piggybacked on data)\n&quot;;</span>
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">// RFC 2581, page 6:</span>
        <span class="comment">// &quot;3.2 Fast Retransmit/Fast Recovery</span>
        <span class="comment">// (...)</span>
        <span class="comment">// In addition, a TCP receiver SHOULD send an immediate ACK</span>
        <span class="comment">// when the incoming segment fills in all or part of a gap in the</span>
        <span class="comment">// sequence space.&quot;</span>
        <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a69fd5385780f1352abd11bbbc2c2c2ef">lossRecovery</a>)
            <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#ac945d97e6a37246ca8cf3648e01a8a26">ack_now</a> = <span class="keyword">true</span>; <span class="comment">// although not mentioned in [Stevens, W.R.: TCP/IP Illustrated, Volume 2, page 861] seems like we have to set ack_now</span>

        <span class="keywordflow">if</span> (!<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a43536d5fd1e75c068cbcfe4ccf8fc79d">delayed_acks_enabled</a>) <span class="comment">// delayed ACK disabled</span>
        {
            <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;rcv_nxt changed to &quot;</span> &lt;&lt; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a5b9de18a3fb71fab5a540f98173b12b1">rcv_nxt</a> &lt;&lt; <span class="stringliteral">&quot;, (delayed ACK disabled) sending ACK now\n&quot;</span>;
            <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a60ee5bc5b391d621e7e684857e195151">sendAck</a>();
        }
        <span class="keywordflow">else</span> <span class="comment">// delayed ACK enabled</span>
        {
            <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#ac945d97e6a37246ca8cf3648e01a8a26">ack_now</a>)
            {
                <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;rcv_nxt changed to &quot;</span> &lt;&lt; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a5b9de18a3fb71fab5a540f98173b12b1">rcv_nxt</a> &lt;&lt; <span class="stringliteral">&quot;, (delayed ACK enabled, but ack_now is set) sending ACK now\n&quot;</span>;
                <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a60ee5bc5b391d621e7e684857e195151">sendAck</a>();
            }
            <span class="comment">// RFC 1122, page 96: &quot;in a stream of full-sized segments there SHOULD be an ACK for at least every second segment.&quot;</span>
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a5d47c2c046bb9fe704be153bb0731e9a">full_sized_segment_counter</a> &gt;= 2)
            {
                <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;rcv_nxt changed to &quot;</span> &lt;&lt; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a5b9de18a3fb71fab5a540f98173b12b1">rcv_nxt</a> &lt;&lt; <span class="stringliteral">&quot;, (delayed ACK enabled, but full_sized_segment_counter=&quot;</span> &lt;&lt; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a5d47c2c046bb9fe704be153bb0731e9a">full_sized_segment_counter</a> &lt;&lt; <span class="stringliteral">&quot;) sending ACK now\n&quot;</span>;
                <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a60ee5bc5b391d621e7e684857e195151">sendAck</a>();
            }
            <span class="keywordflow">else</span>
            {
                <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;rcv_nxt changed to &quot;</span> &lt;&lt; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a5b9de18a3fb71fab5a540f98173b12b1">rcv_nxt</a> &lt;&lt; <span class="stringliteral">&quot;, (delayed ACK enabled and full_sized_segment_counter=&quot;</span> &lt;&lt; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a5d47c2c046bb9fe704be153bb0731e9a">full_sized_segment_counter</a> &lt;&lt; <span class="stringliteral">&quot;) scheduling ACK\n&quot;</span>;
                <span class="keywordflow">if</span> (!<a class="code" href="class_t_c_p_base_alg.html#aba8d2462619e5aa1106b992c3361c3fb">delayedAckTimer</a>-&gt;isScheduled()) <span class="comment">// schedule delayed ACK timer if not already running</span>
                    <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a60c9fb67af21fc9c1cee62369a8a1486">scheduleTimeout</a>(<a class="code" href="class_t_c_p_base_alg.html#aba8d2462619e5aa1106b992c3361c3fb">delayedAckTimer</a>, <a class="code" href="flavours_2_t_c_p_base_alg_8cc.html#a54b7d4e007b4463accfe09a7238ccecb">DELAYED_ACK_TIMEOUT</a>);
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa781a26258eb0504bfff79468079e1b8"></a><!-- doxytag: member="TCPBaseAlg::restartRexmitTimer" ref="aa781a26258eb0504bfff79468079e1b8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::restartRexmitTimer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Restart REXMIT timer. </p>

<p>Implements <a class="el" href="class_t_c_p_algorithm.html#a3369b0b0441f0d5a5400b95f7bbe1f22">TCPAlgorithm</a>.</p>

<p>Referenced by <a class="el" href="class_t_c_p_new_reno.html#a634da20c5ad064882d2c87f6f5ff1301">TCPNewReno::receivedDataAck()</a>, and <a class="el" href="class_t_c_p_reno.html#adcf0d263e1c1551648ff9b52dff8326f">TCPReno::receivedDuplicateAck()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#a2413e27953b03ff929b26b62e9dfe8b0">rexmitTimer</a>-&gt;isScheduled())
        <a class="code" href="class_t_c_p_base_alg.html#afc54d88f3abc5f0956e1d4d6c3d5c206">cancelEvent</a>(<a class="code" href="class_t_c_p_base_alg.html#a2413e27953b03ff929b26b62e9dfe8b0">rexmitTimer</a>);
    <a class="code" href="class_t_c_p_base_alg.html#a5fc842a3f9c5297e9ba795843bf0cabb">startRexmitTimer</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a31986bf6db565ab455f818eafb01320e"></a><!-- doxytag: member="TCPBaseAlg::rttMeasurementComplete" ref="a31986bf6db565ab455f818eafb01320e" args="(simtime_t tSent, simtime_t tAcked)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::rttMeasurementComplete </td>
          <td>(</td>
          <td class="paramtype">simtime_t&#160;</td>
          <td class="paramname"><em>tSent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&#160;</td>
          <td class="paramname"><em>tAcked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update state vars with new measured RTT value. Passing two simtime_t's will allow <a class="el" href="class_t_c_p_base_alg.html#a31986bf6db565ab455f818eafb01320e">rttMeasurementComplete()</a> to do calculations in double or in 200ms/500ms ticks, as needed) </p>

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#a55a32a0e93c6417adb091ee162f225e2">receivedDataAck()</a>, and <a class="el" href="class_t_c_p_base_alg.html#a7515afa05f1ae81306d10824d4940a54">rttMeasurementCompleteUsingTS()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Jacobson&#39;s algorithm for estimating RTT and adaptively setting RTO.</span>
    <span class="comment">//</span>
    <span class="comment">// Note: this implementation calculates in doubles. An impl. which uses</span>
    <span class="comment">// 500ms ticks is available from old tcpmodule.cc:calcRetransTimer().</span>
    <span class="comment">//</span>

    <span class="comment">// update smoothed RTT estimate (srtt) and variance (rttvar)</span>
    <span class="keyword">const</span> <span class="keywordtype">double</span> g = 0.125; <span class="comment">// 1/8; (1-alpha) where alpha=7/8;</span>
    simtime_t newRTT = tAcked-tSent;

    simtime_t&amp; srtt = <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a3fbc98ec258009121b47acc9a5d74a26" title="round-trip time estimation (Jacobson&#39;s algorithm)">srtt</a>;
    simtime_t&amp; rttvar = <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#abc6803555218c740e069bc3d6a7ed3e0" title="variance of round-trip time">rttvar</a>;

    simtime_t err = newRTT - srtt;

    srtt += g*err;
    rttvar += g*(fabs(err) - rttvar);

    <span class="comment">// assign RTO (here: rexmit_timeout) a new value</span>
    simtime_t rto = srtt + 4*rttvar;
    <span class="keywordflow">if</span> (rto&gt;<a class="code" href="flavours_2_t_c_p_base_alg_8cc.html#a0770bb727a65bd2bd84b4581d95ca364">MAX_REXMIT_TIMEOUT</a>)
        rto = <a class="code" href="flavours_2_t_c_p_base_alg_8cc.html#a0770bb727a65bd2bd84b4581d95ca364">MAX_REXMIT_TIMEOUT</a>;
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rto&lt;<a class="code" href="flavours_2_t_c_p_base_alg_8cc.html#aaa64073abed4e79e958d3f8f048f6762">MIN_REXMIT_TIMEOUT</a>)
        rto = <a class="code" href="flavours_2_t_c_p_base_alg_8cc.html#aaa64073abed4e79e958d3f8f048f6762">MIN_REXMIT_TIMEOUT</a>;

    <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab7f8905d9eceedd3bdb9afc7da73ccec" title="current retransmission timeout (aka RTO)">rexmit_timeout</a> = rto;

    <span class="comment">// record statistics</span>
    <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;Measured RTT=&quot;</span> &lt;&lt; (newRTT*1000) &lt;&lt; <span class="stringliteral">&quot;ms, updated SRTT=&quot;</span> &lt;&lt; (srtt*1000)
          &lt;&lt; <span class="stringliteral">&quot;ms, new RTO=&quot;</span> &lt;&lt; (rto*1000) &lt;&lt; <span class="stringliteral">&quot;ms\n&quot;</span>;
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad4718c9463f32652274f266cf0959575">rttVector</a>) <a class="code" href="class_t_c_p_base_alg.html#ad4718c9463f32652274f266cf0959575">rttVector</a>-&gt;record(newRTT);
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#a08ecae944120c1a57b4d0349fef1f98b">srttVector</a>) <a class="code" href="class_t_c_p_base_alg.html#a08ecae944120c1a57b4d0349fef1f98b">srttVector</a>-&gt;record(srtt);
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#a27e1885fc2811db6bb92761d99168c26">rttvarVector</a>) <a class="code" href="class_t_c_p_base_alg.html#a27e1885fc2811db6bb92761d99168c26">rttvarVector</a>-&gt;record(rttvar);
    <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#a81f6ee9e817cc9225e00ce2945c5e4bf">rtoVector</a>) <a class="code" href="class_t_c_p_base_alg.html#a81f6ee9e817cc9225e00ce2945c5e4bf">rtoVector</a>-&gt;record(rto);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7515afa05f1ae81306d10824d4940a54"></a><!-- doxytag: member="TCPBaseAlg::rttMeasurementCompleteUsingTS" ref="a7515afa05f1ae81306d10824d4940a54" args="(uint32 echoedTS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::rttMeasurementCompleteUsingTS </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>echoedTS</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converting uint32 echoedTS to simtime_t and calling <a class="el" href="class_t_c_p_base_alg.html#a31986bf6db565ab455f818eafb01320e">rttMeasurementComplete()</a> to update state vars with new measured RTT value. </p>

<p>Implements <a class="el" href="class_t_c_p_algorithm.html#ac2660d1b53bdca9a6b1cb54a7cee7ad6">TCPAlgorithm</a>.</p>
<div class="fragment"><pre class="fragment">{
    ASSERT (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#aea39bfb1176d367d349fb4efcbbe807f">ts_enabled</a>);
    <span class="comment">// Note: The TS option is using uint32 values (ms precision) therefore we convert the current simTime also to a uint32 value (ms precision)</span>
    <span class="comment">// and then convert back to simtime_t to use rttMeasurementComplete() to update srtt and rttvar</span>
    uint32 now = <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#ad2ab4393f60b26351d445334d4626cc7">convertSimtimeToTS</a>(simTime());
    simtime_t tSent = <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#af8c2c97216e867103c61e0b6393ba625">convertTSToSimtime</a>(echoedTS);
    simtime_t tAcked = <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#af8c2c97216e867103c61e0b6393ba625">convertTSToSimtime</a>(now);
    <a class="code" href="class_t_c_p_base_alg.html#a31986bf6db565ab455f818eafb01320e">rttMeasurementComplete</a>(tSent, tAcked);
}
</pre></div>
</div>
</div>
<a class="anchor" id="adeb5f45e211987af985c94992dc3350f"></a><!-- doxytag: member="TCPBaseAlg::sendCommandInvoked" ref="adeb5f45e211987af985c94992dc3350f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::sendCommandInvoked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called after user sent TCP_C_SEND command to us. </p>

<p>Implements <a class="el" href="class_t_c_p_algorithm.html#a4f091f7203a1813550bcad5738e815cb">TCPAlgorithm</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// try sending</span>
    <a class="code" href="class_t_c_p_base_alg.html#a28c072f575629d0c5ec6478edd3bb7e5">sendData</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a28c072f575629d0c5ec6478edd3bb7e5"></a><!-- doxytag: member="TCPBaseAlg::sendData" ref="a28c072f575629d0c5ec6478edd3bb7e5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TCPBaseAlg::sendData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send data, observing Nagle's algorithm and congestion window </p>

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#a2cbb83fb79f28eaea3d33acb13526e11">established()</a>, <a class="el" href="class_t_c_p_tahoe.html#ab0f1ac1b45b76e45ad5b0ff24faaac80">TCPTahoe::receivedDataAck()</a>, <a class="el" href="class_t_c_p_reno.html#a346296d9fcd3056d1add56d2f03dd391">TCPReno::receivedDataAck()</a>, <a class="el" href="class_t_c_p_no_congestion_control.html#a9e68b13f66146c853c5032476138a123">TCPNoCongestionControl::receivedDataAck()</a>, <a class="el" href="class_t_c_p_new_reno.html#a634da20c5ad064882d2c87f6f5ff1301">TCPNewReno::receivedDataAck()</a>, <a class="el" href="class_t_c_p_reno.html#adcf0d263e1c1551648ff9b52dff8326f">TCPReno::receivedDuplicateAck()</a>, <a class="el" href="class_t_c_p_new_reno.html#a6ce5b0435826f11b9a459b66d7e8aee8">TCPNewReno::receivedDuplicateAck()</a>, and <a class="el" href="class_t_c_p_base_alg.html#adeb5f45e211987af985c94992dc3350f">sendCommandInvoked()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Nagle&#39;s algorithm: when a TCP connection has outstanding data that has not</span>
    <span class="comment">// yet been acknowledged, small segments cannot be sent until the outstanding</span>
    <span class="comment">// data is acknowledged. (In this case, small amounts of data are collected</span>
    <span class="comment">// by TCP and sent in a single segment.)</span>
    <span class="comment">//</span>
    <span class="comment">// FIXME there&#39;s also something like this: can still send if</span>
    <span class="comment">// &quot;b) a segment that can be sent is at least half the size of</span>
    <span class="comment">// the largest window ever advertised by the receiver&quot;</span>

    <span class="keywordtype">bool</span> fullSegmentsOnly = <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#ad0a43b2fd46e7659e79c3cfd90c926a2">nagle_enabled</a> &amp;&amp; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a3a8a7f455c793cf894e22d4d72dbdc93">snd_una</a>!=<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a220683addcd800e00fc59f348b40cff2">snd_max</a>;
    <span class="keywordflow">if</span> (fullSegmentsOnly)
        <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;Nagle is enabled and there&#39;s unacked data: only full segments will be sent\n&quot;</span>;

    <span class="comment">// RFC 2581, pages 7 and 8: &quot;When TCP has not received a segment for</span>
    <span class="comment">// more than one retransmission timeout, cwnd is reduced to the value</span>
    <span class="comment">// of the restart window (RW) before transmission begins.</span>
    <span class="comment">// For the purposes of this standard, we define RW = IW.</span>
    <span class="comment">// (...)</span>
    <span class="comment">// Using the last time a segment was received to determine whether or</span>
    <span class="comment">// not to decrease cwnd fails to deflate cwnd in the common case of</span>
    <span class="comment">// persistent HTTP connections [HTH98].</span>
    <span class="comment">// (...)</span>
    <span class="comment">// Therefore, a TCP SHOULD set cwnd to no more than RW before beginning</span>
    <span class="comment">// transmission if the TCP has not sent data in an interval exceeding</span>
    <span class="comment">// the retransmission timeout.&quot;</span>
    <span class="keywordflow">if</span> (!<a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#aafbfa20356a296e70ca483daa9132460">isSendQueueEmpty</a>())  <span class="comment">// do we have any data to send?</span>
    {
        <span class="keywordflow">if</span> ((simTime() - <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a8ac5ae9db4029d0f8a6cff75297fa2c8">time_last_data_sent</a>) &gt; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab7f8905d9eceedd3bdb9afc7da73ccec" title="current retransmission timeout (aka RTO)">rexmit_timeout</a>)
        {
            <span class="comment">// RFC 5681, page 11: &quot;For the purposes of this standard, we define RW = min(IW,cwnd).&quot;</span>
            <span class="keywordflow">if</span> (<a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a7c3d5a7916b1d457f6065c488684d1d5">increased_IW_enabled</a>)
                <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a36b9d4c46519bcd7a094462c68881ce9">snd_cwnd</a> = <a class="code" href="_s_c_t_p_association_8h.html#ad61931b1ae6b8e5bb714e2e6744f4470">std::min</a> (<a class="code" href="_s_c_t_p_association_8h.html#ad61931b1ae6b8e5bb714e2e6744f4470">std::min</a> (4 * <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a2d9952d560079e7a0cf44f2308ac564f">snd_mss</a>, <a class="code" href="_s_c_t_p_association_8h.html#afdb84bd44c7cbd3fc9cbe1e3bf07d948">std::max</a>(2 * <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a2d9952d560079e7a0cf44f2308ac564f">snd_mss</a>, (uint32)4380)), <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a36b9d4c46519bcd7a094462c68881ce9">snd_cwnd</a>);
            <span class="keywordflow">else</span>
                <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a36b9d4c46519bcd7a094462c68881ce9">snd_cwnd</a> = <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_state_variables.html#a2d9952d560079e7a0cf44f2308ac564f">snd_mss</a>;
            <a class="code" href="_t_c_p_8h.html#a601325e92d65fe658c80eab711e12304">tcpEV</a> &lt;&lt; <span class="stringliteral">&quot;Restarting idle connection, CWND is set to: &quot;</span> &lt;&lt; <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a36b9d4c46519bcd7a094462c68881ce9">snd_cwnd</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
        }
    }

    <span class="comment">//</span>
    <span class="comment">// Send window is effectively the minimum of the congestion window (cwnd)</span>
    <span class="comment">// and the advertised window (snd_wnd).</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span> <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a0238c323366884c6598d7d92d21f69ab">sendData</a>(fullSegmentsOnly, <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a36b9d4c46519bcd7a094462c68881ce9">snd_cwnd</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5fc842a3f9c5297e9ba795843bf0cabb"></a><!-- doxytag: member="TCPBaseAlg::startRexmitTimer" ref="a5fc842a3f9c5297e9ba795843bf0cabb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCPBaseAlg::startRexmitTimer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start REXMIT timer and initialize retransmission variables </p>

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#a8bbd5e8c6d8b139da0cbc44a3274c9fa">dataSent()</a>, <a class="el" href="class_t_c_p_base_alg.html#a55a32a0e93c6417adb091ee162f225e2">receivedDataAck()</a>, and <a class="el" href="class_t_c_p_base_alg.html#aa781a26258eb0504bfff79468079e1b8">restartRexmitTimer()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// start counting retransmissions for this seq number.</span>
    <span class="comment">// Note: state-&gt;rexmit_timeout is set from rttMeasurementComplete().</span>
    <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#a6957d344e4656f8f815052fda321638b" title="retransmit count">rexmit_count</a> = 0;

    <span class="comment">// schedule timer</span>
    <a class="code" href="class_t_c_p_algorithm.html#a20273a398c4165b45243d9c125c2637b">conn</a>-&gt;<a class="code" href="class_t_c_p_connection.html#a60c9fb67af21fc9c1cee62369a8a1486">scheduleTimeout</a>(<a class="code" href="class_t_c_p_base_alg.html#a2413e27953b03ff929b26b62e9dfe8b0">rexmitTimer</a>, <a class="code" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">state</a>-&gt;<a class="code" href="class_t_c_p_base_alg_state_variables.html#ab7f8905d9eceedd3bdb9afc7da73ccec" title="current retransmission timeout (aka RTO)">rexmit_timeout</a>);
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a9e6f430f3a5463137d416627f4282d64"></a><!-- doxytag: member="TCPBaseAlg::cwndVector" ref="a9e6f430f3a5463137d416627f4282d64" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cOutVector* <a class="el" href="class_t_c_p_base_alg.html#a9e6f430f3a5463137d416627f4282d64">TCPBaseAlg::cwndVector</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#ae6147731689fcc4c5c79f4cc539c6b7f">initialize()</a>, <a class="el" href="class_t_c_p_tahoe.html#a7e4ea81dbdbfd0eb8321ccf653a6eb00">TCPTahoe::processRexmitTimer()</a>, <a class="el" href="class_t_c_p_reno.html#a8200e1aeef42d932ef24f447beaf25f5">TCPReno::processRexmitTimer()</a>, <a class="el" href="class_t_c_p_new_reno.html#a0ccc1ba18d31b873fab51b8e429aaae1">TCPNewReno::processRexmitTimer()</a>, <a class="el" href="class_t_c_p_tahoe.html#ab0f1ac1b45b76e45ad5b0ff24faaac80">TCPTahoe::receivedDataAck()</a>, <a class="el" href="class_t_c_p_reno.html#a346296d9fcd3056d1add56d2f03dd391">TCPReno::receivedDataAck()</a>, <a class="el" href="class_t_c_p_new_reno.html#a634da20c5ad064882d2c87f6f5ff1301">TCPNewReno::receivedDataAck()</a>, <a class="el" href="class_t_c_p_tahoe.html#a5c9cd2ff02da7ddc8c1578b0e6a81236">TCPTahoe::receivedDuplicateAck()</a>, <a class="el" href="class_t_c_p_reno.html#adcf0d263e1c1551648ff9b52dff8326f">TCPReno::receivedDuplicateAck()</a>, <a class="el" href="class_t_c_p_new_reno.html#a6ce5b0435826f11b9a459b66d7e8aee8">TCPNewReno::receivedDuplicateAck()</a>, <a class="el" href="class_t_c_p_base_alg.html#a2f8265b680a8cee124f685b19919ab03">TCPBaseAlg()</a>, and <a class="el" href="class_t_c_p_base_alg.html#a5929dfe85238f1ceccd0f5dd578d4b18">~TCPBaseAlg()</a>.</p>

</div>
</div>
<a class="anchor" id="aba8d2462619e5aa1106b992c3361c3fb"></a><!-- doxytag: member="TCPBaseAlg::delayedAckTimer" ref="aba8d2462619e5aa1106b992c3361c3fb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cMessage* <a class="el" href="class_t_c_p_base_alg.html#aba8d2462619e5aa1106b992c3361c3fb">TCPBaseAlg::delayedAckTimer</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#ae40c0a08732c067048a9183945153ec1">ackSent()</a>, <a class="el" href="class_t_c_p_base_alg.html#acf011bd6523207a40e179f1f9f4f448d">connectionClosed()</a>, <a class="el" href="class_t_c_p_base_alg.html#ae6147731689fcc4c5c79f4cc539c6b7f">initialize()</a>, <a class="el" href="class_t_c_p_base_alg.html#a9008afe23db553e45b37d9811f7af110">processTimer()</a>, <a class="el" href="class_t_c_p_base_alg.html#a772c3712679d50b0598957665b14acc9">receiveSeqChanged()</a>, <a class="el" href="class_t_c_p_base_alg.html#a2f8265b680a8cee124f685b19919ab03">TCPBaseAlg()</a>, and <a class="el" href="class_t_c_p_base_alg.html#a5929dfe85238f1ceccd0f5dd578d4b18">~TCPBaseAlg()</a>.</p>

</div>
</div>
<a class="anchor" id="a7eee3af489bedb3010ff637fe848d232"></a><!-- doxytag: member="TCPBaseAlg::keepAliveTimer" ref="a7eee3af489bedb3010ff637fe848d232" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cMessage* <a class="el" href="class_t_c_p_base_alg.html#a7eee3af489bedb3010ff637fe848d232">TCPBaseAlg::keepAliveTimer</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#acf011bd6523207a40e179f1f9f4f448d">connectionClosed()</a>, <a class="el" href="class_t_c_p_base_alg.html#ae6147731689fcc4c5c79f4cc539c6b7f">initialize()</a>, <a class="el" href="class_t_c_p_base_alg.html#a9008afe23db553e45b37d9811f7af110">processTimer()</a>, <a class="el" href="class_t_c_p_base_alg.html#a2f8265b680a8cee124f685b19919ab03">TCPBaseAlg()</a>, and <a class="el" href="class_t_c_p_base_alg.html#a5929dfe85238f1ceccd0f5dd578d4b18">~TCPBaseAlg()</a>.</p>

</div>
</div>
<a class="anchor" id="a0558fe41bf7f4318f5739a472b8e95fd"></a><!-- doxytag: member="TCPBaseAlg::numRtosVector" ref="a0558fe41bf7f4318f5739a472b8e95fd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cOutVector* <a class="el" href="class_t_c_p_base_alg.html#a0558fe41bf7f4318f5739a472b8e95fd">TCPBaseAlg::numRtosVector</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#ae6147731689fcc4c5c79f4cc539c6b7f">initialize()</a>, <a class="el" href="class_t_c_p_base_alg.html#ac8a305a437d4eafd1689204e50af8870">processRexmitTimer()</a>, <a class="el" href="class_t_c_p_base_alg.html#a2f8265b680a8cee124f685b19919ab03">TCPBaseAlg()</a>, and <a class="el" href="class_t_c_p_base_alg.html#a5929dfe85238f1ceccd0f5dd578d4b18">~TCPBaseAlg()</a>.</p>

</div>
</div>
<a class="anchor" id="a16b5813e073593fcf194859387efaef3"></a><!-- doxytag: member="TCPBaseAlg::persistTimer" ref="a16b5813e073593fcf194859387efaef3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cMessage* <a class="el" href="class_t_c_p_base_alg.html#a16b5813e073593fcf194859387efaef3">TCPBaseAlg::persistTimer</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#acf011bd6523207a40e179f1f9f4f448d">connectionClosed()</a>, <a class="el" href="class_t_c_p_base_alg.html#ae6147731689fcc4c5c79f4cc539c6b7f">initialize()</a>, <a class="el" href="class_t_c_p_base_alg.html#a69a0d60fa083b9a3b03e8f80d3c53e6f">processPersistTimer()</a>, <a class="el" href="class_t_c_p_base_alg.html#a9008afe23db553e45b37d9811f7af110">processTimer()</a>, <a class="el" href="class_t_c_p_base_alg.html#a55a32a0e93c6417adb091ee162f225e2">receivedDataAck()</a>, <a class="el" href="class_t_c_p_base_alg.html#a2f8265b680a8cee124f685b19919ab03">TCPBaseAlg()</a>, and <a class="el" href="class_t_c_p_base_alg.html#a5929dfe85238f1ceccd0f5dd578d4b18">~TCPBaseAlg()</a>.</p>

</div>
</div>
<a class="anchor" id="a2413e27953b03ff929b26b62e9dfe8b0"></a><!-- doxytag: member="TCPBaseAlg::rexmitTimer" ref="a2413e27953b03ff929b26b62e9dfe8b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cMessage* <a class="el" href="class_t_c_p_base_alg.html#a2413e27953b03ff929b26b62e9dfe8b0">TCPBaseAlg::rexmitTimer</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#acf011bd6523207a40e179f1f9f4f448d">connectionClosed()</a>, <a class="el" href="class_t_c_p_base_alg.html#a8bbd5e8c6d8b139da0cbc44a3274c9fa">dataSent()</a>, <a class="el" href="class_t_c_p_base_alg.html#ae6147731689fcc4c5c79f4cc539c6b7f">initialize()</a>, <a class="el" href="class_t_c_p_base_alg.html#ac8a305a437d4eafd1689204e50af8870">processRexmitTimer()</a>, <a class="el" href="class_t_c_p_base_alg.html#a9008afe23db553e45b37d9811f7af110">processTimer()</a>, <a class="el" href="class_t_c_p_base_alg.html#a55a32a0e93c6417adb091ee162f225e2">receivedDataAck()</a>, <a class="el" href="class_t_c_p_base_alg.html#aa781a26258eb0504bfff79468079e1b8">restartRexmitTimer()</a>, <a class="el" href="class_t_c_p_base_alg.html#a5fc842a3f9c5297e9ba795843bf0cabb">startRexmitTimer()</a>, <a class="el" href="class_t_c_p_base_alg.html#a2f8265b680a8cee124f685b19919ab03">TCPBaseAlg()</a>, and <a class="el" href="class_t_c_p_base_alg.html#a5929dfe85238f1ceccd0f5dd578d4b18">~TCPBaseAlg()</a>.</p>

</div>
</div>
<a class="anchor" id="a81f6ee9e817cc9225e00ce2945c5e4bf"></a><!-- doxytag: member="TCPBaseAlg::rtoVector" ref="a81f6ee9e817cc9225e00ce2945c5e4bf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cOutVector* <a class="el" href="class_t_c_p_base_alg.html#a81f6ee9e817cc9225e00ce2945c5e4bf">TCPBaseAlg::rtoVector</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#ae6147731689fcc4c5c79f4cc539c6b7f">initialize()</a>, <a class="el" href="class_t_c_p_base_alg.html#a31986bf6db565ab455f818eafb01320e">rttMeasurementComplete()</a>, <a class="el" href="class_t_c_p_base_alg.html#a2f8265b680a8cee124f685b19919ab03">TCPBaseAlg()</a>, and <a class="el" href="class_t_c_p_base_alg.html#a5929dfe85238f1ceccd0f5dd578d4b18">~TCPBaseAlg()</a>.</p>

</div>
</div>
<a class="anchor" id="a27e1885fc2811db6bb92761d99168c26"></a><!-- doxytag: member="TCPBaseAlg::rttvarVector" ref="a27e1885fc2811db6bb92761d99168c26" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cOutVector* <a class="el" href="class_t_c_p_base_alg.html#a27e1885fc2811db6bb92761d99168c26">TCPBaseAlg::rttvarVector</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#ae6147731689fcc4c5c79f4cc539c6b7f">initialize()</a>, <a class="el" href="class_t_c_p_base_alg.html#a31986bf6db565ab455f818eafb01320e">rttMeasurementComplete()</a>, <a class="el" href="class_t_c_p_base_alg.html#a2f8265b680a8cee124f685b19919ab03">TCPBaseAlg()</a>, and <a class="el" href="class_t_c_p_base_alg.html#a5929dfe85238f1ceccd0f5dd578d4b18">~TCPBaseAlg()</a>.</p>

</div>
</div>
<a class="anchor" id="ad4718c9463f32652274f266cf0959575"></a><!-- doxytag: member="TCPBaseAlg::rttVector" ref="ad4718c9463f32652274f266cf0959575" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cOutVector* <a class="el" href="class_t_c_p_base_alg.html#ad4718c9463f32652274f266cf0959575">TCPBaseAlg::rttVector</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#ae6147731689fcc4c5c79f4cc539c6b7f">initialize()</a>, <a class="el" href="class_t_c_p_base_alg.html#a31986bf6db565ab455f818eafb01320e">rttMeasurementComplete()</a>, <a class="el" href="class_t_c_p_base_alg.html#a2f8265b680a8cee124f685b19919ab03">TCPBaseAlg()</a>, and <a class="el" href="class_t_c_p_base_alg.html#a5929dfe85238f1ceccd0f5dd578d4b18">~TCPBaseAlg()</a>.</p>

</div>
</div>
<a class="anchor" id="a08ecae944120c1a57b4d0349fef1f98b"></a><!-- doxytag: member="TCPBaseAlg::srttVector" ref="a08ecae944120c1a57b4d0349fef1f98b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cOutVector* <a class="el" href="class_t_c_p_base_alg.html#a08ecae944120c1a57b4d0349fef1f98b">TCPBaseAlg::srttVector</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#ae6147731689fcc4c5c79f4cc539c6b7f">initialize()</a>, <a class="el" href="class_t_c_p_base_alg.html#a31986bf6db565ab455f818eafb01320e">rttMeasurementComplete()</a>, <a class="el" href="class_t_c_p_base_alg.html#a2f8265b680a8cee124f685b19919ab03">TCPBaseAlg()</a>, and <a class="el" href="class_t_c_p_base_alg.html#a5929dfe85238f1ceccd0f5dd578d4b18">~TCPBaseAlg()</a>.</p>

</div>
</div>
<a class="anchor" id="adcb49cda42179c795cf3c12ed42b3f31"></a><!-- doxytag: member="TCPBaseAlg::ssthreshVector" ref="adcb49cda42179c795cf3c12ed42b3f31" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cOutVector* <a class="el" href="class_t_c_p_base_alg.html#adcb49cda42179c795cf3c12ed42b3f31">TCPBaseAlg::ssthreshVector</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#ae6147731689fcc4c5c79f4cc539c6b7f">initialize()</a>, <a class="el" href="class_t_c_p_tahoe.html#a2bcfd7100334e5ee3df7a4df4eefae28">TCPTahoe::recalculateSlowStartThreshold()</a>, <a class="el" href="class_t_c_p_reno.html#a400250f807397650fa3c83c0c46dfd0f">TCPReno::recalculateSlowStartThreshold()</a>, <a class="el" href="class_t_c_p_new_reno.html#aeb6719d2c5df3c9ed30361f0a7b9e5f7">TCPNewReno::recalculateSlowStartThreshold()</a>, <a class="el" href="class_t_c_p_base_alg.html#a2f8265b680a8cee124f685b19919ab03">TCPBaseAlg()</a>, and <a class="el" href="class_t_c_p_base_alg.html#a5929dfe85238f1ceccd0f5dd578d4b18">~TCPBaseAlg()</a>.</p>

</div>
</div>
<a class="anchor" id="ad1bab317e58578b0976c63d3765867e9"></a><!-- doxytag: member="TCPBaseAlg::state" ref="ad1bab317e58578b0976c63d3765867e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_c_p_base_alg_state_variables.html">TCPBaseAlgStateVariables</a>*&amp; <a class="el" href="class_t_c_p_base_alg.html#ad1bab317e58578b0976c63d3765867e9">TCPBaseAlg::state</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_t_c_p_algorithm.html#add50c340ebfd641323eb3cdee685885c">TCPAlgorithm</a>.</p>

<p>Reimplemented in <a class="el" href="class_t_c_p_new_reno.html#ab57dadc3ba2512c9f42123392fa9346e">TCPNewReno</a>, <a class="el" href="class_t_c_p_no_congestion_control.html#ac627ac65b1fa76b81bd313f66b0ad26e">TCPNoCongestionControl</a>, <a class="el" href="class_t_c_p_reno.html#a60d68f1a2fe9b22f20441ff850c88f54">TCPReno</a>, <a class="el" href="class_t_c_p_tahoe.html#ab9e381bb2b273e372fbf2a701f0f1004">TCPTahoe</a>, and <a class="el" href="class_t_c_p_tahoe_reno_family.html#a55124a30f4315fd87a0fba1ff2d87a1f">TCPTahoeRenoFamily</a>.</p>

<p>Referenced by <a class="el" href="class_t_c_p_base_alg.html#ae40c0a08732c067048a9183945153ec1">ackSent()</a>, <a class="el" href="class_t_c_p_base_alg.html#a8bbd5e8c6d8b139da0cbc44a3274c9fa">dataSent()</a>, <a class="el" href="class_t_c_p_base_alg.html#a2cbb83fb79f28eaea3d33acb13526e11">established()</a>, <a class="el" href="class_t_c_p_base_alg.html#ad5f7c065fdf27a650a7c711cf8e31766">processDelayedAckTimer()</a>, <a class="el" href="class_t_c_p_base_alg.html#a69a0d60fa083b9a3b03e8f80d3c53e6f">processPersistTimer()</a>, <a class="el" href="class_t_c_p_base_alg.html#ac8a305a437d4eafd1689204e50af8870">processRexmitTimer()</a>, <a class="el" href="class_t_c_p_base_alg.html#a55a32a0e93c6417adb091ee162f225e2">receivedDataAck()</a>, <a class="el" href="class_t_c_p_base_alg.html#ad198abc5a259c9b1660ec149aae3b11d">receivedDuplicateAck()</a>, <a class="el" href="class_t_c_p_base_alg.html#aa49a6c59e453685907e24dc671e3561d">receivedOutOfOrderSegment()</a>, <a class="el" href="class_t_c_p_base_alg.html#a772c3712679d50b0598957665b14acc9">receiveSeqChanged()</a>, <a class="el" href="class_t_c_p_base_alg.html#a31986bf6db565ab455f818eafb01320e">rttMeasurementComplete()</a>, <a class="el" href="class_t_c_p_base_alg.html#a7515afa05f1ae81306d10824d4940a54">rttMeasurementCompleteUsingTS()</a>, <a class="el" href="class_t_c_p_base_alg.html#a28c072f575629d0c5ec6478edd3bb7e5">sendData()</a>, and <a class="el" href="class_t_c_p_base_alg.html#a5fc842a3f9c5297e9ba795843bf0cabb">startRexmitTimer()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_t_c_p_base_alg_8h.html">TCPBaseAlg.h</a></li>
<li><a class="el" href="flavours_2_t_c_p_base_alg_8cc.html">flavours/TCPBaseAlg.cc</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="class_t_c_p_base_alg.html">TCPBaseAlg</a>      </li>
      <li class="footer">Generated on Fri Nov 18 2011 12:47:16 for INET Framework for OMNeT++/OMNEST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>

</body>
</html>
