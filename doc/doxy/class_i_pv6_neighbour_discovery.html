<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>INET Framework for OMNeT++/OMNEST: IPv6NeighbourDiscovery Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">INET Framework for OMNeT++/OMNEST
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_i_pv6_neighbour_discovery.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">IPv6NeighbourDiscovery Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="IPv6NeighbourDiscovery" -->
<p>Implements RFC 2461 Neighbor Discovery for <a class="el" href="class_i_pv6.html" title="IPv6 implementation.">IPv6</a>.  
 <a href="class_i_pv6_neighbour_discovery.html#details">More...</a></p>

<p><code>#include &lt;IPv6NeighbourDiscovery.h&gt;</code></p>

<p><a href="class_i_pv6_neighbour_discovery-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_pv6_neighbour_discovery_1_1_adv_if_entry.html">AdvIfEntry</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_pv6_neighbour_discovery_1_1_d_a_d_entry.html">DADEntry</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_pv6_neighbour_discovery_1_1_r_d_entry.html">RDEntry</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; cMessage * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a0e2372b38f3787dd836bcee6b77eb268">MsgPtrVector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_i_pv6_neighbour_cache_1_1_key.html">IPv6NeighbourCache::Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a747705ed3b49881e2d144e2d9f0c8044">Key</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">IPv6NeighbourCache::Neighbour</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="class_i_pv6_neighbour_cache_1_1_default_router_list.html">IPv6NeighbourCache::DefaultRouterList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a78b96883d134769d492bd3c4cd89d982">DefaultRouterList</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a108dde1213dc58b6575583eed36cb92b">IPv6NeighbourDiscovery</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ae7aa7f945013733ec4aebbc290afcb42">~IPv6NeighbourDiscovery</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_a_c_address.html">MACAddress</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a567588762bff7af739e72916df55aebc">resolveNeighbour</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;nextHop, int interfaceId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Public method, to be invoked from the <a class="el" href="class_i_pv6.html" title="IPv6 implementation.">IPv6</a> module to determine link-layer address and the output interface of the next hop.  <a href="#a567588762bff7af739e72916df55aebc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#abcd9999f935e23b593499f8d23a970bf">reachabilityConfirmed</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;neighbour, int interfaceId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Public method, it can be invoked from the <a class="el" href="class_i_pv6.html" title="IPv6 implementation.">IPv6</a> module or any other module to let Neighbour Discovery know that the reachability of the given neighbor has just been confirmed (e.g.  <a href="#abcd9999f935e23b593499f8d23a970bf"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; cMessage * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#af7b0af85c2810acc01d715305818f59b">RATimerList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="struct_i_pv6_neighbour_discovery_1_1_d_a_d_entry.html">DADEntry</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a516186e680ba4eaf87de697019421987">DADList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="struct_i_pv6_neighbour_discovery_1_1_r_d_entry.html">RDEntry</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a99d6acdeeccceb22d5b199a46c1a0e78">RDList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="struct_i_pv6_neighbour_discovery_1_1_adv_if_entry.html">AdvIfEntry</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a74d1e81840eb6742f1f595691e43ac29">AdvIfList</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a878f457b650d3fbdf047dd220f8f2d88">numInitStages</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a6855729184a9f8c2e0072f6773f5e96c">initialize</a> (int stage)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ad90a981569779940aaffe6df55b6285b">handleMessage</a> (cMessage *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a7662f293fab21a873bb22edab70de5ce">processNDMessage</a> (<a class="el" href="class_i_c_m_pv6_message.html">ICMPv6Message</a> *msg, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *ctrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a9c9fcb239e93ed948efb3a946379a3d2">finish</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ade69131623bc5b13205ced3ff54a16d3">processIPv6Datagram</a> (<a class="el" href="class_i_pv6_datagram.html">IPv6Datagram</a> *datagram)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="struct_i_pv6_neighbour_discovery_1_1_adv_if_entry.html">IPv6NeighbourDiscovery::AdvIfEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a44d5adf445298a56e275377d70d620ef">fetchAdvIfEntry</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="struct_i_pv6_neighbour_discovery_1_1_r_d_entry.html">IPv6NeighbourDiscovery::RDEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ab83db378f6596fd37ab6657b13707aa4">fetchRDEntry</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_i_pv6_address.html">IPv6Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a4bddad274cd8eb1472d37ddcd559c629">determineNextHop</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;destAddr, int &amp;outIfID)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function accepts the datagram's destination address and attempts to determine the destination's next hop address and interface ID by: (1) looking up the destination cache, (2)looking up the routing table, or (3) selecting a default router.  <a href="#a4bddad274cd8eb1472d37ddcd559c629"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a9f14cc2bfe0cce622308be4388b3b397">initiateNeighbourUnreachabilityDetection</a> (<a class="el" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *neighbour)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a623b4069795d46d2b421d5aee4f1eb59">processNUDTimeout</a> (cMessage *timeoutMsg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_i_pv6_address.html">IPv6Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a9f6c83de24b3e270c3843cc213b5250a">selectDefaultRouter</a> (int &amp;outIfID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a0e59b5c2995f7bdec6b6a67e60a1e675">timeoutPrefixEntry</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;destPrefix, int prefixLength)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">RFC 2461: Section 6.3.5 Whenever the invalidation timer expires for a Prefix List entry, that entry is discarded.  <a href="#a0e59b5c2995f7bdec6b6a67e60a1e675"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a303391440ad2004ff69cfc5e4cf7504a">timeoutDefaultRouter</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;addr, int interfaceID)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">RFC 2461: Section 6.3.5 Whenever the Lifetime of an entry in the Default Router List expires, that entry is discarded.  <a href="#a303391440ad2004ff69cfc5e4cf7504a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a6afff1bf1db0e7b69f3f6782a87b5b82">initiateAddressResolution</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;dgSrcAddr, <a class="el" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *nce)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method attempts to resolve the given neighbour's link-layer address.  <a href="#a6afff1bf1db0e7b69f3f6782a87b5b82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a61e880bea24c63e2661d2722077ac172">processARTimeout</a> (cMessage *arTimeoutMsg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resends a NS packet to the address intended for address resolution.  <a href="#a61e880bea24c63e2661d2722077ac172"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a888724269369dc1aa87aa73586216b8c">dropQueuedPacketsAwaitingAR</a> (<a class="el" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *nce)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops specific queued packets for a specific NCE AR-timeout.  <a href="#a888724269369dc1aa87aa73586216b8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a58642b1dc383266b43abc6d6e4a74e5e">sendPacketToIPv6Module</a> (cMessage *msg, const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;destAddr, const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;srcAddr, int interfaceId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create control info and assigns it to a msg.  <a href="#a58642b1dc383266b43abc6d6e4a74e5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a6cc2bafedafa13f79df2410b6617ff4b">sendQueuedPacketsToIPv6Module</a> (<a class="el" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *nce)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send off any queued packets within the Neighbour Discovery module awaiting address resolution.  <a href="#a6cc2bafedafa13f79df2410b6617ff4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#aab8e413cb12b66797d5e497f9fe6fddd">initiateDAD</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;tentativeAddr, <a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiating DAD means to send off a Neighbour Solicitation with its target address set as this node's tentative link-local address.  <a href="#aab8e413cb12b66797d5e497f9fe6fddd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a13117cd0ac035e0a0fd198d872b209c3">processDADTimeout</a> (cMessage *msg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a scheduled DAD NS packet.  <a href="#a13117cd0ac035e0a0fd198d872b209c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ab645e6aeaba5afb6cfede0a13d0de5a5">makeTentativeAddressPermanent</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;tentativeAddr, <a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Permanently assign the given address for the given interface entry.  <a href="#ab645e6aeaba5afb6cfede0a13d0de5a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a5438ceb3077ec49d9b393136a9a5e768">assignLinkLocalAddress</a> (cMessage *timerMsg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">as it is not possbile to explicitly define RFC 2462.  <a href="#a5438ceb3077ec49d9b393136a9a5e768"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_i_pv6_router_solicitation.html">IPv6RouterSolicitation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a75431d6a5076b17ae0630f2fc4aa441a">createAndSendRSPacket</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a53cb1f954b65272ad826f3daaec29136">initiateRouterDiscovery</a> (cMessage *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a01e12e84e38baf2539a8335f8f01abc6">cancelRouterDiscovery</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">RFC 2461: Section 6.3.7 4th paragraph Once the host sends a Router Solicitation, and receives a valid Router Advertisement with a non-zero Router Lifetime, the host MUST desist from sending additional solicitations on that interface,.  <a href="#a01e12e84e38baf2539a8335f8f01abc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a860a64e4fbb311fef343ec7044c0a10b">processRDTimeout</a> (cMessage *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ac6f2316e1a19d2816bab83e96d11ef57">processRSPacket</a> (<a class="el" href="class_i_pv6_router_solicitation.html">IPv6RouterSolicitation</a> *rs, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *rsCtrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a09f8b6d13b8546d9c3d735589df9e37f">validateRSPacket</a> (<a class="el" href="class_i_pv6_router_solicitation.html">IPv6RouterSolicitation</a> *rs, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *rsCtrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a50d09a125fd3477828643875b72573ec">createAndSendRAPacket</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;destAddr, <a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a4482770f35807ddc238a9259e85752e3">processRAPacket</a> (<a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *ra, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *raCtrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a41da6658d387e46e3e656d4704bf908f">processRAForRouterUpdates</a> (<a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *ra, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *raCtrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a5acf0814f6ca500c38d87763c0a5aef7">processRAPrefixInfo</a> (<a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *ra, <a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ae187033477823763f0fc0063353821f6">processRAPrefixInfoForAddrAutoConf</a> (<a class="el" href="class_i_pv6_n_d_prefix_information.html">IPv6NDPrefixInformation</a> &amp;prefixInfo, <a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a6e0f7e782e7b912a683c653b30e7b957">createRATimer</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a timer for the given interface entry that sends periodic Router Advertisements.  <a href="#a6e0f7e782e7b912a683c653b30e7b957"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#acd79bbeb030e0105e39d63cab1cee297">resetRATimer</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the given interface entry's Router Advertisement timer.  <a href="#acd79bbeb030e0105e39d63cab1cee297"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a7ab6b1fc3d01da2bc31d772a31013e08">sendPeriodicRA</a> (cMessage *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a32ed95da45989efe4509946492299d34">sendSolicitedRA</a> (cMessage *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a902261563ea0bd130700a148a062781c">validateRAPacket</a> (<a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *ra, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *raCtrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#aedad2b550812f9be54ab691296e5876d">createAndSendNSPacket</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;nsTargetAddr, const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;dgDestAddr, const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;dgSrcAddr, <a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a8d7676502f17ed01eb095afadab7bb33">processNSPacket</a> (<a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *ns, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *naCtrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a72d9ee3401361c560c47f5172c05c1a4">validateNSPacket</a> (<a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *ns, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *nsCtrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a1d21eff02fed770d1bf56dbb995c3db9">processNSForTentativeAddress</a> (<a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *ns, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *ctrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#abccb93f2300252252370c5cfab5017c6">processNSForNonTentativeAddress</a> (<a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *ns, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *ctrlInfo, <a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a8106a5866c58a9c6372c741a15ce943b">processNSWithSpecifiedSrcAddr</a> (<a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *ns, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *ctrlInfo, <a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ac2a5f2e2cbd6845ecd10038fce448ead">sendSolicitedNA</a> (<a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *ns, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *nsCtrlInfo, <a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a30bc9cd2bec93e40e238fe91b573ca9f">sendUnsolicitedNA</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a348ba5dd9e93f4640d465a74b8a73d53">processNAPacket</a> (<a class="el" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *na, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *naCtrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a8f18a6e238820911ee6253f12b766fad">validateNAPacket</a> (<a class="el" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *na, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *naCtrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a093219842e9055dc413f8f6d401001ee">processNAForIncompleteNCEState</a> (<a class="el" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *na, <a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">IPv6NeighbourCache::Neighbour</a> *nce)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a58a8a7aaf00643c4eb0044cc1380413b">processNAForOtherNCEStates</a> (<a class="el" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *na, <a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">IPv6NeighbourCache::Neighbour</a> *nce)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_i_pv6_redirect.html">IPv6Redirect</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a96fb67a2da25bbcd4b18a21a1d597fa6">createAndSendRedirectPacket</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ab95f9c30abcda08c3b762d191df4a3ae">processRedirectPacket</a> (<a class="el" href="class_i_pv6_redirect.html">IPv6Redirect</a> *redirect, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *ctrlInfo)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cQueue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a8cebccf199f96d0903c4663b203199ca">pendingQueue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_interface_table.html">IInterfaceTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_routing_table6.html">RoutingTable6</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_c_m_pv6.html">ICMPv6</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a78cfa038ef771566c18a2eec28fd740b">icmpv6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_pv6_neighbour_cache.html">IPv6NeighbourCache</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_pv6_neighbour_discovery.html#af7b0af85c2810acc01d715305818f59b">RATimerList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ad8d41d97624aa9ba4878adea476018d0">raTimerList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_pv6_neighbour_discovery.html#a516186e680ba4eaf87de697019421987">DADList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a750d70366700481befd66c567d420a7e">dadList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_pv6_neighbour_discovery.html#a99d6acdeeccceb22d5b199a46c1a0e78">RDList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a7f075a086f580756337ef6f59223727c">rdList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_pv6_neighbour_discovery.html#a74d1e81840eb6742f1f595691e43ac29">AdvIfList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a868ef2afa69950bd536b1fb5cd10569a">advIfList</a></td></tr>
<tr><td colspan="2"><h2><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static simsignal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a22051cc7aeebf83e295e30dfff069e36">startDADSignal</a> = SIMSIGNAL_NULL</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Implements RFC 2461 Neighbor Discovery for <a class="el" href="class_i_pv6.html" title="IPv6 implementation.">IPv6</a>. </p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a74d1e81840eb6742f1f595691e43ac29"></a><!-- doxytag: member="IPv6NeighbourDiscovery::AdvIfList" ref="a74d1e81840eb6742f1f595691e43ac29" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="struct_i_pv6_neighbour_discovery_1_1_adv_if_entry.html">AdvIfEntry</a>*&gt; <a class="el" href="class_i_pv6_neighbour_discovery.html#a74d1e81840eb6742f1f595691e43ac29">IPv6NeighbourDiscovery::AdvIfList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a516186e680ba4eaf87de697019421987"></a><!-- doxytag: member="IPv6NeighbourDiscovery::DADList" ref="a516186e680ba4eaf87de697019421987" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="struct_i_pv6_neighbour_discovery_1_1_d_a_d_entry.html">DADEntry</a>*&gt; <a class="el" href="class_i_pv6_neighbour_discovery.html#a516186e680ba4eaf87de697019421987">IPv6NeighbourDiscovery::DADList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a78b96883d134769d492bd3c4cd89d982"></a><!-- doxytag: member="IPv6NeighbourDiscovery::DefaultRouterList" ref="a78b96883d134769d492bd3c4cd89d982" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_i_pv6_neighbour_cache_1_1_default_router_list.html">IPv6NeighbourCache::DefaultRouterList</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a78b96883d134769d492bd3c4cd89d982">IPv6NeighbourDiscovery::DefaultRouterList</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a747705ed3b49881e2d144e2d9f0c8044"></a><!-- doxytag: member="IPv6NeighbourDiscovery::Key" ref="a747705ed3b49881e2d144e2d9f0c8044" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_i_pv6_neighbour_cache_1_1_key.html">IPv6NeighbourCache::Key</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a747705ed3b49881e2d144e2d9f0c8044">IPv6NeighbourDiscovery::Key</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0e2372b38f3787dd836bcee6b77eb268"></a><!-- doxytag: member="IPv6NeighbourDiscovery::MsgPtrVector" ref="a0e2372b38f3787dd836bcee6b77eb268" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;cMessage*&gt; <a class="el" href="class_i_pv6_neighbour_discovery.html#a0e2372b38f3787dd836bcee6b77eb268">IPv6NeighbourDiscovery::MsgPtrVector</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a13e99f7e1505dd01abbf03066e61384c"></a><!-- doxytag: member="IPv6NeighbourDiscovery::Neighbour" ref="a13e99f7e1505dd01abbf03066e61384c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">IPv6NeighbourCache::Neighbour</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">IPv6NeighbourDiscovery::Neighbour</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af7b0af85c2810acc01d715305818f59b"></a><!-- doxytag: member="IPv6NeighbourDiscovery::RATimerList" ref="af7b0af85c2810acc01d715305818f59b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;cMessage*&gt; <a class="el" href="class_i_pv6_neighbour_discovery.html#af7b0af85c2810acc01d715305818f59b">IPv6NeighbourDiscovery::RATimerList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a99d6acdeeccceb22d5b199a46c1a0e78"></a><!-- doxytag: member="IPv6NeighbourDiscovery::RDList" ref="a99d6acdeeccceb22d5b199a46c1a0e78" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="struct_i_pv6_neighbour_discovery_1_1_r_d_entry.html">RDEntry</a>*&gt; <a class="el" href="class_i_pv6_neighbour_discovery.html#a99d6acdeeccceb22d5b199a46c1a0e78">IPv6NeighbourDiscovery::RDList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a108dde1213dc58b6575583eed36cb92b"></a><!-- doxytag: member="IPv6NeighbourDiscovery::IPv6NeighbourDiscovery" ref="a108dde1213dc58b6575583eed36cb92b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_neighbour_discovery.html#a108dde1213dc58b6575583eed36cb92b">IPv6NeighbourDiscovery::IPv6NeighbourDiscovery</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">    : <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>(*<span class="keyword">this</span>)
{
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae7aa7f945013733ec4aebbc290afcb42"></a><!-- doxytag: member="IPv6NeighbourDiscovery::~IPv6NeighbourDiscovery" ref="ae7aa7f945013733ec4aebbc290afcb42" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_neighbour_discovery.html#ae7aa7f945013733ec4aebbc290afcb42">IPv6NeighbourDiscovery::~IPv6NeighbourDiscovery</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="comment">// FIXME delete the following data structures, cancelAndDelete timers in them etc.</span>
    <span class="comment">// Deleting the data structures my become unnecessary if the lists store the</span>
    <span class="comment">// structs themselves and not pointers.</span>
    <span class="comment">//   RATimerList raTimerList;</span>
    <span class="comment">//   DADList dadList;</span>
    <span class="comment">//   RDList rdList;</span>
    <span class="comment">//   AdvIfList advIfList;</span>
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5438ceb3077ec49d9b393136a9a5e768"></a><!-- doxytag: member="IPv6NeighbourDiscovery::assignLinkLocalAddress" ref="a5438ceb3077ec49d9b393136a9a5e768" args="(cMessage *timerMsg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a5438ceb3077ec49d9b393136a9a5e768">IPv6NeighbourDiscovery::assignLinkLocalAddress</a> </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>timerMsg</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>as it is not possbile to explicitly define RFC 2462. </p>
<p>ND is the next best place to do this.</p>
<p>RFC 2462-IPv6 Stateless Address Autoconfiguration: Section 1 The autoconfiguration process specified in this document applies only to hosts and not routers. Since host autoconfiguration uses information advertised by routers, routers will need to be configured by some other means. However, it is expected that routers will generate link-local addresses using the mechanism described in this document. In addition, routers are expected to successfully pass the Duplicate Address Detection procedure described in this document on all addresses prior to assigning them to an interface. </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#ad90a981569779940aaffe6df55b6285b">handleMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//Node has booted up. Start assigning a link-local address for each</span>
    <span class="comment">//interface in this node.</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a2b0ce46cd92da6f64fc363410dc71904" title="Returns the number of interfaces.">getNumInterfaces</a>(); i++)
    {
        <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a19ce4ca3b47b52b8e2b67c25806c4b49" title="Returns the InterfaceEntry specified by an index 0..numInterfaces-1.">getInterface</a>(i);

        <span class="comment">//Skip the loopback interface.</span>
        <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a0ee93e88273f61390d1293dae55004d1">isLoopback</a>()) <span class="keywordflow">continue</span>;

        <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> linkLocalAddr = ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a3b9fa2d8e186014cf9c758e45b5a56df" title="Returns the first valid link-local address of the interface, or UNSPECIFIED_ADDRESS if there&#39;s none...">getLinkLocalAddress</a>();
        <span class="keywordflow">if</span> (linkLocalAddr.<a class="code" href="class_i_pv6_address.html#af526cffcc3a4aa5bb96d307de6e8d448" title="Check if the IPv6 Address is undefined.">isUnspecified</a>())
        {
            <span class="comment">//if no link local address exists for this interface, we assign one to it.</span>
                <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;No link local address exists. Forming one&quot;</span> &lt;&lt; endl;
            linkLocalAddr = <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a>().<a class="code" href="class_i_pv6_address.html#aa8a3ef9e930a6703ea9cbde5a3ecaaca" title="Forms a link-local address using the given interface identifier.">formLinkLocalAddress</a>(ie-&gt;<a class="code" href="class_interface_entry.html#a1196c8e3f1a10a26778296af4c14a4bb">getInterfaceToken</a>());
            ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a715b339dc41612149940ed0607af1535" title="Assigns the given address to the interface.">assignAddress</a>(linkLocalAddr, <span class="keyword">true</span>, 0, 0);
        }

        <span class="comment">//Before we can use this address, we MUST initiate DAD first.</span>
        <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a90fa17dc7efaa7170176e853cf32dfed" title="Returns true if the ith address of the interface is tentative.">isTentativeAddress</a>(linkLocalAddr))
        {
            <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a6c0ffe1d061a7e8ddb69c8503b9b8c7f">getDupAddrDetectTransmits</a>() &gt; 0)
                <a class="code" href="class_i_pv6_neighbour_discovery.html#aab8e413cb12b66797d5e497f9fe6fddd" title="Initiating DAD means to send off a Neighbour Solicitation with its target address set as this node&#39;s ...">initiateDAD</a>(linkLocalAddr, ie);
            <span class="keywordflow">else</span>
                <a class="code" href="class_i_pv6_neighbour_discovery.html#ab645e6aeaba5afb6cfede0a13d0de5a5" title="Permanently assign the given address for the given interface entry.">makeTentativeAddressPermanent</a>(linkLocalAddr, ie);
        }
    }
    <span class="keyword">delete</span> timerMsg;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a01e12e84e38baf2539a8335f8f01abc6"></a><!-- doxytag: member="IPv6NeighbourDiscovery::cancelRouterDiscovery" ref="a01e12e84e38baf2539a8335f8f01abc6" args="(InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a01e12e84e38baf2539a8335f8f01abc6">IPv6NeighbourDiscovery::cancelRouterDiscovery</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>RFC 2461: Section 6.3.7 4th paragraph Once the host sends a Router Solicitation, and receives a valid Router Advertisement with a non-zero Router Lifetime, the host MUST desist from sending additional solicitations on that interface,. </p>
<p>Cancel Router Discovery on the Interface where a RA was received with the given Interface Entry. </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a4482770f35807ddc238a9259e85752e3">processRAPacket()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//Next we retrieve the rdEntry with the Interface Entry.</span>
    RDEntry *rdEntry = <a class="code" href="class_i_pv6_neighbour_discovery.html#ab83db378f6596fd37ab6657b13707aa4">fetchRDEntry</a>(ie);
    <span class="keywordflow">if</span> (rdEntry != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;rdEntry is not NULL, RD cancelled!&quot;</span> &lt;&lt; endl;
        cancelAndDelete(rdEntry-&gt;timeoutMsg);
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a7f075a086f580756337ef6f59223727c">rdList</a>.erase(rdEntry);
        <span class="keyword">delete</span> rdEntry;
    }
    <span class="keywordflow">else</span>
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;rdEntry is NULL, not cancelling RD!&quot;</span> &lt;&lt; endl;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aedad2b550812f9be54ab691296e5876d"></a><!-- doxytag: member="IPv6NeighbourDiscovery::createAndSendNSPacket" ref="aedad2b550812f9be54ab691296e5876d" args="(const IPv6Address &amp;nsTargetAddr, const IPv6Address &amp;dgDestAddr, const IPv6Address &amp;dgSrcAddr, InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> * <a class="el" href="class_i_pv6_neighbour_discovery.html#aedad2b550812f9be54ab691296e5876d">IPv6NeighbourDiscovery::createAndSendNSPacket</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>nsTargetAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>dgDestAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>dgSrcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a6afff1bf1db0e7b69f3f6782a87b5b82">initiateAddressResolution()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#aab8e413cb12b66797d5e497f9fe6fddd">initiateDAD()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a61e880bea24c63e2661d2722077ac172">processARTimeout()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a13117cd0ac035e0a0fd198d872b209c3">processDADTimeout()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#a623b4069795d46d2b421d5aee4f1eb59">processNUDTimeout()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>    Enter_Method_Silent();
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

    <a class="code" href="class_m_a_c_address.html" title="Stores an IEEE 802 MAC address (6 octets = 48 bits).">MACAddress</a> myMacAddr = ie-&gt;<a class="code" href="class_interface_entry.html#af8004a12e9aac171699ff1f7f08ee4c4">getMacAddress</a>();

    <span class="comment">//Construct a Neighbour Solicitation message</span>
    <a class="code" href="class_i_pv6_neighbour_solicitation.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6NeighbourSolicitation</a> *ns = <span class="keyword">new</span> <a class="code" href="class_i_pv6_neighbour_solicitation.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6NeighbourSolicitation</a>(<span class="stringliteral">&quot;NSpacket&quot;</span>);
    ns-&gt;<a class="code" href="class_i_c_m_pv6_message.html#a567e6b86fb028d4f6c0cf97118b36a08">setType</a>(<a class="code" href="_i_c_m_pv6_message__m_8h.html#a007402fd73fa0142d3b888578b1280f8affcf80b9ec52fe2943c51544b9a3f5ce">ICMPv6_NEIGHBOUR_SOL</a>);

    <span class="comment">//Neighbour Solicitation Specific Information</span>
    ns-&gt;<a class="code" href="class_i_pv6_neighbour_solicitation.html#a99d768636c7449cba508c0220bc10c42">setTargetAddress</a>(nsTargetAddr);

    <span class="comment">/*If the solicitation is being sent to a solicited-node multicast</span>
<span class="comment">    address, the sender MUST include its link-layer address (if it has</span>
<span class="comment">    one) as a Source Link-Layer Address option.*/</span>
    <span class="keywordflow">if</span> (dgDestAddr.<a class="code" href="class_i_pv6_address.html#a4d9102b52fcf98d1945c75a098bc678a" title="Returns true if the address matches the given prefix.">matches</a>(<a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a>(<span class="stringliteral">&quot;FF02::1:FF00:0&quot;</span>), 104) &amp;&amp; <span class="comment">// FIXME what&#39;s this? make constant...</span>
            !dgSrcAddr.<a class="code" href="class_i_pv6_address.html#af526cffcc3a4aa5bb96d307de6e8d448" title="Check if the IPv6 Address is undefined.">isUnspecified</a>())
        ns-&gt;<a class="code" href="class_i_pv6_neighbour_solicitation.html#a2290208e998517fa73b2885603dfbdc4">setSourceLinkLayerAddress</a>(myMacAddr);

    <a class="code" href="class_i_pv6_neighbour_discovery.html#a58642b1dc383266b43abc6d6e4a74e5e" title="Create control info and assigns it to a msg.">sendPacketToIPv6Module</a>(ns, dgDestAddr, dgSrcAddr, ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>());

    <span class="keywordflow">return</span> ns;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a50d09a125fd3477828643875b72573ec"></a><!-- doxytag: member="IPv6NeighbourDiscovery::createAndSendRAPacket" ref="a50d09a125fd3477828643875b72573ec" args="(const IPv6Address &amp;destAddr, InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> * <a class="el" href="class_i_pv6_neighbour_discovery.html#a50d09a125fd3477828643875b72573ec">IPv6NeighbourDiscovery::createAndSendRAPacket</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>destAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a7ab6b1fc3d01da2bc31d772a31013e08">sendPeriodicRA()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#a32ed95da45989efe4509946492299d34">sendSolicitedRA()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Create and send RA invoked!\n&quot;</span>;
    <span class="comment">//Must use link-local addr. See: RFC2461 Section 6.1.2</span>
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> sourceAddr = ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a3b9fa2d8e186014cf9c758e45b5a56df" title="Returns the first valid link-local address of the interface, or UNSPECIFIED_ADDRESS if there&#39;s none...">getLinkLocalAddress</a>();

    <span class="comment">//This operation includes all options, regardless whether it is solicited or unsolicited.</span>
    <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ad25e520c7730fff1647b57ba206573ed">getAdvSendAdvertisements</a>()) <span class="comment">//if this is an advertising interface</span>
    {
        <span class="comment">//Construct a Router Advertisment message</span>
        <a class="code" href="class_i_pv6_router_advertisement.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6RouterAdvertisement</a> *ra = <span class="keyword">new</span> <a class="code" href="class_i_pv6_router_advertisement.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6RouterAdvertisement</a>(<span class="stringliteral">&quot;RApacket&quot;</span>);
        ra-&gt;<a class="code" href="class_i_c_m_pv6_message.html#a567e6b86fb028d4f6c0cf97118b36a08">setType</a>(<a class="code" href="_i_c_m_pv6_message__m_8h.html#a007402fd73fa0142d3b888578b1280f8a174c9cf27d2d2203dad02feefb9b0281">ICMPv6_ROUTER_AD</a>);

        <span class="comment">//RFC 2461: Section 6.2.3 Router Advertisment Message Content</span>
        <span class="comment">/*A router sends periodic as well as solicited Router Advertisements out</span>
<span class="comment">        its advertising interfaces.  Outgoing Router Advertisements are filled</span>
<span class="comment">        with the following values consistent with the message format given in</span>
<span class="comment">        Section 4.2:*/</span>

        <span class="comment">//- In the Router Lifetime field: the interface&#39;s configured AdvDefaultLifetime.</span>
        ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a76888c44eb949781b5bfc3a324549ea8">setRouterLifetime</a>(SIMTIME_DBL(ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a4d90e6d4d0bd7949c725652e197805ac">getAdvDefaultLifetime</a>()));

        <span class="comment">//- In the M and O flags: the interface&#39;s configured AdvManagedFlag and</span>
        <span class="comment">//AdvOtherConfigFlag, respectively.  See [ADDRCONF].</span>
        ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a54ec9e3a37943a5ebb5b39876467dcdf">setManagedAddrConfFlag</a>(ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a61241f36404813c6eca618ea5d9051d7">getAdvManagedFlag</a>());
        ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a7cc7d72d28972db2efd1089178abc46f">setOtherStatefulConfFlag</a>(ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ab3e34bccfbcf115390febff5b11294b0">getAdvOtherConfigFlag</a>());

<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>        <span class="comment">// Configuring the HomeAgentFlag (H-bit) (RFC 3775): Zarrar 25.02.07</span>
        <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;isHomeAgent())
            ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a8ff26c3f53f57a9e2de0c00021450e96">setHomeAgentFlag</a>(<span class="keyword">true</span>);  <span class="comment">//Set H-bit if the router is a HA</span>
        <span class="keywordflow">else</span>
            ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a8ff26c3f53f57a9e2de0c00021450e96">setHomeAgentFlag</a>(ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;getAdvHomeAgentFlag()); <span class="comment">//else unset it, which is default</span>
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

        <span class="comment">//- In the Cur Hop Limit field: the interface&#39;s configured CurHopLimit.</span>
        ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#aa54008a86574ecf0a6a04c1e13cfb7ec">setCurHopLimit</a>(ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a5a679f2464927ac4b25a8868281be831">getAdvCurHopLimit</a>());

        <span class="comment">//- In the Reachable Time field: the interface&#39;s configured AdvReachableTime.</span>
        ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#ae8cc4a62bb57fd18b57238e35e00ae7a">setReachableTime</a>(ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a1d7449f508107ff3acb5da29e3931990">getAdvReachableTime</a>());

        <span class="comment">//- In the Retrans Timer field: the interface&#39;s configured AdvRetransTimer.</span>
        ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a4f34e6d54c1a07f067a10dc74585d70e">setRetransTimer</a>(ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#aea515eceac5a9ea9780c4e52980df7c1">getAdvRetransTimer</a>());

        <span class="comment">//- In the options:</span>
        <span class="comment">/*o Source Link-Layer Address option: link-layer address of the sending</span>
<span class="comment">            interface.  (Assumption: We always send this)*/</span>
        ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a19e5854a9456c9f011c8dad47f86fc46">setSourceLinkLayerAddress</a>(ie-&gt;<a class="code" href="class_interface_entry.html#af8004a12e9aac171699ff1f7f08ee4c4">getMacAddress</a>());
        ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a7dd004ca2dc7b7ca05b01a89860c7692">setMTU</a>(ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a6129dfc0ec26f401607336886a9875a8">getAdvLinkMTU</a>());

        <span class="comment">//Add all Advertising Prefixes to the RA</span>
        <span class="keywordtype">int</span> numAdvPrefixes = ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a1d84187cfbe9e91f7af79927c813f61c" title="Returns the number of advertised prefixes on the interface.">getNumAdvPrefixes</a>();
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Number of Adv Prefixes: &quot;</span> &lt;&lt; numAdvPrefixes &lt;&lt; endl;
        ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#ac53dcafff08880c29972a9e97cc190a1">setPrefixInformationArraySize</a>(numAdvPrefixes);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numAdvPrefixes; i++)
        {
            <a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html" title="For routers: advertised prefix configuration.">IPv6InterfaceData::AdvPrefix</a> advPrefix = ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a90da8f012bd443c75e6e742bcf6f7d38" title="Returns the ith advertised prefix on the interface.">getAdvPrefix</a>(i);
            <a class="code" href="class_i_pv6_n_d_prefix_information.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6NDPrefixInformation</a> prefixInfo;

<span class="preprocessor">#ifndef WITH_xMIPv6</span>
<span class="preprocessor"></span>            prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a9453ba3d60ab814b138cb926e3acd25e">setPrefix</a>(advPrefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a8dbd979f7860762721b55d4793629258">prefix</a>);
<span class="preprocessor">#else </span><span class="comment">/* WITH_xMIPv6 */</span>
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a>&lt;&lt;<span class="stringliteral">&quot;\n+=+=+=+= Appendign Prefix Info Option to RA +=+=+=+=\n&quot;</span>;
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a>&lt;&lt;<span class="stringliteral">&quot;Prefix Vaue: &quot;</span> &lt;&lt;advPrefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a8dbd979f7860762721b55d4793629258">prefix</a> &lt;&lt;endl;
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a>&lt;&lt;<span class="stringliteral">&quot;Prefix Length: &quot;</span> &lt;&lt;advPrefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a8e68016dcc5cb215199e7f61402f854b">prefixLength</a> &lt;&lt;endl;
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a>&lt;&lt;<span class="stringliteral">&quot;L-Flag: &quot;</span> &lt;&lt;advPrefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a9c2fa49f3db59393e76c08e022c4e12c">advOnLinkFlag</a> &lt;&lt;endl;
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a>&lt;&lt;<span class="stringliteral">&quot;A-Flag: &quot;</span> &lt;&lt;advPrefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#ac593127a85f0ced6a4f8d9c0aee2184d">advAutonomousFlag</a> &lt;&lt;endl;
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a>&lt;&lt;<span class="stringliteral">&quot;R-Flag: &quot;</span> &lt;&lt;advPrefix.advRtrAddr &lt;&lt;endl;
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a>&lt;&lt;<span class="stringliteral">&quot;Global Address from Prefix: &quot;</span> &lt;&lt;advPrefix.rtrAddress &lt;&lt;endl;

            <span class="keywordflow">if</span> ( <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;isHomeAgent() &amp;&amp; advPrefix.advRtrAddr == <span class="keyword">true</span>)
                prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a9453ba3d60ab814b138cb926e3acd25e">setPrefix</a>(advPrefix.rtrAddress); <span class="comment">//add the global-scope address of the HA&#39;s interface in the prefix option list of the RA message.</span>
            <span class="keywordflow">else</span>
                prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a9453ba3d60ab814b138cb926e3acd25e">setPrefix</a>(advPrefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a8dbd979f7860762721b55d4793629258">prefix</a>);  <span class="comment">//adds the prefix only of the router&#39;s interface in the prefix option list of the RA message.</span>
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

            prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a2ec26f5ca81d0edb173057aa2e4c3df6">setPrefixLength</a>(advPrefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a8e68016dcc5cb215199e7f61402f854b">prefixLength</a>);

            <span class="comment">//- In the &quot;on-link&quot; flag: the entry&#39;s AdvOnLinkFlag.</span>
            prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#aa5c36f737ba2097728eef5be64bdc479">setOnlinkFlag</a>(advPrefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a9c2fa49f3db59393e76c08e022c4e12c">advOnLinkFlag</a>);
            <span class="comment">//- In the Valid Lifetime field: the entry&#39;s AdvValidLifetime.</span>
            prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#ac4162a19fd9bee85dac27030b935ffba">setValidLifetime</a>(SIMTIME_DBL(advPrefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a8a0703cb25c21fb9db5e7a4408e40680">advValidLifetime</a>));
            <span class="comment">//- In the &quot;Autonomous address configuration&quot; flag: the entry&#39;s</span>
            <span class="comment">//AdvAutonomousFlag.</span>
            prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a6c2d6ad4ebee1b6009df94f0b40d81aa">setAutoAddressConfFlag</a>(advPrefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#ac593127a85f0ced6a4f8d9c0aee2184d">advAutonomousFlag</a>);

<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>            <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;isHomeAgent())
                prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a5e83d0659ac79fc6d2cc1be84a89b0e2">setRouterAddressFlag</a>(<span class="keyword">true</span>); <span class="comment">// set the R-bit if the node is a HA</span>

            <span class="comment">//- In the Valid Lifetime field: the entry&#39;s AdvValidLifetime.</span>
            prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#ac4162a19fd9bee85dac27030b935ffba">setValidLifetime</a>(SIMTIME_DBL(advPrefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a8a0703cb25c21fb9db5e7a4408e40680">advValidLifetime</a>));
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

            <span class="comment">//- In the Preferred Lifetime field: the entry&#39;s AdvPreferredLifetime.</span>
            prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#aa8c86e8763b189e2c84658c9dd648cc8">setPreferredLifetime</a>(SIMTIME_DBL(advPrefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a0df07072856386db3465443deffacd6f">advPreferredLifetime</a>));
            <span class="comment">//Now we pop the prefix info into the RA.</span>
            ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a0f506c39d4c2118c522aa5397bd34e43">setPrefixInformation</a>(i, prefixInfo);
        }

        <a class="code" href="class_i_pv6_neighbour_discovery.html#a58642b1dc383266b43abc6d6e4a74e5e" title="Create control info and assigns it to a msg.">sendPacketToIPv6Module</a>(ra, destAddr, sourceAddr, ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>());
        <span class="keywordflow">return</span> ra;
    }

    <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>; <span class="comment">//XXX is this OK?</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a96fb67a2da25bbcd4b18a21a1d597fa6"></a><!-- doxytag: member="IPv6NeighbourDiscovery::createAndSendRedirectPacket" ref="a96fb67a2da25bbcd4b18a21a1d597fa6" args="(InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_redirect.html">IPv6Redirect</a> * <a class="el" href="class_i_pv6_neighbour_discovery.html#a96fb67a2da25bbcd4b18a21a1d597fa6">IPv6NeighbourDiscovery::createAndSendRedirectPacket</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="comment">//Construct a Redirect message</span>
    <a class="code" href="class_i_pv6_redirect.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6Redirect</a> *redirect = <span class="keyword">new</span> <a class="code" href="class_i_pv6_redirect.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6Redirect</a>(<span class="stringliteral">&quot;redirectMsg&quot;</span>);
    redirect-&gt;<a class="code" href="class_i_c_m_pv6_message.html#a567e6b86fb028d4f6c0cf97118b36a08">setType</a>(<a class="code" href="_i_c_m_pv6_message__m_8h.html#a007402fd73fa0142d3b888578b1280f8ac60a8328fb5c35a24712bcb9476f0203">ICMPv6_REDIRECT</a>);

    <span class="comment">//Redirect Message Specific Information</span>
    <span class="comment">//redirect-&gt;setTargetAddress();</span>
    <span class="comment">//redirect-&gt;setDestinationAddress();</span>

    <span class="comment">//Possible Option</span>
    <span class="comment">//redirect-&gt;setTargetLinkLayerAddress();</span>

    <span class="keywordflow">return</span> redirect;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a75431d6a5076b17ae0630f2fc4aa441a"></a><!-- doxytag: member="IPv6NeighbourDiscovery::createAndSendRSPacket" ref="a75431d6a5076b17ae0630f2fc4aa441a" args="(InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_router_solicitation.html">IPv6RouterSolicitation</a> * <a class="el" href="class_i_pv6_neighbour_discovery.html#a75431d6a5076b17ae0630f2fc4aa441a">IPv6NeighbourDiscovery::createAndSendRSPacket</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a53cb1f954b65272ad826f3daaec29136">initiateRouterDiscovery()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#a860a64e4fbb311fef343ec7044c0a10b">processRDTimeout()</a>.</p>
<div class="fragment"><pre class="fragment">{
    ASSERT(ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ad25e520c7730fff1647b57ba206573ed">getAdvSendAdvertisements</a>() == <span class="keyword">false</span>);
    <span class="comment">//RFC 2461: Section 6.3.7 Sending Router Solicitations</span>
    <span class="comment">//A host sends Router Solicitations to the All-Routers multicast address. The</span>
    <span class="comment">//IP source address is set to either one of the interface&#39;s unicast addresses</span>
    <span class="comment">//or the unspecified address.</span>
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> myIPv6Address = ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a56f3fe4007e3df66dc88edd008f059b9" title="Chooses a preferred address for the interface and returns it.">getPreferredAddress</a>();

    <span class="keywordflow">if</span> (myIPv6Address.isUnspecified())
        myIPv6Address = ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a3b9fa2d8e186014cf9c758e45b5a56df" title="Returns the first valid link-local address of the interface, or UNSPECIFIED_ADDRESS if there&#39;s none...">getLinkLocalAddress</a>(); <span class="comment">//so we use the link local address instead</span>

    <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a90fa17dc7efaa7170176e853cf32dfed" title="Returns true if the ith address of the interface is tentative.">isTentativeAddress</a>(myIPv6Address))
        myIPv6Address = <a class="code" href="class_i_pv6_address.html#a0c1e137cb3b1470ec6b8d9a95e03dbe5" title="The unspecified address.">IPv6Address::UNSPECIFIED_ADDRESS</a>; <span class="comment">//set my IPv6 address to unspecified.</span>

    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> destAddr = <a class="code" href="class_i_pv6_address.html#a3550339d4b3388eb3891c4744dca2aa1" title="All-routers multicast address, scope 2 (link-local)">IPv6Address::ALL_ROUTERS_2</a>; <span class="comment">//all_routers multicast</span>
    <a class="code" href="class_i_pv6_router_solicitation.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6RouterSolicitation</a> *rs = <span class="keyword">new</span> <a class="code" href="class_i_pv6_router_solicitation.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6RouterSolicitation</a>(<span class="stringliteral">&quot;RSpacket&quot;</span>);
    rs-&gt;<a class="code" href="class_i_c_m_pv6_message.html#a567e6b86fb028d4f6c0cf97118b36a08">setType</a>(<a class="code" href="_i_c_m_pv6_message__m_8h.html#a007402fd73fa0142d3b888578b1280f8af937f0d524ed38f43ca7e122fe415294">ICMPv6_ROUTER_SOL</a>);

    <span class="comment">//The Source Link-Layer Address option SHOULD be set to the host&#39;s link-layer</span>
    <span class="comment">//address, if the IP source address is not the unspecified address.</span>
    <span class="keywordflow">if</span> (!myIPv6Address.isUnspecified())
        rs-&gt;<a class="code" href="class_i_pv6_router_solicitation.html#a00e06ca71bcf0b3aca669671303ce43e">setSourceLinkLayerAddress</a>(ie-&gt;<a class="code" href="class_interface_entry.html#af8004a12e9aac171699ff1f7f08ee4c4">getMacAddress</a>());

    <span class="comment">//Construct a Router Solicitation message</span>
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a58642b1dc383266b43abc6d6e4a74e5e" title="Create control info and assigns it to a msg.">sendPacketToIPv6Module</a>(rs, destAddr, myIPv6Address, ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>());
    <span class="keywordflow">return</span> rs;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6e0f7e782e7b912a683c653b30e7b957"></a><!-- doxytag: member="IPv6NeighbourDiscovery::createRATimer" ref="a6e0f7e782e7b912a683c653b30e7b957" args="(InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a6e0f7e782e7b912a683c653b30e7b957">IPv6NeighbourDiscovery::createRATimer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a timer for the given interface entry that sends periodic Router Advertisements. </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a6855729184a9f8c2e0072f6773f5e96c">initialize()</a>.</p>
<div class="fragment"><pre class="fragment">{
    cMessage *msg = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;sendPeriodicRA&quot;</span>, <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a810fd09c143fca097e7f2569c9f9b89c">MK_SEND_PERIODIC_RTRADV</a>);
    msg-&gt;setContextPointer(ie);
    AdvIfEntry *advIfEntry = <span class="keyword">new</span> AdvIfEntry();
    advIfEntry-&gt;interfaceId = ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>();
    advIfEntry-&gt;numRASent = 0;

<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>    <span class="comment">// 20.9.07 - CB</span>
    <span class="comment">/*if ( rt6-&gt;isRouter() )</span>
<span class="comment">    {</span>
<span class="comment">        ie-&gt;ipv6()-&gt;setMinRtrAdvInterval(IPv6NeighbourDiscovery::getMinRAInterval()); //should be 0.07 for MIPv6 Support</span>
<span class="comment">        ie-&gt;ipv6()-&gt;setMaxRtrAdvInterval(IPv6NeighbourDiscovery::getMaxRAInterval()); //should be 0.03 for MIPv6 Support</span>
<span class="comment">    }*/</span>
    <span class="comment">// update 23.10.07 - CB</span>

    <span class="keywordflow">if</span> ( canServeWirelessNodes(ie) )
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;This Interface is connected to a WLAN AP, hence using MIPv6 Default Values&quot;</span>&lt;&lt;endl;
        simtime_t minRAInterval = par(<span class="stringliteral">&quot;minIntervalBetweenRAs&quot;</span>); <span class="comment">//reading from the omnetpp.ini (ZY 23.07.09)</span>
        simtime_t maxRAInterval = par(<span class="stringliteral">&quot;maxIntervalBetweenRAs&quot;</span>); <span class="comment">//reading from the omnetpp.ini (ZY 23.07.09</span>
        ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ae9ac588d242336be0e425145b6e15b8a">setMinRtrAdvInterval</a>(minRAInterval);
        ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#aab5cb9dbc801e930e6791b0cf9d21f89">setMaxRtrAdvInterval</a>(maxRAInterval);
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;This Interface is not connected to a WLAN AP, hence using default values&quot;</span>&lt;&lt;endl;
        <span class="comment">//interval = uniform( ie-&gt;ipv6()-&gt;minRtrAdvInterval(), ie-&gt;ipv6()-&gt;maxRtrAdvInterval() );</span>
        <span class="comment">//EV&lt;&lt;&quot;\nThe random calculated RA_ND interval is: &quot;&lt;&lt; interval&lt;&lt;&quot; seconds\n&quot;;</span>
    }
    <span class="comment">// end CB</span>
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

    simtime_t interval = uniform(ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a9ef09c4f701d015e4c99229fbcde0694">getMinRtrAdvInterval</a>(), ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a31355ab369205f9fa820c873a8088b81">getMaxRtrAdvInterval</a>());
    advIfEntry-&gt;raTimeoutMsg = msg;

    simtime_t nextScheduledTime = simTime() + interval;
    advIfEntry-&gt;nextScheduledRATime = nextScheduledTime;
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a868ef2afa69950bd536b1fb5cd10569a">advIfList</a>.insert(advIfEntry);
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Interval: &quot;</span> &lt;&lt; interval &lt;&lt; endl;
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Next scheduled time: &quot;</span> &lt;&lt; nextScheduledTime &lt;&lt; endl;
    <span class="comment">//now we schedule the msg for whatever time that was derived</span>
    scheduleAt(nextScheduledTime, msg);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4bddad274cd8eb1472d37ddcd559c629"></a><!-- doxytag: member="IPv6NeighbourDiscovery::determineNextHop" ref="a4bddad274cd8eb1472d37ddcd559c629" args="(const IPv6Address &amp;destAddr, int &amp;outIfID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_address.html">IPv6Address</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a4bddad274cd8eb1472d37ddcd559c629">IPv6NeighbourDiscovery::determineNextHop</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>destAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>outIfID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function accepts the datagram's destination address and attempts to determine the destination's next hop address and interface ID by: (1) looking up the destination cache, (2)looking up the routing table, or (3) selecting a default router. </p>
<p>It then updates the destination cache. If no default router can be selected than we assume the destination address to be onlink and simply return any available interface. </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#ade69131623bc5b13205ced3ff54a16d3">processIPv6Datagram()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> nextHopAddr;
    simtime_t expiryTime;

    <span class="comment">//RFC 2461 Section 5.2</span>
    <span class="comment">//Next-hop determination for a given unicast destination operates as follows.</span>

    <span class="comment">//The sender performs a longest prefix match against the Prefix List to</span>
    <span class="comment">//determine whether the packet&#39;s destination is on- or off-link.</span>
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Find out if supplied dest addr is on-link or off-link.\n&quot;</span>;
    <span class="keyword">const</span> <a class="code" href="class_i_pv6_route.html" title="Represents a route in the route table.">IPv6Route</a> *route = <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#aa3ba1d17dc59f3e5d77ead359dd3a999" title="Performs longest prefix match in the routing table and returns the resulting route, or NULL if there was no match.">doLongestPrefixMatch</a>(destAddr);

    <span class="keywordflow">if</span> (route != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
    {
        expiryTime = route-&gt;<a class="code" href="class_i_pv6_route.html#a71218ba7da774a43d6b0ea1ceb54a302">getExpiryTime</a>();
        outIfID = route-&gt;<a class="code" href="class_i_pv6_route.html#adbdd6910c92deca3571fa8e5cd27baf8">getInterfaceId</a>();

        <span class="comment">//If the destination is on-link, the next-hop address is the same as the</span>
        <span class="comment">//packet&#39;s destination address.</span>
        <span class="keywordflow">if</span> (route-&gt;<a class="code" href="class_i_pv6_route.html#abdc06722ce1f1af7236ee2c37fcfa132">getNextHop</a>().<a class="code" href="class_i_pv6_address.html#af526cffcc3a4aa5bb96d307de6e8d448" title="Check if the IPv6 Address is undefined.">isUnspecified</a>())
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Dest is on-link, next-hop addr is same as dest addr.\n&quot;</span>;
            nextHopAddr = destAddr;
        }
        <span class="keywordflow">else</span>
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;A next-hop address was found with the route, dest is off-link\n&quot;</span>;
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Assume next-hop address as the selected default router.\n&quot;</span>;
            nextHopAddr = route-&gt;<a class="code" href="class_i_pv6_route.html#abdc06722ce1f1af7236ee2c37fcfa132">getNextHop</a>();
        }
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">//Otherwise, the sender selects a router from the Default Router List</span>
        <span class="comment">//(following the rules described in Section 6.3.6).</span>

        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;No routes were found, Dest addr is off-link.\n&quot;</span>;
        nextHopAddr = <a class="code" href="class_i_pv6_neighbour_discovery.html#a9f6c83de24b3e270c3843cc213b5250a">selectDefaultRouter</a>(outIfID);
        expiryTime = 0;

        <span class="keywordflow">if</span> (outIfID == -1)
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;No Default Routers were found.&quot;</span>;
        <span class="keywordflow">else</span>
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Default router found.\n&quot;</span>;
    }

    <span class="comment">/*the results of next-hop determination computations are saved in the Destination</span>
<span class="comment">    Cache (which also contains updates learned from Redirect messages).*/</span>
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#a1e7fbe36b5dcdfa80e6af5b0c0eea235" title="Add or update a destination cache entry.">updateDestCache</a>(destAddr, nextHopAddr, outIfID, expiryTime);
    <span class="keywordflow">return</span> nextHopAddr;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a888724269369dc1aa87aa73586216b8c"></a><!-- doxytag: member="IPv6NeighbourDiscovery::dropQueuedPacketsAwaitingAR" ref="a888724269369dc1aa87aa73586216b8c" args="(Neighbour *nce)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a888724269369dc1aa87aa73586216b8c">IPv6NeighbourDiscovery::dropQueuedPacketsAwaitingAR</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *&#160;</td>
          <td class="paramname"><em>nce</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drops specific queued packets for a specific NCE AR-timeout. </p>
<p>TODO: Not implemented yet! </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a61e880bea24c63e2661d2722077ac172">processARTimeout()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> <a class="code" href="class_i_pv6_neighbour_discovery.html#a747705ed3b49881e2d144e2d9f0c8044">Key</a> *nceKey = nce-&gt;nceKey;
    <span class="comment">//RFC 2461: Section 7.2.2</span>
    <span class="comment">/*If no Neighbor Advertisement is received after MAX_MULTICAST_SOLICIT</span>
<span class="comment">    solicitations, address resolution has failed. The sender MUST return ICMP</span>
<span class="comment">    destination unreachable indications with code 3 (Address Unreachable) for</span>
<span class="comment">    each packet queued awaiting address resolution.*/</span>
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a0e2372b38f3787dd836bcee6b77eb268">MsgPtrVector</a> pendingPackets = nce-&gt;pendingPackets;
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Pending Packets empty:&quot;</span> &lt;&lt; pendingPackets.empty() &lt;&lt; endl;

    <span class="keywordflow">while</span> (!pendingPackets.empty())
    {
        MsgPtrVector::iterator i = pendingPackets.begin();
        cMessage *msg = (*i);
        <a class="code" href="class_i_pv6_datagram.html" title="Represents an IPv6 datagram.">IPv6Datagram</a> *ipv6Msg = (<a class="code" href="class_i_pv6_datagram.html" title="Represents an IPv6 datagram.">IPv6Datagram</a> *)msg;
        <span class="comment">//Assume msg is the packet itself. I need the datagram&#39;s source addr.</span>
        <span class="comment">//The datagram&#39;s src addr will be the destination of the unreachable msg.</span>
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Sending ICMP unreachable destination.&quot;</span> &lt;&lt; endl;
        pendingPackets.erase(i);
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a8cebccf199f96d0903c4663b203199ca">pendingQueue</a>.remove(msg);
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a78cfa038ef771566c18a2eec28fd740b">icmpv6</a>-&gt;<a class="code" href="class_i_c_m_pv6.html#a3968b2c9964bb40a3d14b3fda9fdbba5" title="This method can be called from other modules to send an ICMPv6 error packet.">sendErrorMessage</a>(ipv6Msg, <a class="code" href="_i_c_m_pv6_message__m_8h.html#a007402fd73fa0142d3b888578b1280f8a41a9a5f4838bc4483b77b0fdcd13f72b">ICMPv6_DESTINATION_UNREACHABLE</a>, <a class="code" href="_i_c_m_pv6_message__m_8h.html#a0de5d721e9e426e7acecf6830de1331fa91cfe5d64331066d0fe0df66b9fa9442">ADDRESS_UNREACHABLE</a>);
    }

    <span class="comment">//RFC 2461: Section 7.3.3</span>
    <span class="comment">/*If address resolution fails, the entry SHOULD be deleted, so that subsequent</span>
<span class="comment">    traffic to that neighbor invokes the next-hop determination procedure again.*/</span>
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Removing neighbour cache entry&quot;</span> &lt;&lt; endl;
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#a877bc367ca422baabc22199c5036df83" title="Deletes the given neighbour from the cache.">remove</a>(nceKey-&gt;address, nceKey-&gt;interfaceID);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a44d5adf445298a56e275377d70d620ef"></a><!-- doxytag: member="IPv6NeighbourDiscovery::fetchAdvIfEntry" ref="a44d5adf445298a56e275377d70d620ef" args="(InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_i_pv6_neighbour_discovery_1_1_adv_if_entry.html">IPv6NeighbourDiscovery::AdvIfEntry</a> * <a class="el" href="class_i_pv6_neighbour_discovery.html#a44d5adf445298a56e275377d70d620ef">IPv6NeighbourDiscovery::fetchAdvIfEntry</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#ac6f2316e1a19d2816bab83e96d11ef57">processRSPacket()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#a7ab6b1fc3d01da2bc31d772a31013e08">sendPeriodicRA()</a>.</p>
<div class="fragment"><pre class="fragment">{
   <span class="keywordflow">for</span> (AdvIfList::iterator it = <a class="code" href="class_i_pv6_neighbour_discovery.html#a868ef2afa69950bd536b1fb5cd10569a">advIfList</a>.begin(); it != <a class="code" href="class_i_pv6_neighbour_discovery.html#a868ef2afa69950bd536b1fb5cd10569a">advIfList</a>.end(); it++)
   {
       AdvIfEntry *advIfEntry = (*it);
       <span class="keywordflow">if</span> (advIfEntry-&gt;interfaceId == ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>())
       {
           <span class="keywordflow">return</span> advIfEntry;
       }
   }
   <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab83db378f6596fd37ab6657b13707aa4"></a><!-- doxytag: member="IPv6NeighbourDiscovery::fetchRDEntry" ref="ab83db378f6596fd37ab6657b13707aa4" args="(InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_i_pv6_neighbour_discovery_1_1_r_d_entry.html">IPv6NeighbourDiscovery::RDEntry</a> * <a class="el" href="class_i_pv6_neighbour_discovery.html#ab83db378f6596fd37ab6657b13707aa4">IPv6NeighbourDiscovery::fetchRDEntry</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a01e12e84e38baf2539a8335f8f01abc6">cancelRouterDiscovery()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#a860a64e4fbb311fef343ec7044c0a10b">processRDTimeout()</a>.</p>
<div class="fragment"><pre class="fragment">{
   <span class="keywordflow">for</span> (RDList::iterator it = <a class="code" href="class_i_pv6_neighbour_discovery.html#a7f075a086f580756337ef6f59223727c">rdList</a>.begin(); it != <a class="code" href="class_i_pv6_neighbour_discovery.html#a7f075a086f580756337ef6f59223727c">rdList</a>.end(); it++)
   {
       RDEntry *rdEntry = (*it);
       <span class="keywordflow">if</span> (rdEntry-&gt;interfaceId == ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>())
       {
           <span class="keywordflow">return</span> rdEntry;
       }
   }
   <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9c9fcb239e93ed948efb3a946379a3d2"></a><!-- doxytag: member="IPv6NeighbourDiscovery::finish" ref="a9c9fcb239e93ed948efb3a946379a3d2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a9c9fcb239e93ed948efb3a946379a3d2">IPv6NeighbourDiscovery::finish</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad90a981569779940aaffe6df55b6285b"></a><!-- doxytag: member="IPv6NeighbourDiscovery::handleMessage" ref="ad90a981569779940aaffe6df55b6285b" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#ad90a981569779940aaffe6df55b6285b">IPv6NeighbourDiscovery::handleMessage</a> </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (msg-&gt;isSelfMessage())
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Self message received!\n&quot;</span>;

        <span class="keywordflow">if</span> (msg-&gt;getKind() == <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a810fd09c143fca097e7f2569c9f9b89c">MK_SEND_PERIODIC_RTRADV</a>)
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Sending periodic RA\n&quot;</span>;
            <a class="code" href="class_i_pv6_neighbour_discovery.html#a7ab6b1fc3d01da2bc31d772a31013e08">sendPeriodicRA</a>(msg);
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;getKind() == <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#ab76c2fe672ed307b0a91f9efa35a7548">MK_SEND_SOL_RTRADV</a>)
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Sending solicited RA\n&quot;</span>;
            <a class="code" href="class_i_pv6_neighbour_discovery.html#a32ed95da45989efe4509946492299d34">sendSolicitedRA</a>(msg);
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;getKind() == <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#aed4b9313083f229d6a498c6c337f931e" title="Copyright (C) 2005 Andras Varga Copyright (C) 2005 Wei Yang, Ng.">MK_ASSIGN_LINKLOCAL_ADDRESS</a>)
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Assigning Link Local Address\n&quot;</span>;
            <a class="code" href="class_i_pv6_neighbour_discovery.html#a5438ceb3077ec49d9b393136a9a5e768" title="as it is not possbile to explicitly define RFC 2462.">assignLinkLocalAddress</a>(msg);
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;getKind() == <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a81f972006a357c3ddda2dfcfd7469015">MK_DAD_TIMEOUT</a>)
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;DAD Timeout message received\n&quot;</span>;
            <a class="code" href="class_i_pv6_neighbour_discovery.html#a13117cd0ac035e0a0fd198d872b209c3" title="Sends a scheduled DAD NS packet.">processDADTimeout</a>(msg);
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;getKind() == <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a9f894036bf61bbc51aa7a8560db5a30e">MK_RD_TIMEOUT</a>)
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Router Discovery message received\n&quot;</span>;
            <a class="code" href="class_i_pv6_neighbour_discovery.html#a860a64e4fbb311fef343ec7044c0a10b">processRDTimeout</a>(msg);
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;getKind() == <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#aadba1232289c7af8c42ae503b367f409">MK_INITIATE_RTRDIS</a>)
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;initiate router discovery.\n&quot;</span>;
            <a class="code" href="class_i_pv6_neighbour_discovery.html#a53cb1f954b65272ad826f3daaec29136">initiateRouterDiscovery</a>(msg);
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;getKind() == <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a817ccecd04135b6f9307b110598e476e">MK_NUD_TIMEOUT</a>)
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NUD Timeout message received\n&quot;</span>;
            <a class="code" href="class_i_pv6_neighbour_discovery.html#a623b4069795d46d2b421d5aee4f1eb59">processNUDTimeout</a>(msg);
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;getKind() == <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a3599ccb8ab8108c0d27c47561d6f93e3">MK_AR_TIMEOUT</a>)
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Address Resolution Timeout message received\n&quot;</span>;
            <a class="code" href="class_i_pv6_neighbour_discovery.html#a61e880bea24c63e2661d2722077ac172" title="Resends a NS packet to the address intended for address resolution.">processARTimeout</a>(msg);
        }
        <span class="keywordflow">else</span>
            error(<span class="stringliteral">&quot;Unrecognized Timer&quot;</span>); <span class="comment">//stops sim w/ error msg.</span>
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;ICMPv6Message *&gt;(msg))
    {
        <span class="comment">//This information will serve as input parameters to various processors.</span>
        <a class="code" href="class_i_pv6_control_info.html" title="Control information for sending/receiving packets over IPv6.">IPv6ControlInfo</a> *ctrlInfo = check_and_cast&lt;<a class="code" href="class_i_pv6_control_info.html" title="Control information for sending/receiving packets over IPv6.">IPv6ControlInfo</a>*&gt;(msg-&gt;removeControlInfo());
        <a class="code" href="class_i_c_m_pv6_message.html" title="Class generated from networklayer/icmpv6/ICMPv6Message.msg by opp_msgc.">ICMPv6Message</a> *ndMsg = (<a class="code" href="class_i_c_m_pv6_message.html" title="Class generated from networklayer/icmpv6/ICMPv6Message.msg by opp_msgc.">ICMPv6Message</a> *)msg;
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a7662f293fab21a873bb22edab70de5ce">processNDMessage</a>(ndMsg, ctrlInfo);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;IPv6Datagram *&gt;(msg))<span class="comment">// not ND message</span>
    {
        <a class="code" href="class_i_pv6_datagram.html" title="Represents an IPv6 datagram.">IPv6Datagram</a> *datagram = (<a class="code" href="class_i_pv6_datagram.html" title="Represents an IPv6 datagram.">IPv6Datagram</a> *)msg;
        <a class="code" href="class_i_pv6_neighbour_discovery.html#ade69131623bc5b13205ced3ff54a16d3">processIPv6Datagram</a>(datagram);
    }
    <span class="keywordflow">else</span>
        error(<span class="stringliteral">&quot;Unknown message type received.\n&quot;</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6855729184a9f8c2e0072f6773f5e96c"></a><!-- doxytag: member="IPv6NeighbourDiscovery::initialize" ref="a6855729184a9f8c2e0072f6773f5e96c" args="(int stage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a6855729184a9f8c2e0072f6773f5e96c">IPv6NeighbourDiscovery::initialize</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="comment">// We have to wait until the 3rd stage (stage 2) with scheduling messages,</span>
    <span class="comment">// because interface registration and IPv6 configuration takes places</span>
    <span class="comment">// in the first two stages.</span>
    <span class="keywordflow">if</span> (stage == 3)
    {
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a> = <a class="code" href="class_interface_table_access.html" title="Gives access to IInterfaceTable.">InterfaceTableAccess</a>().<a class="code" href="class_module_access.html#a46a82b1fa0e957eb42d29c8637df1f4f">get</a>();
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a> = <a class="code" href="class_routing_table6_access.html" title="Gives access to RoutingTable6.">RoutingTable6Access</a>().<a class="code" href="class_module_access.html#a46a82b1fa0e957eb42d29c8637df1f4f">get</a>();
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a78cfa038ef771566c18a2eec28fd740b">icmpv6</a> = <a class="code" href="class_i_c_m_pv6_access.html" title="Gives access to ICMPv6.">ICMPv6Access</a>().<a class="code" href="class_module_access.html#a46a82b1fa0e957eb42d29c8637df1f4f">get</a>();

<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>        <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;isMobileNode())
            mipv6 = <a class="code" href="classx_m_i_pv6_access.html" title="Copyright (C) 2007 Faqir Zarrar Yousaf Communication Networks Institute, Dortmund University of Techn...">xMIPv6Access</a>().<a class="code" href="class_module_access.html#a46a82b1fa0e957eb42d29c8637df1f4f">get</a>();
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

        <a class="code" href="class_i_pv6_neighbour_discovery.html#a8cebccf199f96d0903c4663b203199ca">pendingQueue</a>.setName(<span class="stringliteral">&quot;pendingQueue&quot;</span>);

<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>        <span class="comment">//MIPv6Enabled = par(&quot;MIPv6Support&quot;);    // (Zarrar 14.07.07)</span>
        <span class="comment">/*if(rt6-&gt;isRouter()) // 12.9.07 - CB</span>
<span class="comment">        {</span>
<span class="comment">            minRAInterval = par(&quot;minIntervalBetweenRAs&quot;); // from the omnetpp.ini file (Zarrar 15.07.07)</span>
<span class="comment">            maxRAInterval = par(&quot;maxIntervalBetweenRAs&quot;); // from the omnetpp.ini file (Zarrar 15.07.07)</span>
<span class="comment">            //WATCH (MIPv6Enabled);    // (Zarrar 14.07.07)</span>
<span class="comment">            WATCH(minRAInterval);    // (Zarrar 15.07.07)</span>
<span class="comment">            WATCH(maxRAInterval);    // (Zarrar 15.07.07)</span>
<span class="comment">        }*/</span>
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a2b0ce46cd92da6f64fc363410dc71904" title="Returns the number of interfaces.">getNumInterfaces</a>(); i++)
        {
            <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a19ce4ca3b47b52b8e2b67c25806c4b49" title="Returns the InterfaceEntry specified by an index 0..numInterfaces-1.">getInterface</a>(i);

            <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ad25e520c7730fff1647b57ba206573ed">getAdvSendAdvertisements</a>() &amp;&amp; !(ie-&gt;<a class="code" href="class_interface_entry.html#a0ee93e88273f61390d1293dae55004d1">isLoopback</a>()))
            {
                <a class="code" href="class_i_pv6_neighbour_discovery.html#a6e0f7e782e7b912a683c653b30e7b957" title="Create a timer for the given interface entry that sends periodic Router Advertisements.">createRATimer</a>(ie);
            }
        }
        <span class="comment">//This simulates random node bootup time. Link local address assignment</span>
        <span class="comment">//takes place during this time.</span>
        cMessage *msg = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;assignLinkLocalAddr&quot;</span>, <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#aed4b9313083f229d6a498c6c337f931e" title="Copyright (C) 2005 Andras Varga Copyright (C) 2005 Wei Yang, Ng.">MK_ASSIGN_LINKLOCAL_ADDRESS</a>);
        <span class="comment">//We want routers to boot up faster!</span>

        <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#a79a742fa2d94543412e183ebe0e83d3a" title="IP forwarding on/off.">isRouter</a>())
            scheduleAt(simTime() + uniform(0, 0.3), msg); <span class="comment">//Random Router bootup time</span>
        <span class="keywordflow">else</span>
            scheduleAt(simTime() + uniform(0.4, 1), msg); <span class="comment">//Random Host bootup time</span>

        <a class="code" href="class_i_pv6_neighbour_discovery.html#a22051cc7aeebf83e295e30dfff069e36">startDADSignal</a> = registerSignal(<span class="stringliteral">&quot;startDAD&quot;</span>);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6afff1bf1db0e7b69f3f6782a87b5b82"></a><!-- doxytag: member="IPv6NeighbourDiscovery::initiateAddressResolution" ref="a6afff1bf1db0e7b69f3f6782a87b5b82" args="(const IPv6Address &amp;dgSrcAddr, Neighbour *nce)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a6afff1bf1db0e7b69f3f6782a87b5b82">IPv6NeighbourDiscovery::initiateAddressResolution</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>dgSrcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *&#160;</td>
          <td class="paramname"><em>nce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method attempts to resolve the given neighbour's link-layer address. </p>
<p>The source address of the packet prompting address resolution is also given in order to decide the source address of the NS to be sent. nceKey stores 2 pieces of information (Neighbour address and Interface ID) which is needed for addr resolution and access to the corresponding nce. </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#ade69131623bc5b13205ced3ff54a16d3">processIPv6Datagram()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> <a class="code" href="class_i_pv6_neighbour_discovery.html#a747705ed3b49881e2d144e2d9f0c8044">Key</a> *nceKey = nce-&gt;nceKey;
    <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7" title="Returns an interface by its Id.">getInterfaceById</a>(nceKey-&gt;interfaceID);
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> neighbourAddr = nceKey-&gt;address;
    <span class="keywordtype">int</span> ifID = nceKey-&gt;interfaceID;

    <span class="comment">//RFC2461: Section 7.2.2</span>
    <span class="comment">//When a node has a unicast packet to send to a neighbor, but does not</span>
    <span class="comment">//know the neighbor&#39;s link-layer address, it performs address</span>
    <span class="comment">//resolution.  For multicast-capable interfaces this entails creating a</span>
    <span class="comment">//Neighbor Cache entry in the INCOMPLETE state(already created if not done yet)</span>
    <span class="comment">//WEI-If entry already exists, we still have to ensure that its state is INCOMPLETE.</span>
    nce-&gt;reachabilityState = <a class="code" href="_b_g_p_update_path_attributes__m_8h.html#a308747ffa51e288473d3ecf62c655799a0a00da50814c46c6e714304c1bdd35e7">IPv6NeighbourCache::INCOMPLETE</a>;

    <span class="comment">//and transmitting a Neighbor Solicitation message targeted at the</span>
    <span class="comment">//neighbor.  The solicitation is sent to the solicited-node multicast</span>
    <span class="comment">//address &quot;corresponding to&quot;(or &quot;derived from&quot;) the target address.</span>
    <span class="comment">//(in this case, the target address is the address we are trying to resolve)</span>
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Preparing to send NS to solicited-node multicast group\n&quot;</span>;
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;on the next hop interface\n&quot;</span>;
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> nsDestAddr = neighbourAddr.<a class="code" href="class_i_pv6_address.html#ab135c68c866eb93e17b4a8b070abf750" title="Returns the solicited-node multicast address for this address.">formSolicitedNodeMulticastAddress</a>(); <span class="comment">//for NS datagram</span>
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> nsTargetAddr = neighbourAddr; <span class="comment">//for the field within the NS</span>
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> nsSrcAddr;

    <span class="comment">/*If the source address of the packet prompting the solicitation is the</span>
<span class="comment">    same as one of the addresses assigned to the outgoing interface,*/</span>
    <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#af4856e5c4da3563e03fbc388db63ba8a" title="Returns true if the given address is one of the addresses assigned, regardless whether it is tentativ...">hasAddress</a>(dgSrcAddr))
        <span class="comment">/*that address SHOULD be placed in the IP Source Address of the outgoing</span>
<span class="comment">        solicitation.*/</span>
        nsSrcAddr = dgSrcAddr;
    <span class="keywordflow">else</span>
        <span class="comment">/*Otherwise, any one of the addresses assigned to the interface</span>
<span class="comment">        should be used.*/</span>
        nsSrcAddr = ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a56f3fe4007e3df66dc88edd008f059b9" title="Chooses a preferred address for the interface and returns it.">getPreferredAddress</a>();
    ASSERT(ifID != -1);
    <span class="comment">//Sending NS on specified interface.</span>
    <a class="code" href="class_i_pv6_neighbour_discovery.html#aedad2b550812f9be54ab691296e5876d">createAndSendNSPacket</a>(nsTargetAddr, nsDestAddr, nsSrcAddr, ie);
    nce-&gt;numOfARNSSent = 1;
    nce-&gt;nsSrcAddr = nsSrcAddr;

    <span class="comment">/*While awaiting a response, the sender SHOULD retransmit Neighbor Solicitation</span>
<span class="comment">    messages approximately every RetransTimer milliseconds, even in the absence</span>
<span class="comment">    of additional traffic to the neighbor. Retransmissions MUST be rate-limited</span>
<span class="comment">    to at most one solicitation per neighbor every RetransTimer milliseconds.*/</span>
    cMessage *msg = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;arTimeout&quot;</span>, <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a3599ccb8ab8108c0d27c47561d6f93e3">MK_AR_TIMEOUT</a>); <span class="comment">//AR msg timer</span>
    nce-&gt;arTimer = msg;
    msg-&gt;setContextPointer(nce);
    scheduleAt(simTime() + ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a701f3bea1180a8b0c64359d76d532839">_getRetransTimer</a>(), msg);
}
</pre></div>
</div>
</div>
<a class="anchor" id="aab8e413cb12b66797d5e497f9fe6fddd"></a><!-- doxytag: member="IPv6NeighbourDiscovery::initiateDAD" ref="aab8e413cb12b66797d5e497f9fe6fddd" args="(const IPv6Address &amp;tentativeAddr, InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#aab8e413cb12b66797d5e497f9fe6fddd">IPv6NeighbourDiscovery::initiateDAD</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>tentativeAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initiating DAD means to send off a Neighbour Solicitation with its target address set as this node's tentative link-local address. </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a5438ceb3077ec49d9b393136a9a5e768">assignLinkLocalAddress()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>    Enter_Method_Silent();
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a>&lt;&lt;<span class="stringliteral">&quot;----------INITIATING DUPLICATE ADDRESS DISCOVERY----------&quot;</span>&lt;&lt;endl;
    ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;setDADInProgress(<span class="keyword">true</span>);
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

    DADEntry *dadEntry = <span class="keyword">new</span> DADEntry();
    dadEntry-&gt;interfaceId = ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>();
    dadEntry-&gt;address = tentativeAddr;
    dadEntry-&gt;numNSSent = 0;
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a750d70366700481befd66c567d420a7e">dadList</a>.insert(dadEntry);
    <span class="comment">/*</span>
<span class="comment">    RFC2462: Section 5.4.2</span>
<span class="comment">    To check an address, a node sends DupAddrDetectTransmits Neighbor</span>
<span class="comment">    Solicitations, each separated by RetransTimer milliseconds. The</span>
<span class="comment">    solicitation&#39;s Target Address is set to the address being checked,</span>
<span class="comment">    the IP source is set to the unspecified address and the IP</span>
<span class="comment">    destination is set to the solicited-node multicast address of the</span>
<span class="comment">    target address.*/</span>
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> destAddr = tentativeAddr.<a class="code" href="class_i_pv6_address.html#ab135c68c866eb93e17b4a8b070abf750" title="Returns the solicited-node multicast address for this address.">formSolicitedNodeMulticastAddress</a>();
    <span class="comment">//Send a NS</span>
    <a class="code" href="class_i_pv6_neighbour_discovery.html#aedad2b550812f9be54ab691296e5876d">createAndSendNSPacket</a>(tentativeAddr, destAddr,
        <a class="code" href="class_i_pv6_address.html#a0c1e137cb3b1470ec6b8d9a95e03dbe5" title="The unspecified address.">IPv6Address::UNSPECIFIED_ADDRESS</a>, ie);
    dadEntry-&gt;numNSSent++;

    cMessage *msg = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;dadTimeout&quot;</span>, <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a81f972006a357c3ddda2dfcfd7469015">MK_DAD_TIMEOUT</a>);
    msg-&gt;setContextPointer(dadEntry);

<span class="preprocessor">#ifndef WITH_xMIPv6</span>
<span class="preprocessor"></span>    scheduleAt(simTime()+ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#af14377eaaa9eb0200152bf75670eff33">getRetransTimer</a>(), msg);
<span class="preprocessor">#else </span><span class="comment">/* WITH_xMIPv6 */</span>
    <span class="comment">// update: added uniform(0, IPv6_MAX_RTR_SOLICITATION_DELAY) to account for joining the solicited-node multicast</span>
    <span class="comment">// group which is delay up to one 1 second (RFC 4862, 5.4.2) - 16.01.08, CB</span>
    scheduleAt(simTime()+ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#af14377eaaa9eb0200152bf75670eff33">getRetransTimer</a>()+uniform(0, <a class="code" href="_i_pv6_interface_data_8h.html#a062efe990ca0b6b9de4742526b251a73">IPv6_MAX_RTR_SOLICITATION_DELAY</a>), msg);
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

    emit(<a class="code" href="class_i_pv6_neighbour_discovery.html#a22051cc7aeebf83e295e30dfff069e36">startDADSignal</a>, 1);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9f14cc2bfe0cce622308be4388b3b397"></a><!-- doxytag: member="IPv6NeighbourDiscovery::initiateNeighbourUnreachabilityDetection" ref="a9f14cc2bfe0cce622308be4388b3b397" args="(Neighbour *neighbour)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a9f14cc2bfe0cce622308be4388b3b397">IPv6NeighbourDiscovery::initiateNeighbourUnreachabilityDetection</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *&#160;</td>
          <td class="paramname"><em>neighbour</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#ade69131623bc5b13205ced3ff54a16d3">processIPv6Datagram()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#a567588762bff7af739e72916df55aebc">resolveNeighbour()</a>.</p>
<div class="fragment"><pre class="fragment">{
    ASSERT(nce-&gt;reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a115199155dd43585124db1d8f471025b">IPv6NeighbourCache::STALE</a>);
    <span class="keyword">const</span> <a class="code" href="class_i_pv6_neighbour_discovery.html#a747705ed3b49881e2d144e2d9f0c8044">Key</a> *nceKey = nce-&gt;nceKey;
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Initiating Neighbour Unreachability Detection&quot;</span>;
    <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7" title="Returns an interface by its Id.">getInterfaceById</a>(nceKey-&gt;interfaceID);
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Setting NCE state to DELAY.\n&quot;</span>;
    <span class="comment">/*The first time a node sends a packet to a neighbor whose entry is</span>
<span class="comment">    STALE, the sender changes the state to DELAY*/</span>
    nce-&gt;reachabilityState = <a class="code" href="_o_l_s_r_8h.html#ad0a00c3386c4a24278b3b710ae798220" title="Gets the delay between a given time and the current time.">IPv6NeighbourCache::DELAY</a>;

    <span class="comment">/*and sets a timer to expire in DELAY_FIRST_PROBE_TIME seconds.*/</span>
    cMessage *msg = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;NUDTimeout&quot;</span>, <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a817ccecd04135b6f9307b110598e476e">MK_NUD_TIMEOUT</a>);
    msg-&gt;setContextPointer(nce);
    nce-&gt;nudTimeoutEvent = msg;
    scheduleAt(simTime()+ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a25d5c7a8c5dc4112f9fc4ae14167042a">_getDelayFirstProbeTime</a>(), msg);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a53cb1f954b65272ad826f3daaec29136"></a><!-- doxytag: member="IPv6NeighbourDiscovery::initiateRouterDiscovery" ref="a53cb1f954b65272ad826f3daaec29136" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a53cb1f954b65272ad826f3daaec29136">IPv6NeighbourDiscovery::initiateRouterDiscovery</a> </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#ad90a981569779940aaffe6df55b6285b">handleMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Initiating Router Discovery&quot;</span> &lt;&lt; endl;
    <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = (<a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *)msg-&gt;getContextPointer();
    <span class="keyword">delete</span> msg;
    <span class="comment">//RFC2461: Section 6.3.7</span>
    <span class="comment">/*When an interface becomes enabled, a host may be unwilling to wait for the</span>
<span class="comment">    next unsolicited Router Advertisement to locate default routers or learn</span>
<span class="comment">    prefixes.  To obtain Router Advertisements quickly, a host SHOULD transmit up</span>
<span class="comment">    to MAX_RTR_SOLICITATIONS Router Solicitation messages each separated by at</span>
<span class="comment">    least RTR_SOLICITATION_INTERVAL seconds.(FIXME:Therefore this should be invoked</span>
<span class="comment">    at the beginning of the simulation-WEI)*/</span>
    RDEntry *rdEntry = <span class="keyword">new</span> RDEntry();
    rdEntry-&gt;interfaceId = ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>();
    rdEntry-&gt;numRSSent = 0;
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a75431d6a5076b17ae0630f2fc4aa441a">createAndSendRSPacket</a>(ie);
    rdEntry-&gt;numRSSent++;

    <span class="comment">//Create and schedule a message for retransmission to this module</span>
    cMessage *rdTimeoutMsg = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;processRDTimeout&quot;</span>, <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a9f894036bf61bbc51aa7a8560db5a30e">MK_RD_TIMEOUT</a>);
    rdTimeoutMsg-&gt;setContextPointer(ie);
    rdEntry-&gt;timeoutMsg = rdTimeoutMsg;
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a7f075a086f580756337ef6f59223727c">rdList</a>.insert(rdEntry);
    <span class="comment">/*Before a host sends an initial solicitation, it SHOULD delay the</span>
<span class="comment">    transmission for a random amount of time between 0 and</span>
<span class="comment">    MAX_RTR_SOLICITATION_DELAY.  This serves to alleviate congestion when</span>
<span class="comment">    many hosts start up on a link at the same time, such as might happen</span>
<span class="comment">    after recovery from a power failure.  If a host has already performed</span>
<span class="comment">    a random delay since the interface became (re)enabled (e.g., as part</span>
<span class="comment">    of Duplicate Address Detection [ADDRCONF]) there is no need to delay</span>
<span class="comment">    again before sending the first Router Solicitation message.*/</span>
    <span class="comment">//simtime_t rndInterval = uniform(0, ie-&gt;ipv6Data()-&gt;_getMaxRtrSolicitationDelay());</span>
    scheduleAt(simTime()+ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ae0ae3a3184f559d08910a20e3ea7c2c6">_getRtrSolicitationInterval</a>(), rdTimeoutMsg);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab645e6aeaba5afb6cfede0a13d0de5a5"></a><!-- doxytag: member="IPv6NeighbourDiscovery::makeTentativeAddressPermanent" ref="ab645e6aeaba5afb6cfede0a13d0de5a5" args="(const IPv6Address &amp;tentativeAddr, InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#ab645e6aeaba5afb6cfede0a13d0de5a5">IPv6NeighbourDiscovery::makeTentativeAddressPermanent</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>tentativeAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Permanently assign the given address for the given interface entry. </p>
<p>To be called after successful DAD. </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a5438ceb3077ec49d9b393136a9a5e768">assignLinkLocalAddress()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#a13117cd0ac035e0a0fd198d872b209c3">processDADTimeout()</a>.</p>
<div class="fragment"><pre class="fragment">{
    ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#aa80a8f0b2706a8622bab6b3ff61959ff" title="Clears the &quot;tentative&quot; flag of an existing interface address.">permanentlyAssign</a>(tentativeAddr);

<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>    ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;setDADInProgress(<span class="keyword">false</span>);

    <span class="comment">// update 28.09.07 - CB</span>
    <span class="comment">// after the link-local address was verified to be unique</span>
    <span class="comment">// we can assign the address and initiate the MIPv6 protocol</span>
    <span class="comment">// in case there are any pending entries in the list</span>
    DADGlobalList::iterator it = dadGlobalList.find(ie);
    <span class="keywordflow">if</span> ( it != dadGlobalList.end() )
    {
        DADGlobalEntry&amp; entry = it-&gt;second;

        ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a715b339dc41612149940ed0607af1535" title="Assigns the given address to the interface.">assignAddress</a>(entry.addr, <span class="keyword">false</span>, simTime()+entry.validLifetime,
                simTime()+entry.preferredLifetime, entry.hFlag);

        <span class="comment">// moved from processRAPrefixInfoForAddrAutoConf()</span>
        <span class="comment">// we can remove the old CoA now</span>
        <span class="keywordflow">if</span> ( !entry.CoA.isUnspecified() )
            ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a437e44ce15e213a4ab3a09d69e0e39e1" title="Removes the address.">removeAddress</a>(entry.CoA);

        <span class="comment">// set addresses on this interface to tentative=false</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ae4fe7ab839b3c7f08226eed79f224103" title="Returns the number of addresses the interface has.">getNumAddresses</a>(); i++)
        {
            <span class="comment">// TODO improve this code so that only addresses are permanently assigned</span>
            <span class="comment">// which are formed based on the new prefix from the RA</span>
            <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> addr = ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a908a45071d8685ebbb01f73bb086525b" title="Returns ith address of the interface.">getAddress</a>(i);
            ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#aa80a8f0b2706a8622bab6b3ff61959ff" title="Clears the &quot;tentative&quot; flag of an existing interface address.">permanentlyAssign</a>(addr);
        }

        <span class="comment">// if we have MIPv6 protocols on this node we will eventually have to</span>
        <span class="comment">// call some appropriate methods</span>
        <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;isMobileNode())
        {
            <span class="keywordflow">if</span> (entry.hFlag == <span class="keyword">false</span>) <span class="comment">// if we are not in the home network, send BUs</span>
                  mipv6-&gt;initiateMIPv6Protocol(ie, tentativeAddr);
              <span class="comment">/*</span>
<span class="comment">            else if ( entry.returnedHome ) // if we are again in the home network</span>
<span class="comment">              {</span>
<span class="comment">                  ASSERT(entry.CoA.isUnspecified() == false);</span>
<span class="comment">                  mipv6-&gt;returningHome(entry.CoA, ie); // initiate the returning home procedure</span>
<span class="comment">              }*/</span>
        }

        dadGlobalList.erase(it-&gt;first);
    }

    <span class="comment">// an optimization to make sure that the access router on the link gets our L2 address</span>
    <span class="comment">//sendUnsolicitedNA(ie);</span>

    <span class="comment">// =================================Start: Zarrar Yousaf 08.07.07 ===============================================</span>
    <span class="comment">/* == Calling the routine to assign global scope adddresses to the the routers only. At present during the simulation initialization, the FlatNetworkConfigurator6 assigns a 64 bit prefix to the routers but for xMIPv6 operation, we need full 128bit global scope address, only for routers. The call to  autoConfRouterGlobalScopeAddress() will autoconfigure the full 128 bit global scope address, which will be used by the MN in its BU message destination address, especially for home registeration.</span>
<span class="comment">    */</span>
    <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#a79a742fa2d94543412e183ebe0e83d3a" title="IP forwarding on/off.">isRouter</a>() &amp;&amp; !(ie-&gt;<a class="code" href="class_interface_entry.html#a0ee93e88273f61390d1293dae55004d1">isLoopback</a>()))
    {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a1d84187cfbe9e91f7af79927c813f61c" title="Returns the number of advertised prefixes on the interface.">getNumAdvPrefixes</a>(); i++)
        {
            <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> globalAddress = ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;autoConfRouterGlobalScopeAddress(i);
            ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a715b339dc41612149940ed0607af1535" title="Assigns the given address to the interface.">assignAddress</a>(globalAddress, <span class="keyword">false</span>, 0, 0);
            <span class="comment">// ie-&gt;ipv6Data()-&gt;deduceAdvPrefix(); //commented out but the above two statements can be replaced with this single statement. But i am using the above two statements for clarity reasons.</span>
        }
    }
    <span class="comment">// ==================================End: Zarrar Yousaf 08.07.07===========================================</span>
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

    <span class="comment">/*RFC 2461: Section 6.3.7 2nd Paragraph</span>
<span class="comment">    Before a host sends an initial solicitation, it SHOULD delay the</span>
<span class="comment">    transmission for a random amount of time between 0 and</span>
<span class="comment">    MAX_RTR_SOLICITATION_DELAY.  This serves to alleviate congestion when</span>
<span class="comment">    many hosts start up on a link at the same time, such as might happen</span>
<span class="comment">    after recovery from a power failure.*/</span>
    <span class="comment">//TODO: Placing these operations here means fast router solicitation is</span>
    <span class="comment">//not adopted. Will relocate.</span>
    <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ad25e520c7730fff1647b57ba206573ed">getAdvSendAdvertisements</a>() == <span class="keyword">false</span>)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;creating router discovery message timer\n&quot;</span>;
        cMessage *rtrDisMsg = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;initiateRTRDIS&quot;</span>, <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#aadba1232289c7af8c42ae503b367f409">MK_INITIATE_RTRDIS</a>);
        rtrDisMsg-&gt;setContextPointer(ie);
        simtime_t interval = uniform(0, ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a988083d3c03f3c9c04ba6b85bbdcca4d">_getMaxRtrSolicitationDelay</a>()); <span class="comment">// random delay</span>
        scheduleAt(simTime()+interval, rtrDisMsg);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a878f457b650d3fbdf047dd220f8f2d88"></a><!-- doxytag: member="IPv6NeighbourDiscovery::numInitStages" ref="a878f457b650d3fbdf047dd220f8f2d88" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="class_i_pv6_neighbour_discovery.html#a878f457b650d3fbdf047dd220f8f2d88">IPv6NeighbourDiscovery::numInitStages</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{<span class="keywordflow">return</span> 4;}
</pre></div>
</div>
</div>
<a class="anchor" id="a61e880bea24c63e2661d2722077ac172"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processARTimeout" ref="a61e880bea24c63e2661d2722077ac172" args="(cMessage *arTimeoutMsg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a61e880bea24c63e2661d2722077ac172">IPv6NeighbourDiscovery::processARTimeout</a> </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>arTimeoutMsg</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resends a NS packet to the address intended for address resolution. </p>
<p>TODO: Not implemented yet! </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#ad90a981569779940aaffe6df55b6285b">handleMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//AR timeouts are cancelled when a valid solicited NA is received.</span>
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *nce = (<a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *)arTimeoutMsg-&gt;getContextPointer();
    <span class="keyword">const</span> <a class="code" href="class_i_pv6_neighbour_discovery.html#a747705ed3b49881e2d144e2d9f0c8044">Key</a> *nceKey = nce-&gt;nceKey;
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> nsTargetAddr = nceKey-&gt;address;
    <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7" title="Returns an interface by its Id.">getInterfaceById</a>(nceKey-&gt;interfaceID);
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Num Of NS Sent:&quot;</span> &lt;&lt; nce-&gt;numOfARNSSent &lt;&lt; endl;
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Max Multicast Solicitation:&quot;</span> &lt;&lt; ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a078e8bee47863a749fb99f07c8f6cb69">_getMaxMulticastSolicit</a>() &lt;&lt; endl;

    <span class="keywordflow">if</span> (nce-&gt;numOfARNSSent &lt; ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a078e8bee47863a749fb99f07c8f6cb69">_getMaxMulticastSolicit</a>())
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Sending another Address Resolution NS message&quot;</span> &lt;&lt; endl;
        <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> nsDestAddr = nsTargetAddr.<a class="code" href="class_i_pv6_address.html#ab135c68c866eb93e17b4a8b070abf750" title="Returns the solicited-node multicast address for this address.">formSolicitedNodeMulticastAddress</a>();
        <a class="code" href="class_i_pv6_neighbour_discovery.html#aedad2b550812f9be54ab691296e5876d">createAndSendNSPacket</a>(nsTargetAddr, nsDestAddr, nce-&gt;nsSrcAddr, ie);
        nce-&gt;numOfARNSSent++;
        scheduleAt(simTime()+ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a701f3bea1180a8b0c64359d76d532839">_getRetransTimer</a>(), arTimeoutMsg);
        <span class="keywordflow">return</span>;
    }

    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Address Resolution has failed.&quot;</span> &lt;&lt; endl;
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a888724269369dc1aa87aa73586216b8c" title="Drops specific queued packets for a specific NCE AR-timeout.">dropQueuedPacketsAwaitingAR</a>(nce);
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Deleting AR timeout msg\n&quot;</span>;
    <span class="keyword">delete</span> arTimeoutMsg;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a13117cd0ac035e0a0fd198d872b209c3"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processDADTimeout" ref="a13117cd0ac035e0a0fd198d872b209c3" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a13117cd0ac035e0a0fd198d872b209c3">IPv6NeighbourDiscovery::processDADTimeout</a> </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a scheduled DAD NS packet. </p>
<p>If number of sends is equals or more than dupAddrDetectTransmits, then permantly assign target link local address as permanent address for given interface entry. </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#ad90a981569779940aaffe6df55b6285b">handleMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    DADEntry *dadEntry = (DADEntry *)msg-&gt;getContextPointer();
    <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = (<a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *)<a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7" title="Returns an interface by its Id.">getInterfaceById</a>(dadEntry-&gt;interfaceId);
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> tentativeAddr = dadEntry-&gt;address;
    <span class="comment">//Here, we need to check how many DAD messages for the interface entry were</span>
    <span class="comment">//sent vs. DupAddrDetectTransmits</span>
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;numOfDADMessagesSent is: &quot;</span> &lt;&lt; dadEntry-&gt;numNSSent &lt;&lt; endl;
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;dupAddrDetectTrans is: &quot;</span> &lt;&lt; ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a6c0ffe1d061a7e8ddb69c8503b9b8c7f">getDupAddrDetectTransmits</a>() &lt;&lt; endl;

    <span class="keywordflow">if</span> (dadEntry-&gt;numNSSent &lt; ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a6c0ffe1d061a7e8ddb69c8503b9b8c7f">getDupAddrDetectTransmits</a>())
    {
        bubble(<span class="stringliteral">&quot;Sending another DAD NS message.&quot;</span>);
        <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> destAddr = tentativeAddr.<a class="code" href="class_i_pv6_address.html#ab135c68c866eb93e17b4a8b070abf750" title="Returns the solicited-node multicast address for this address.">formSolicitedNodeMulticastAddress</a>();
        <a class="code" href="class_i_pv6_neighbour_discovery.html#aedad2b550812f9be54ab691296e5876d">createAndSendNSPacket</a>(dadEntry-&gt;address, destAddr, <a class="code" href="class_i_pv6_address.html#a0c1e137cb3b1470ec6b8d9a95e03dbe5" title="The unspecified address.">IPv6Address::UNSPECIFIED_ADDRESS</a>, ie);
        dadEntry-&gt;numNSSent++;
        <span class="comment">//Reuse the received msg</span>
        scheduleAt(simTime()+ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#af14377eaaa9eb0200152bf75670eff33">getRetransTimer</a>(), msg);
    }
    <span class="keywordflow">else</span>
    {
        bubble(<span class="stringliteral">&quot;Max number of DAD messages for interface sent. Address is unique.&quot;</span>);
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a750d70366700481befd66c567d420a7e">dadList</a>.erase(dadEntry);
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;delete dadEntry and msg\n&quot;</span>;
        <span class="keyword">delete</span> dadEntry;
        <span class="keyword">delete</span> msg;

        <a class="code" href="class_i_pv6_neighbour_discovery.html#ab645e6aeaba5afb6cfede0a13d0de5a5" title="Permanently assign the given address for the given interface entry.">makeTentativeAddressPermanent</a>(tentativeAddr, ie);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ade69131623bc5b13205ced3ff54a16d3"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processIPv6Datagram" ref="ade69131623bc5b13205ced3ff54a16d3" args="(IPv6Datagram *datagram)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#ade69131623bc5b13205ced3ff54a16d3">IPv6NeighbourDiscovery::processIPv6Datagram</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_datagram.html">IPv6Datagram</a> *&#160;</td>
          <td class="paramname"><em>datagram</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#ad90a981569779940aaffe6df55b6285b">handleMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Packet &quot;</span> &lt;&lt; msg &lt;&lt; <span class="stringliteral">&quot; arrived from IPv6 module.\n&quot;</span>;

    <span class="keywordtype">int</span> nextHopIfID;
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Determining Next Hop&quot;</span> &lt;&lt; endl;
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> nextHopAddr = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4bddad274cd8eb1472d37ddcd559c629" title="This function accepts the datagram&#39;s destination address and attempts to determine the destination&#39;s ...">determineNextHop</a>(msg-&gt;getDestAddress(), nextHopIfID);

    <span class="keywordflow">if</span> (nextHopIfID == -1)
    {
        <span class="comment">//draft-ietf-ipv6-2461bis-04 has omitted on-link assumption.</span>
        <span class="comment">//draft-ietf-v6ops-onlinkassumption-03 explains why.</span>
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a78cfa038ef771566c18a2eec28fd740b">icmpv6</a>-&gt;<a class="code" href="class_i_c_m_pv6.html#a3968b2c9964bb40a3d14b3fda9fdbba5" title="This method can be called from other modules to send an ICMPv6 error packet.">sendErrorMessage</a>(msg, <a class="code" href="_i_c_m_pv6_message__m_8h.html#a007402fd73fa0142d3b888578b1280f8a41a9a5f4838bc4483b77b0fdcd13f72b">ICMPv6_DESTINATION_UNREACHABLE</a>, <a class="code" href="_i_c_m_pv6_message__m_8h.html#a0de5d721e9e426e7acecf6830de1331fab458cf17d1a4b7018719211a9ed053fd">NO_ROUTE_TO_DEST</a>);
        <span class="keywordflow">return</span>;
    }

    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Next Hop Address is: &quot;</span> &lt;&lt; nextHopAddr &lt;&lt; <span class="stringliteral">&quot; on interface: &quot;</span> &lt;&lt; nextHopIfID &lt;&lt; endl;

    <span class="comment">//RFC2461: Section 5.2 Conceptual Sending Algorithm</span>
    <span class="comment">//Once the IP address of the next-hop node is known, the sender examines the</span>
    <span class="comment">//Neighbor Cache for link-layer information about that neighbor.</span>
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *nce = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#af88ebc30d5f18f0a628ead79f1fc3cb9" title="Returns a neighbour entry, or NULL.">lookup</a>(nextHopAddr, nextHopIfID);

    <span class="keywordflow">if</span> (nce == <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;No Entry exists in the Neighbour Cache.\n&quot;</span>;
        <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7" title="Returns an interface by its Id.">getInterfaceById</a>(nextHopIfID);
        <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a91ff5ecd3f8a0e38a09f40694b760a65">isPointToPoint</a>())
        {
            <span class="comment">//the sender creates one, sets its state to STALE,</span>
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Creating an STALE entry in the neighbour cache.\n&quot;</span>;
            nce = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#ab0751209af2b66c4171f92ba6ed7eee1" title="Creates and initializes a neighbour entry with isRouter=false, state=INCOMPLETE.">addNeighbour</a>(nextHopAddr, nextHopIfID, <a class="code" href="class_m_a_c_address.html#a9083fdb636ab09f77e7af806f2d471b6" title="The unspecified MAC address, 00:00:00:00:00:00.">MACAddress::UNSPECIFIED_ADDRESS</a>);
        }
        <span class="keywordflow">else</span>
        {
            <span class="comment">//the sender creates one, sets its state to INCOMPLETE,</span>
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Creating an INCOMPLETE entry in the neighbour cache.\n&quot;</span>;
            nce = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#ab0751209af2b66c4171f92ba6ed7eee1" title="Creates and initializes a neighbour entry with isRouter=false, state=INCOMPLETE.">addNeighbour</a>(nextHopAddr, nextHopIfID);

            <span class="comment">//initiates Address Resolution,</span>
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Initiating Address Resolution for:&quot;</span> &lt;&lt; nextHopAddr
               &lt;&lt; <span class="stringliteral">&quot; on Interface:&quot;</span> &lt;&lt; nextHopIfID &lt;&lt; endl;
            <a class="code" href="class_i_pv6_neighbour_discovery.html#a6afff1bf1db0e7b69f3f6782a87b5b82" title="This method attempts to resolve the given neighbour&#39;s link-layer address.">initiateAddressResolution</a>(msg-&gt;getSrcAddress(), nce);
        }
    }

    <span class="keywordflow">if</span> (nce-&gt;reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1ac2cfd6c9d21c7d34d2f6f53d6cfe6638">IPv6NeighbourCache::INCOMPLETE</a>)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Reachability State is INCOMPLETE. Address Resolution already initiated.\n&quot;</span>;
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Add packet to entry&#39;s queue until Address Resolution is complete.\n&quot;</span>;
        bubble(<span class="stringliteral">&quot;Packet added to queue until Address Resolution is complete.&quot;</span>);
        nce-&gt;pendingPackets.push_back(msg);
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a8cebccf199f96d0903c4663b203199ca">pendingQueue</a>.insert(msg);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nce-&gt;reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a115199155dd43585124db1d8f471025b">IPv6NeighbourCache::STALE</a>)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Reachability State is STALE.\n&quot;</span>;
        send(msg, <span class="stringliteral">&quot;ipv6Out&quot;</span>);
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a9f14cc2bfe0cce622308be4388b3b397">initiateNeighbourUnreachabilityDetection</a>(nce);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nce-&gt;reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a537cfe5cd6d576deab91b256b6da873a">IPv6NeighbourCache::REACHABLE</a>)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Next hop is REACHABLE, sending packet to next-hop address.&quot;</span>;
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a58642b1dc383266b43abc6d6e4a74e5e" title="Create control info and assigns it to a msg.">sendPacketToIPv6Module</a>(msg, nextHopAddr, msg-&gt;getSrcAddress(), nextHopIfID);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nce-&gt;reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a815cc3dd5d8b220495a69641b00f5bdb">IPv6NeighbourCache::DELAY</a>)<span class="comment">//TODO: What if NCE is in PROBE state?</span>
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Next hop is in DELAY state, sending packet to next-hop address.&quot;</span>;
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a58642b1dc383266b43abc6d6e4a74e5e" title="Create control info and assigns it to a msg.">sendPacketToIPv6Module</a>(msg, nextHopAddr, msg-&gt;getSrcAddress(), nextHopIfID);
    }
    <span class="keywordflow">else</span>
        error(<span class="stringliteral">&quot;Unknown Neighbour cache entry state.&quot;</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a093219842e9055dc413f8f6d401001ee"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processNAForIncompleteNCEState" ref="a093219842e9055dc413f8f6d401001ee" args="(IPv6NeighbourAdvertisement *na, IPv6NeighbourCache::Neighbour *nce)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a093219842e9055dc413f8f6d401001ee">IPv6NeighbourDiscovery::processNAForIncompleteNCEState</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *&#160;</td>
          <td class="paramname"><em>na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">IPv6NeighbourCache::Neighbour</a> *&#160;</td>
          <td class="paramname"><em>nce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a348ba5dd9e93f4640d465a74b8a73d53">processNAPacket()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_m_a_c_address.html" title="Stores an IEEE 802 MAC address (6 octets = 48 bits).">MACAddress</a> naMacAddr = na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a30d4ff1f627fd97932c2ee4d9c435f8b">getTargetLinkLayerAddress</a>();
    <span class="keywordtype">bool</span> naRouterFlag = na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a88ac570e8f5e77f9a37f7f1ac545a0dc">getRouterFlag</a>();
    <span class="keywordtype">bool</span> naSolicitedFlag = na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a930381145de395cf787734ae40ea7361">getSolicitedFlag</a>();
    <span class="keyword">const</span> <a class="code" href="class_i_pv6_neighbour_discovery.html#a747705ed3b49881e2d144e2d9f0c8044">Key</a> *nceKey = nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#ad5af58880fcaf23480829713c6842037">nceKey</a>;
    <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7" title="Returns an interface by its Id.">getInterfaceById</a>(nceKey-&gt;interfaceID);

    <span class="comment">/*If the target&#39;s neighbour Cache entry is in the INCOMPLETE state when the</span>
<span class="comment">    advertisement is received, one of two things happens.*/</span>
    <span class="keywordflow">if</span> (naMacAddr.<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107" title="Returns true if all address bytes are zero.">isUnspecified</a>())
    {
        <span class="comment">/*If the link layer has addresses and no Target Link-Layer address option</span>
<span class="comment">        is included, the receiving node SHOULD silently discard the received</span>
<span class="comment">        advertisement.*/</span>
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;No MAC Address specified in NA. Ignoring NA\n&quot;</span>;
        <span class="keywordflow">return</span>;
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">//Otherwise, the receiving node performs the following steps:</span>
        <span class="comment">//- It records the link-layer address in the neighbour Cache entry.</span>
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;ND is updating Neighbour Cache Entry.\n&quot;</span>;
        nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a3b51b5802cd50245bc2cdbbca1069dd0">macAddress</a> = naMacAddr;

        <span class="comment">//- If the advertisement&#39;s Solicited flag is set, the state of the</span>
        <span class="comment">//  entry is set to REACHABLE, otherwise it is set to STALE.</span>
        <span class="keywordflow">if</span> (naSolicitedFlag == <span class="keyword">true</span>)
        {
            nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a0895435c223a2d4f67f02c3c614afbb5">reachabilityState</a> = <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a537cfe5cd6d576deab91b256b6da873a">IPv6NeighbourCache::REACHABLE</a>;
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Reachability confirmed through successful Addr Resolution.\n&quot;</span>;
            nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#ad89a5f7ec5a7834e440c4437d108687a">reachabilityExpires</a> = simTime() + ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ade85749f4c00abf6dcafe675997bc946">_getReachableTime</a>();
        }
        <span class="keywordflow">else</span>
            nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a0895435c223a2d4f67f02c3c614afbb5">reachabilityState</a> = <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a115199155dd43585124db1d8f471025b">IPv6NeighbourCache::STALE</a>;

        <span class="comment">//- It sets the IsRouter flag in the cache entry based on the Router</span>
        <span class="comment">//  flag in the received advertisement.</span>
        nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#af5203d6dd6d97a8b2baf782f44f8206f">isRouter</a> = naRouterFlag;
        <span class="keywordflow">if</span> (nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a85fae78cf00dd05a864ec8112639b6d5">isDefaultRouter</a>() &amp;&amp; !nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#af5203d6dd6d97a8b2baf782f44f8206f">isRouter</a>)
            <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#a949aafe89b2ced9a3cba25ec476473a3">getDefaultRouterList</a>().<a class="code" href="class_i_pv6_neighbour_cache_1_1_default_router_list.html#adce978a2f79872422a2116018a254e44">remove</a>(*nce);

        <span class="comment">//- It sends any packets queued for the neighbour awaiting address</span>
        <span class="comment">//  resolution.</span>
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a6cc2bafedafa13f79df2410b6617ff4b" title="Send off any queued packets within the Neighbour Discovery module awaiting address resolution...">sendQueuedPacketsToIPv6Module</a>(nce);
        cancelAndDelete(nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a85eabb9c45740ac29550eb11cb03cdb6">arTimer</a>);
        nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a85eabb9c45740ac29550eb11cb03cdb6">arTimer</a> = <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a58a8a7aaf00643c4eb0044cc1380413b"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processNAForOtherNCEStates" ref="a58a8a7aaf00643c4eb0044cc1380413b" args="(IPv6NeighbourAdvertisement *na, IPv6NeighbourCache::Neighbour *nce)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a58a8a7aaf00643c4eb0044cc1380413b">IPv6NeighbourDiscovery::processNAForOtherNCEStates</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *&#160;</td>
          <td class="paramname"><em>na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">IPv6NeighbourCache::Neighbour</a> *&#160;</td>
          <td class="paramname"><em>nce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a348ba5dd9e93f4640d465a74b8a73d53">processNAPacket()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> naRouterFlag = na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a88ac570e8f5e77f9a37f7f1ac545a0dc">getRouterFlag</a>();
    <span class="keywordtype">bool</span> naSolicitedFlag = na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a930381145de395cf787734ae40ea7361">getSolicitedFlag</a>();
    <span class="keywordtype">bool</span> naOverrideFlag = na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a6cb96afeb88e2c5dcfed94d1992916df">getOverrideFlag</a>();
    <a class="code" href="class_m_a_c_address.html" title="Stores an IEEE 802 MAC address (6 octets = 48 bits).">MACAddress</a> naMacAddr = na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a30d4ff1f627fd97932c2ee4d9c435f8b">getTargetLinkLayerAddress</a>();
    <span class="keyword">const</span> <a class="code" href="class_i_pv6_neighbour_discovery.html#a747705ed3b49881e2d144e2d9f0c8044">Key</a> *nceKey = nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#ad5af58880fcaf23480829713c6842037">nceKey</a>;
    <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7" title="Returns an interface by its Id.">getInterfaceById</a>(nceKey-&gt;interfaceID);

    <span class="comment">/*draft-ietf-ipv6-2461bis-04</span>
<span class="comment">    Section 7.2.5: Receipt of Neighbour Advertisements</span>
<span class="comment">    If the target&#39;s Neighbor Cache entry is in any state other than INCOMPLETE</span>
<span class="comment">    when the advertisement is received, the following actions take place:*/</span>

    <span class="keywordflow">if</span> (naOverrideFlag == <span class="keyword">false</span> &amp;&amp; !(naMacAddr.<a class="code" href="class_m_a_c_address.html#a2d1669ce517436105cd75faed677a303" title="Returns true if the two addresses are equal.">equals</a>(nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a3b51b5802cd50245bc2cdbbca1069dd0">macAddress</a>))
            &amp;&amp; !(naMacAddr.<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107" title="Returns true if all address bytes are zero.">isUnspecified</a>()))
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NA override is FALSE and NA MAC addr is different.\n&quot;</span>;

        <span class="comment">//I. If the Override flag is clear and the supplied link-layer address</span>
        <span class="comment">//   differs from that in the cache, then one of two actions takes place:</span>
        <span class="comment">//(Note: An unspecified MAC should not be compared with the NCE&#39;s mac!)</span>
        <span class="comment">//a. If the state of the entry is REACHABLE,</span>
        <span class="keywordflow">if</span> (nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a0895435c223a2d4f67f02c3c614afbb5">reachabilityState</a> == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a537cfe5cd6d576deab91b256b6da873a">IPv6NeighbourCache::REACHABLE</a>)
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NA mac is different. Change NCE state from REACHABLE to STALE\n&quot;</span>;
            <span class="comment">//set it to STALE, but do not update the entry in any other way.</span>
            nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a0895435c223a2d4f67f02c3c614afbb5">reachabilityState</a> = <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a115199155dd43585124db1d8f471025b">IPv6NeighbourCache::STALE</a>;
        }
        <span class="keywordflow">else</span>
            <span class="comment">//b. Otherwise, the received advertisement should be ignored and</span>
            <span class="comment">//MUST NOT update the cache.</span>
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NCE is not in REACHABLE state. Ignore NA.\n&quot;</span>;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (naOverrideFlag == <span class="keyword">true</span> || naMacAddr.<a class="code" href="class_m_a_c_address.html#a2d1669ce517436105cd75faed677a303" title="Returns true if the two addresses are equal.">equals</a>(nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a3b51b5802cd50245bc2cdbbca1069dd0">macAddress</a>)
            || naMacAddr.<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107" title="Returns true if all address bytes are zero.">isUnspecified</a>())
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NA override flag is TRUE. or Advertised MAC is same as NCE&#39;s. or&quot;</span>
           &lt;&lt; <span class="stringliteral">&quot; NA MAC is not specified.\n&quot;</span>;
        <span class="comment">/*II. If the Override flag is set, or the supplied link-layer address</span>
<span class="comment">        is the same as that in the cache, or no Target Link-layer address</span>
<span class="comment">        option was supplied, the received advertisement MUST update the</span>
<span class="comment">        Neighbor Cache entry as follows:*/</span>

        <span class="comment">/*- The link-layer address in the Target Link-Layer Address option</span>
<span class="comment">            MUST be inserted in the cache (if one is supplied and is</span>
<span class="comment">            Different than the already recorded address).*/</span>
        <span class="keywordflow">if</span> (!(naMacAddr.<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107" title="Returns true if all address bytes are zero.">isUnspecified</a>()) &amp;&amp; !(naMacAddr.<a class="code" href="class_m_a_c_address.html#a2d1669ce517436105cd75faed677a303" title="Returns true if the two addresses are equal.">equals</a>(nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a3b51b5802cd50245bc2cdbbca1069dd0">macAddress</a>)))
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Updating NCE&#39;s MAC addr with NA&#39;s.\n&quot;</span>;
            nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a3b51b5802cd50245bc2cdbbca1069dd0">macAddress</a> = naMacAddr;
        }

        <span class="comment">//- If the Solicited flag is set,</span>
        <span class="keywordflow">if</span> (naSolicitedFlag == <span class="keyword">true</span>)
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Solicited Flag is TRUE. Set NCE state to REACHABLE.\n&quot;</span>;
            <span class="comment">//the state of the entry MUST be set to REACHABLE.</span>
            nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a0895435c223a2d4f67f02c3c614afbb5">reachabilityState</a> = <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a537cfe5cd6d576deab91b256b6da873a">IPv6NeighbourCache::REACHABLE</a>;
            <span class="comment">//We have to cancel the NUD self timer message if there is one.</span>

            cMessage *msg = nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a861411e349fda127a4b66659f155659f">nudTimeoutEvent</a>;
            <span class="keywordflow">if</span> (msg != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
            {
                <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NUD in progress. Cancelling NUD Timer\n&quot;</span>;
                bubble(<span class="stringliteral">&quot;Reachability Confirmed via NUD.&quot;</span>);
                nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#ad89a5f7ec5a7834e440c4437d108687a">reachabilityExpires</a> = simTime() + ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ade85749f4c00abf6dcafe675997bc946">_getReachableTime</a>();
                cancelAndDelete(msg);
                nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a861411e349fda127a4b66659f155659f">nudTimeoutEvent</a> = <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
            }
        }
        <span class="keywordflow">else</span>
        {
            <span class="comment">//If the Solicited flag is zero</span>
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Solicited Flag is FALSE.\n&quot;</span>;
            <span class="comment">//and the link layer address was updated with a different address</span>

            <span class="keywordflow">if</span> (!(naMacAddr.<a class="code" href="class_m_a_c_address.html#a2d1669ce517436105cd75faed677a303" title="Returns true if the two addresses are equal.">equals</a>(nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a3b51b5802cd50245bc2cdbbca1069dd0">macAddress</a>)))
            {
                <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NA&#39;s MAC is different from NCE&#39;s.Set NCE state to STALE\n&quot;</span>;
                <span class="comment">//the state MUST be set to STALE.</span>
                nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a0895435c223a2d4f67f02c3c614afbb5">reachabilityState</a> = <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a115199155dd43585124db1d8f471025b">IPv6NeighbourCache::STALE</a>;
            }
            <span class="keywordflow">else</span>
                <span class="comment">//Otherwise, the entry&#39;s state remains unchanged.</span>
                <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NA&#39;s MAC is the same as NCE&#39;s. State remains unchanged.\n&quot;</span>;
        }
        <span class="comment">//(Next paragraph with explanation is omitted.-WEI)</span>

        <span class="comment">/*- The IsRouter flag in the cache entry MUST be set based on the</span>
<span class="comment">        Router flag in the received advertisement.*/</span>
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Updating NCE&#39;s router flag to &quot;</span> &lt;&lt; naRouterFlag &lt;&lt; endl;
        nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#af5203d6dd6d97a8b2baf782f44f8206f">isRouter</a> = naRouterFlag;

        <span class="comment">/*In those cases where the IsRouter flag changes from TRUE to FALSE as a</span>
<span class="comment">        result of this update, the node MUST remove that router from the Default</span>
<span class="comment">        Router List and update the Destination Cache entries for all destinations</span>
<span class="comment">        using that neighbor as a router as specified in Section 7.3.3. This is</span>
<span class="comment">        needed to detect when a node that is used as a router stops forwarding</span>
<span class="comment">        packets due to being configured as a host.*/</span>
        <span class="keywordflow">if</span> (nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a85fae78cf00dd05a864ec8112639b6d5">isDefaultRouter</a>() &amp;&amp; !nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#af5203d6dd6d97a8b2baf782f44f8206f">isRouter</a>)
            <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#a949aafe89b2ced9a3cba25ec476473a3">getDefaultRouterList</a>().<a class="code" href="class_i_pv6_neighbour_cache_1_1_default_router_list.html#adce978a2f79872422a2116018a254e44">remove</a>(*nce);

        <span class="comment">//TODO: remove destination cache entries</span>
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a348ba5dd9e93f4640d465a74b8a73d53"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processNAPacket" ref="a348ba5dd9e93f4640d465a74b8a73d53" args="(IPv6NeighbourAdvertisement *na, IPv6ControlInfo *naCtrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a348ba5dd9e93f4640d465a74b8a73d53">IPv6NeighbourDiscovery::processNAPacket</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *&#160;</td>
          <td class="paramname"><em>na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&#160;</td>
          <td class="paramname"><em>naCtrlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a7662f293fab21a873bb22edab70de5ce">processNDMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a8f18a6e238820911ee6253f12b766fad">validateNAPacket</a>(na, naCtrlInfo) == <span class="keyword">false</span>)
    {
        <span class="keyword">delete</span> naCtrlInfo;
        <span class="keyword">delete</span> na;
        <span class="keywordflow">return</span>;
    }

    <span class="comment">//Neighbour Advertisement Information</span>
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> naTargetAddr = na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#ab4ced614f69b3cf120dbb835fbd7c11b">getTargetAddress</a>();

    <span class="comment">//First, we check if the target address in NA is found in the interface it</span>
    <span class="comment">//was received on is tentative.</span>
    <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7" title="Returns an interface by its Id.">getInterfaceById</a>(naCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a74046fa005d98f0c304eb39eb28a1ec3">getInterfaceId</a>());
    <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a90fa17dc7efaa7170176e853cf32dfed" title="Returns true if the ith address of the interface is tentative.">isTentativeAddress</a>(naTargetAddr))
    {
        error(<span class="stringliteral">&quot;Duplicate Address Detected! Manual attention needed!&quot;</span>);
    }
    <span class="comment">//Logic as defined in Section 7.2.5</span>
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *neighbourEntry = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#af88ebc30d5f18f0a628ead79f1fc3cb9" title="Returns a neighbour entry, or NULL.">lookup</a>(naTargetAddr, ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>());

    <span class="keywordflow">if</span> (neighbourEntry == <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NA received. Target Address not found in Neighbour Cache\n&quot;</span>;
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Dropping NA packet.\n&quot;</span>;
        <span class="keyword">delete</span> naCtrlInfo;
        <span class="keyword">delete</span> na;
        <span class="keywordflow">return</span>;
    }

    <span class="comment">//Target Address has entry in Neighbour Cache</span>
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NA received. Target Address found in Neighbour Cache\n&quot;</span>;

    <span class="keywordflow">if</span> (neighbourEntry-&gt;reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1ac2cfd6c9d21c7d34d2f6f53d6cfe6638">IPv6NeighbourCache::INCOMPLETE</a>)
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a093219842e9055dc413f8f6d401001ee">processNAForIncompleteNCEState</a>(na, neighbourEntry);
    <span class="keywordflow">else</span>
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a58a8a7aaf00643c4eb0044cc1380413b">processNAForOtherNCEStates</a>(na, neighbourEntry);

    <span class="keyword">delete</span> naCtrlInfo;
    <span class="keyword">delete</span> na;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7662f293fab21a873bb22edab70de5ce"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processNDMessage" ref="a7662f293fab21a873bb22edab70de5ce" args="(ICMPv6Message *msg, IPv6ControlInfo *ctrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a7662f293fab21a873bb22edab70de5ce">IPv6NeighbourDiscovery::processNDMessage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_c_m_pv6_message.html">ICMPv6Message</a> *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&#160;</td>
          <td class="paramname"><em>ctrlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#ad90a981569779940aaffe6df55b6285b">handleMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (dynamic_cast&lt;IPv6RouterSolicitation *&gt;(msg))
    {
        <a class="code" href="class_i_pv6_router_solicitation.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6RouterSolicitation</a> *rs = (<a class="code" href="class_i_pv6_router_solicitation.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6RouterSolicitation</a> *)msg;
        <a class="code" href="class_i_pv6_neighbour_discovery.html#ac6f2316e1a19d2816bab83e96d11ef57">processRSPacket</a>(rs, ctrlInfo);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;IPv6RouterAdvertisement *&gt;(msg))
    {
        <a class="code" href="class_i_pv6_router_advertisement.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6RouterAdvertisement</a> *ra = (<a class="code" href="class_i_pv6_router_advertisement.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6RouterAdvertisement</a> *)msg;
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a4482770f35807ddc238a9259e85752e3">processRAPacket</a>(ra, ctrlInfo);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;IPv6NeighbourSolicitation *&gt;(msg))
    {
        <a class="code" href="class_i_pv6_neighbour_solicitation.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6NeighbourSolicitation</a> *ns = (<a class="code" href="class_i_pv6_neighbour_solicitation.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6NeighbourSolicitation</a> *)msg;
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a8d7676502f17ed01eb095afadab7bb33">processNSPacket</a>(ns, ctrlInfo);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;IPv6NeighbourAdvertisement *&gt;(msg))
    {
        <a class="code" href="class_i_pv6_neighbour_advertisement.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6NeighbourAdvertisement</a> *na = (<a class="code" href="class_i_pv6_neighbour_advertisement.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6NeighbourAdvertisement</a> *)msg;
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a348ba5dd9e93f4640d465a74b8a73d53">processNAPacket</a>(na, ctrlInfo);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;IPv6Redirect *&gt;(msg))
    {
        <a class="code" href="class_i_pv6_redirect.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6Redirect</a> *redirect = (<a class="code" href="class_i_pv6_redirect.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6Redirect</a> *)msg;
        <a class="code" href="class_i_pv6_neighbour_discovery.html#ab95f9c30abcda08c3b762d191df4a3ae">processRedirectPacket</a>(redirect, ctrlInfo);
    }
    <span class="keywordflow">else</span>
    {
        error(<span class="stringliteral">&quot;Unrecognized ND message!&quot;</span>);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="abccb93f2300252252370c5cfab5017c6"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processNSForNonTentativeAddress" ref="abccb93f2300252252370c5cfab5017c6" args="(IPv6NeighbourSolicitation *ns, IPv6ControlInfo *ctrlInfo, InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#abccb93f2300252252370c5cfab5017c6">IPv6NeighbourDiscovery::processNSForNonTentativeAddress</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&#160;</td>
          <td class="paramname"><em>ctrlInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a8d7676502f17ed01eb095afadab7bb33">processNSPacket()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//Neighbour Solicitation Information</span>
    <a class="code" href="class_m_a_c_address.html" title="Stores an IEEE 802 MAC address (6 octets = 48 bits).">MACAddress</a> nsMacAddr = ns-&gt;<a class="code" href="class_i_pv6_neighbour_solicitation.html#ade4c8874a206e1696e204264db63d415">getSourceLinkLayerAddress</a>();

    <span class="comment">//target addr is not tentative addr</span>
    <span class="comment">//solicitation processed as described in RFC2461:section 7.2.3</span>
    <span class="keywordflow">if</span> (nsCtrlInfo-&gt;getSrcAddr().isUnspecified())
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Address is duplicate! Inform Sender of duplicate address!\n&quot;</span>;
        <a class="code" href="class_i_pv6_neighbour_discovery.html#ac2a5f2e2cbd6845ecd10038fce448ead">sendSolicitedNA</a>(ns, nsCtrlInfo, ie);
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a8106a5866c58a9c6372c741a15ce943b">processNSWithSpecifiedSrcAddr</a>(ns, nsCtrlInfo, ie);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1d21eff02fed770d1bf56dbb995c3db9"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processNSForTentativeAddress" ref="a1d21eff02fed770d1bf56dbb995c3db9" args="(IPv6NeighbourSolicitation *ns, IPv6ControlInfo *ctrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a1d21eff02fed770d1bf56dbb995c3db9">IPv6NeighbourDiscovery::processNSForTentativeAddress</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&#160;</td>
          <td class="paramname"><em>ctrlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a8d7676502f17ed01eb095afadab7bb33">processNSPacket()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//Control Information</span>
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> nsSrcAddr = nsCtrlInfo-&gt;getSrcAddr();
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> nsDestAddr = nsCtrlInfo-&gt;getDestAddr();

    ASSERT(nsSrcAddr.<a class="code" href="class_i_pv6_address.html#a052b40d4f11c907cfacd29462dd5e385" title="Utility function based on getScope()">isUnicast</a>() || nsSrcAddr.<a class="code" href="class_i_pv6_address.html#af526cffcc3a4aa5bb96d307de6e8d448" title="Check if the IPv6 Address is undefined.">isUnspecified</a>());
    <span class="comment">//solicitation is processed as described in RFC2462:section 5.4.3</span>

    <span class="keywordflow">if</span> (nsSrcAddr.<a class="code" href="class_i_pv6_address.html#af526cffcc3a4aa5bb96d307de6e8d448" title="Check if the IPv6 Address is undefined.">isUnspecified</a>())
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Source Address is UNSPECIFIED. Sender is performing DAD\n&quot;</span>;

        <span class="comment">//Sender performing Duplicate Address Detection</span>
        <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#acbf9dbfff5efa25eec0982afa1bbf061" title="Checks if the address is one of the host&#39;s addresses, i.e.">isLocalAddress</a>(nsSrcAddr))     <span class="comment">// FIXME: isLocalAddress(UNSPECIFIED) is always false!!! Must write another check for detecting source is myself/foreign node!!!</span>
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NS comes from myself. Ignoring NS\n&quot;</span>;
        <span class="keywordflow">else</span>
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NS comes from another node. Address is duplicate!\n&quot;</span>;
            error(<span class="stringliteral">&quot;Duplicate Address Detected! Manual Attention Required!&quot;</span>);
        }
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nsSrcAddr.<a class="code" href="class_i_pv6_address.html#a052b40d4f11c907cfacd29462dd5e385" title="Utility function based on getScope()">isUnicast</a>())
    {
        <span class="comment">//Sender performing address resolution</span>
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Sender is performing Address Resolution\n&quot;</span>;
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Target Address is tentative. Ignoring NS.\n&quot;</span>;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8d7676502f17ed01eb095afadab7bb33"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processNSPacket" ref="a8d7676502f17ed01eb095afadab7bb33" args="(IPv6NeighbourSolicitation *ns, IPv6ControlInfo *naCtrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a8d7676502f17ed01eb095afadab7bb33">IPv6NeighbourDiscovery::processNSPacket</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&#160;</td>
          <td class="paramname"><em>naCtrlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a7662f293fab21a873bb22edab70de5ce">processNDMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//Control Information</span>
    <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7" title="Returns an interface by its Id.">getInterfaceById</a>(nsCtrlInfo-&gt;getInterfaceId());

    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> nsTargetAddr = ns-&gt;<a class="code" href="class_i_pv6_neighbour_solicitation.html#aa8758b1539001a247c925ead4856ec69">getTargetAddress</a>();

    <span class="comment">//RFC 2461:Section 7.2.3</span>
    <span class="comment">//If target address is not a valid &quot;unicast&quot; or anycast address assigned to the</span>
    <span class="comment">//receiving interface, we should silently discard the packet.</span>
    <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a72d9ee3401361c560c47f5172c05c1a4">validateNSPacket</a>(ns, nsCtrlInfo) == <span class="keyword">false</span>
            || ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#af4856e5c4da3563e03fbc388db63ba8a" title="Returns true if the given address is one of the addresses assigned, regardless whether it is tentativ...">hasAddress</a>(nsTargetAddr) == <span class="keyword">false</span>)
    {
        bubble(<span class="stringliteral">&quot;NS validation failed\n&quot;</span>);
        <span class="keyword">delete</span> nsCtrlInfo;
        <span class="keyword">delete</span> ns;
        <span class="keywordflow">return</span>;
    }

    bubble(<span class="stringliteral">&quot;NS validation passed.\n&quot;</span>);

    <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a90fa17dc7efaa7170176e853cf32dfed" title="Returns true if the ith address of the interface is tentative.">isTentativeAddress</a>(nsTargetAddr))
    {
        <span class="comment">//If the Target Address is tentative, the Neighbor Solicitation should</span>
        <span class="comment">//be processed as described in [ADDRCONF].</span>
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Process NS for Tentative target address.\n&quot;</span>;
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a1d21eff02fed770d1bf56dbb995c3db9">processNSForTentativeAddress</a>(ns, nsCtrlInfo);
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">//Otherwise, the following description applies.</span>
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Process NS for Non-Tentative target address.\n&quot;</span>;
        <a class="code" href="class_i_pv6_neighbour_discovery.html#abccb93f2300252252370c5cfab5017c6">processNSForNonTentativeAddress</a>(ns, nsCtrlInfo, ie);
    }

    <span class="keyword">delete</span> nsCtrlInfo;
    <span class="keyword">delete</span> ns;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8106a5866c58a9c6372c741a15ce943b"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processNSWithSpecifiedSrcAddr" ref="a8106a5866c58a9c6372c741a15ce943b" args="(IPv6NeighbourSolicitation *ns, IPv6ControlInfo *ctrlInfo, InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a8106a5866c58a9c6372c741a15ce943b">IPv6NeighbourDiscovery::processNSWithSpecifiedSrcAddr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&#160;</td>
          <td class="paramname"><em>ctrlInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#abccb93f2300252252370c5cfab5017c6">processNSForNonTentativeAddress()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//RFC 2461, Section 7.2.3</span>
    <span class="comment">/*If the Source Address is not the unspecified address and, on link layers</span>
<span class="comment">    that have addresses, the solicitation includes a Source Link-Layer Address</span>
<span class="comment">    option, then the recipient SHOULD create or update the Neighbor Cache entry</span>
<span class="comment">    for the IP Source Address of the solicitation.*/</span>

    <span class="comment">//Neighbour Solicitation Information</span>
    <a class="code" href="class_m_a_c_address.html" title="Stores an IEEE 802 MAC address (6 octets = 48 bits).">MACAddress</a> nsMacAddr = ns-&gt;<a class="code" href="class_i_pv6_neighbour_solicitation.html#ade4c8874a206e1696e204264db63d415">getSourceLinkLayerAddress</a>();

    <span class="keywordtype">int</span> ifID = ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>();

    <span class="comment">//Look for the Neighbour Cache Entry</span>
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *entry = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#af88ebc30d5f18f0a628ead79f1fc3cb9" title="Returns a neighbour entry, or NULL.">lookup</a>(nsCtrlInfo-&gt;getSrcAddr(), ifID);

    <span class="keywordflow">if</span> (entry == <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
    {
        <span class="comment">/*If an entry does not already exist, the node SHOULD create a new one</span>
<span class="comment">        and set its reachability state to STALE as specified in Section 7.3.3.*/</span>
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Neighbour Entry not found. Create a Neighbour Cache Entry.\n&quot;</span>;
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#ab0751209af2b66c4171f92ba6ed7eee1" title="Creates and initializes a neighbour entry with isRouter=false, state=INCOMPLETE.">addNeighbour</a>(nsCtrlInfo-&gt;getSrcAddr(), ifID, nsMacAddr);
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">/*If an entry already exists, and the cached link-layer address differs from</span>
<span class="comment">        the one in the received Source Link-Layer option,*/</span>
        <span class="keywordflow">if</span> (!(entry-&gt;macAddress.equals(nsMacAddr)) &amp;&amp; !nsMacAddr.<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107" title="Returns true if all address bytes are zero.">isUnspecified</a>())
        {
            <span class="comment">//the cached address should be replaced by the received address</span>
            entry-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a3b51b5802cd50245bc2cdbbca1069dd0">macAddress</a> = nsMacAddr;
            <span class="comment">//and the entry&#39;s reachability state MUST be set to STALE.</span>
            entry-&gt;reachabilityState = <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a115199155dd43585124db1d8f471025b">IPv6NeighbourCache::STALE</a>;
        }
    }

    <span class="comment">/*After any updates to the Neighbor Cache, the node sends a Neighbor</span>
<span class="comment">    Advertisement response as described in the next section.*/</span>
    <a class="code" href="class_i_pv6_neighbour_discovery.html#ac2a5f2e2cbd6845ecd10038fce448ead">sendSolicitedNA</a>(ns, nsCtrlInfo, ie);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a623b4069795d46d2b421d5aee4f1eb59"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processNUDTimeout" ref="a623b4069795d46d2b421d5aee4f1eb59" args="(cMessage *timeoutMsg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a623b4069795d46d2b421d5aee4f1eb59">IPv6NeighbourDiscovery::processNUDTimeout</a> </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>timeoutMsg</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#ad90a981569779940aaffe6df55b6285b">handleMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NUD has timed out\n&quot;</span>;
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *nce = (<a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *) timeoutMsg-&gt;getContextPointer();

    <span class="keyword">const</span> <a class="code" href="class_i_pv6_neighbour_discovery.html#a747705ed3b49881e2d144e2d9f0c8044">Key</a> *nceKey = nce-&gt;nceKey;
    <span class="keywordflow">if</span> ( nceKey == <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> )
        <span class="keywordflow">throw</span> cRuntimeError(<span class="stringliteral">&quot;The nceKey is NULL at nce-&gt;MAC=%s, isRouter=%d&quot;</span>,
                nce-&gt;macAddress.str().c_str(), nce-&gt;isRouter);

    <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7" title="Returns an interface by its Id.">getInterfaceById</a>(nceKey-&gt;interfaceID);

    <span class="keywordflow">if</span> (nce-&gt;reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a815cc3dd5d8b220495a69641b00f5bdb">IPv6NeighbourCache::DELAY</a>)
    {
        <span class="comment">/*If the entry is still in the DELAY state when the timer expires, the</span>
<span class="comment">        entry&#39;s state changes to PROBE. If reachability confirmation is received,</span>
<span class="comment">        the entry&#39;s state changes to REACHABLE.*/</span>
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Neighbour Entry is still in DELAY state.\n&quot;</span>;
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Entering PROBE state. Sending NS probe.\n&quot;</span>;
        nce-&gt;reachabilityState = <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a8fdd2d1853264aa8f5479ebfa6502054">IPv6NeighbourCache::PROBE</a>;
        nce-&gt;numProbesSent = 0;
    }

    <span class="comment">/*If no response is received after waiting RetransTimer milliseconds</span>
<span class="comment">    after sending the MAX_UNICAST_SOLICIT solicitations, retransmissions cease</span>
<span class="comment">    and the entry SHOULD be deleted. Subsequent traffic to that neighbor will</span>
<span class="comment">    recreate the entry and performs address resolution again.*/</span>
    <span class="keywordflow">if</span> (nce-&gt;numProbesSent == (<span class="keywordtype">int</span>)ie-&gt;ipv6Data()-&gt;_getMaxUnicastSolicit())
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Max number of probes have been sent.&quot;</span> &lt;&lt; endl;
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Neighbour is Unreachable, removing NCE.&quot;</span> &lt;&lt; endl;
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#a877bc367ca422baabc22199c5036df83" title="Deletes the given neighbour from the cache.">remove</a>(nceKey-&gt;address, nceKey-&gt;interfaceID);
        <span class="keywordflow">return</span>;
    }

    <span class="comment">/*Upon entering the PROBE state, a node sends a unicast Neighbor Solicitation</span>
<span class="comment">    message to the neighbor using the cached link-layer address.*/</span>
    <a class="code" href="class_i_pv6_neighbour_discovery.html#aedad2b550812f9be54ab691296e5876d">createAndSendNSPacket</a>(nceKey-&gt;address, nceKey-&gt;address,
        ie-&gt;ipv6Data()-&gt;getPreferredAddress(), ie);
    nce-&gt;numProbesSent++;
    <span class="comment">/*While in the PROBE state, a node retransmits Neighbor Solicitation messages</span>
<span class="comment">    every RetransTimer milliseconds until reachability confirmation is obtained.</span>
<span class="comment">    Probes are retransmitted even if no additional packets are sent to the</span>
<span class="comment">    neighbor.*/</span>
    scheduleAt(simTime()+ie-&gt;ipv6Data()-&gt;_getRetransTimer(), timeoutMsg);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a41da6658d387e46e3e656d4704bf908f"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processRAForRouterUpdates" ref="a41da6658d387e46e3e656d4704bf908f" args="(IPv6RouterAdvertisement *ra, IPv6ControlInfo *raCtrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a41da6658d387e46e3e656d4704bf908f">IPv6NeighbourDiscovery::processRAForRouterUpdates</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *&#160;</td>
          <td class="paramname"><em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&#160;</td>
          <td class="paramname"><em>raCtrlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a4482770f35807ddc238a9259e85752e3">processRAPacket()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Processing RA for Router Updates\n&quot;</span>;
    <span class="comment">//RFC2461: Section 6.3.4</span>
    <span class="comment">//Paragraphs 1 and 2 omitted.</span>

    <span class="comment">//On receipt of a valid Router Advertisement, a host extracts the source</span>
    <span class="comment">//address of the packet and does the following:</span>
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> raSrcAddr = raCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a8980bdcd6051ae3fe071bf2c18a0215e">getSrcAddr</a>();
    <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7" title="Returns an interface by its Id.">getInterfaceById</a>(raCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a74046fa005d98f0c304eb39eb28a1ec3">getInterfaceId</a>());
    <span class="keywordtype">int</span> ifID = ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>();

    <span class="comment">/*- If the address is not already present in the host&#39;s Default Router List,</span>
<span class="comment">    and the advertisement&#39;s Router Lifetime is non-zero, create a new entry in</span>
<span class="comment">    the list, and initialize its invalidation timer value from the advertisement&#39;s</span>
<span class="comment">    Router Lifetime field.*/</span>
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *neighbour = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#af88ebc30d5f18f0a628ead79f1fc3cb9" title="Returns a neighbour entry, or NULL.">lookup</a>(raSrcAddr, ifID);

<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>    <span class="comment">// update 3.9.07 - CB // if (neighbour == NULL &amp;&amp; (ra-&gt;homeAgentFlag() == true)) //the RA is from a Router acting as a Home Agent as well</span>
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

    <span class="keywordflow">if</span> (neighbour == <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Neighbour Cache Entry does not contain RA&#39;s source address\n&quot;</span>;
        <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a8792d1615047ca1fbaa446c1a8316f9a">getRouterLifetime</a>() != 0)
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;RA&#39;s router lifetime is non-zero, creating an entry in the &quot;</span>
               &lt;&lt; <span class="stringliteral">&quot;Host&#39;s default router list with lifetime=&quot;</span> &lt;&lt; ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a8792d1615047ca1fbaa446c1a8316f9a">getRouterLifetime</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>            <span class="comment">// initiate neighbour unreachability detection for existing routers and remove default route(r), 3.9.07 - CB</span>
            <span class="comment">// TODO improve this code</span>
            routersUnreachabilityDetection(ie);
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

            <span class="comment">//If a Neighbor Cache entry is created for the router its reachability</span>
            <span class="comment">//state MUST be set to STALE as specified in Section 7.3.3.</span>
            neighbour = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#a7ff5ebbb09aa68832cf6e1260fadfbcf" title="Creates and initializes a router entry (isRouter=isDefaultRouter=true), MAC address and state=STALE...">addRouter</a>(raSrcAddr, ifID,
#ifndef WITH_xMIPv6
                ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a705aaac520402119b8aa6e9efc5ceb64">getSourceLinkLayerAddress</a>(), simTime() + ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a8792d1615047ca1fbaa446c1a8316f9a">getRouterLifetime</a>());
<span class="preprocessor">#else </span><span class="comment">/* WITH_xMIPv6 */</span>
                ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a705aaac520402119b8aa6e9efc5ceb64">getSourceLinkLayerAddress</a>(), simTime() + ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a8792d1615047ca1fbaa446c1a8316f9a">getRouterLifetime</a>(), ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#ab561e70dc80f515f1780a8e9dc6866a7">getHomeAgentFlag</a>() );
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>
            <span class="comment">//According to Greg, we should add a default route for hosts as well!</span>
            <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#a50f73e181d9c5e965ad72f74f0b43c40" title="Adds a default route for a host.">addDefaultRoute</a>(raSrcAddr, ifID, simTime() + ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a8792d1615047ca1fbaa446c1a8316f9a">getRouterLifetime</a>());
        }
        <span class="keywordflow">else</span>
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Router Lifetime is 0, adding NON-default router.\n&quot;</span>;
            <span class="comment">//WEI-The router is advertising itself, BUT not as a default router.</span>
            <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a705aaac520402119b8aa6e9efc5ceb64">getSourceLinkLayerAddress</a>().<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107" title="Returns true if all address bytes are zero.">isUnspecified</a>())
                neighbour = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#ab0751209af2b66c4171f92ba6ed7eee1" title="Creates and initializes a neighbour entry with isRouter=false, state=INCOMPLETE.">addNeighbour</a>(raSrcAddr, ifID);
            <span class="keywordflow">else</span>
                neighbour = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#ab0751209af2b66c4171f92ba6ed7eee1" title="Creates and initializes a neighbour entry with isRouter=false, state=INCOMPLETE.">addNeighbour</a>(raSrcAddr, ifID,
                    ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a705aaac520402119b8aa6e9efc5ceb64">getSourceLinkLayerAddress</a>());
            neighbour-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#af5203d6dd6d97a8b2baf782f44f8206f">isRouter</a> = <span class="keyword">true</span>;
        }
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">//If no Source Link-Layer Address is included, but a corresponding Neighbor</span>
        <span class="comment">//Cache entry exists, its IsRouter flag MUST be set to TRUE.</span>
        neighbour-&gt;isRouter = <span class="keyword">true</span>;

        <span class="comment">//If a cache entry already exists and is updated with a different link-</span>
        <span class="comment">//layer address the reachability state MUST also be set to STALE.</span>
        <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a705aaac520402119b8aa6e9efc5ceb64">getSourceLinkLayerAddress</a>().<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107" title="Returns true if all address bytes are zero.">isUnspecified</a>() == <span class="keyword">false</span> &amp;&amp;
                neighbour-&gt;macAddress.equals(ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a705aaac520402119b8aa6e9efc5ceb64">getSourceLinkLayerAddress</a>()) == <span class="keyword">false</span>)
            neighbour-&gt;macAddress = ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a705aaac520402119b8aa6e9efc5ceb64">getSourceLinkLayerAddress</a>();

        <span class="comment">/*- If the address is already present in the host&#39;s Default Router List</span>
<span class="comment">        as a result of a previously-received advertisement, reset its invalidation</span>
<span class="comment">        timer to the Router Lifetime value in the newly-received advertisement.*/</span>
        neighbour-&gt;routerExpiryTime = simTime()+ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a8792d1615047ca1fbaa446c1a8316f9a">getRouterLifetime</a>();

        <span class="comment">/*- If the address is already present in the host&#39;s Default Router List</span>
<span class="comment">        and the received Router Lifetime value is zero, immediately time-out the</span>
<span class="comment">        entry as specified in Section 6.3.5.*/</span>
        <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a8792d1615047ca1fbaa446c1a8316f9a">getRouterLifetime</a>() == 0)
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;RA&#39;s router lifetime is ZERO. Timing-out entry.\n&quot;</span>;
            <a class="code" href="class_i_pv6_neighbour_discovery.html#a303391440ad2004ff69cfc5e4cf7504a" title="RFC 2461: Section 6.3.5 Whenever the Lifetime of an entry in the Default Router List expires...">timeoutDefaultRouter</a>(raSrcAddr, ifID);
        }
    }

    <span class="comment">//Paragraph Omitted.</span>

    <span class="comment">//If the received Cur Hop Limit value is non-zero the host SHOULD set</span>
    <span class="comment">//its CurHopLimit variable to the received value.</span>
    <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a7fb846c4b2c00e4f21b2548229e0f617">getCurHopLimit</a>() != 0)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;RA&#39;s Cur Hop Limit is non-zero. Setting host&#39;s Cur Hop Limit to &quot;</span>
           &lt;&lt; <span class="stringliteral">&quot;received value.\n&quot;</span>;
        ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a1ea2f32f4ae7ebbfa060ea5af5b7c603">setCurHopLimit</a>(ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a7fb846c4b2c00e4f21b2548229e0f617">getCurHopLimit</a>());
    }

    <span class="comment">//If the received Reachable Time value is non-zero the host SHOULD set its</span>
    <span class="comment">//BaseReachableTime variable to the received value.</span>
    <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#acfc4519404fc893bc99e7f0d9e1d531e">getReachableTime</a>() != 0)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;RA&#39;s reachable time is non-zero &quot;</span>;

        <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#acfc4519404fc893bc99e7f0d9e1d531e">getReachableTime</a>() != SIMTIME_DBL(ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a70e0316819b7cf06ec2174cda007840f">getReachableTime</a>()))
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot; and RA&#39;s and Host&#39;s reachable time differ, \nsetting host&#39;s base&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot; reachable time to received value.\n&quot;</span>;
            ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ae4305f5d17e9073b911ab750b3a4fb78">setBaseReachableTime</a>(ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#acfc4519404fc893bc99e7f0d9e1d531e">getReachableTime</a>());
            <span class="comment">//If the new value differs from the previous value, the host SHOULD</span>
            <span class="comment">//recompute a new random ReachableTime value.</span>
            ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#aa9a9bd84379adbe33bb06319f8e1e807">setReachableTime</a>(ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a923ed5aa070331f87ff6a541387b046a" title="This method randomly generates a reachableTime given the MIN_RANDOM_FACTOR MAX_RANDOM_FACTOR and base...">generateReachableTime</a>());
        }

        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; endl;
    }

    <span class="comment">//The RetransTimer variable SHOULD be copied from the Retrans Timer field,</span>
    <span class="comment">//if the received value is non-zero.</span>
    <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a7478bb558c46dec7f012860622cff7e2">getRetransTimer</a>() != 0)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;RA&#39;s retrans timer is non-zero, copying retrans timer variable.\n&quot;</span>;
        ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ae017519c2fb2144ad9e5827f12cb4740">setRetransTimer</a>(ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a7478bb558c46dec7f012860622cff7e2">getRetransTimer</a>());
    }

    <span class="comment">/*If the MTU option is present, hosts SHOULD copy the option&#39;s value into</span>
<span class="comment">    LinkMTU so long as the value is greater than or equal to the minimum link MTU</span>
<span class="comment">    [IPv6] and does not exceed the default LinkMTU value specified in the link</span>
<span class="comment">    type specific document (e.g., [IPv6-ETHER]).*/</span>
    <span class="comment">//TODO: not done yet</span>

    <a class="code" href="class_i_pv6_neighbour_discovery.html#a5acf0814f6ca500c38d87763c0a5aef7">processRAPrefixInfo</a>(ra, ie);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4482770f35807ddc238a9259e85752e3"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processRAPacket" ref="a4482770f35807ddc238a9259e85752e3" args="(IPv6RouterAdvertisement *ra, IPv6ControlInfo *raCtrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a4482770f35807ddc238a9259e85752e3">IPv6NeighbourDiscovery::processRAPacket</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *&#160;</td>
          <td class="paramname"><em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&#160;</td>
          <td class="paramname"><em>raCtrlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a7662f293fab21a873bb22edab70de5ce">processNDMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7" title="Returns an interface by its Id.">getInterfaceById</a>(raCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a74046fa005d98f0c304eb39eb28a1ec3">getInterfaceId</a>());

    <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ad25e520c7730fff1647b57ba206573ed">getAdvSendAdvertisements</a>())
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Interface is an advertising interface, dropping RA message.\n&quot;</span>;
        <span class="keyword">delete</span> ra;
        <span class="keywordflow">return</span>;
    }
    <span class="keywordflow">else</span>
    {
        <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a902261563ea0bd130700a148a062781c">validateRAPacket</a>(ra, raCtrlInfo) == <span class="keyword">false</span>)
        {
            <span class="keyword">delete</span> ra;
            <span class="keywordflow">return</span>;
        }

<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>        <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;isDADInProgress())
        {
            <span class="comment">// in case we are currently performing DAD we ignore this RA</span>
            <span class="comment">// TODO improve this procedure in order to allow reinitiating DAD</span>
            <span class="comment">// (which means cancel current DAD, start new DAD)</span>
            <span class="keyword">delete</span> ra;
            <span class="keywordflow">return</span>;
        }
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

        <a class="code" href="class_i_pv6_neighbour_discovery.html#a01e12e84e38baf2539a8335f8f01abc6" title="RFC 2461: Section 6.3.7 4th paragraph Once the host sends a Router Solicitation, and receives a valid...">cancelRouterDiscovery</a>(ie); <span class="comment">//Cancel router discovery if it is in progress.</span>
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Interface is a host, processing RA.\n&quot;</span>;

        <a class="code" href="class_i_pv6_neighbour_discovery.html#a41da6658d387e46e3e656d4704bf908f">processRAForRouterUpdates</a>(ra, raCtrlInfo); <span class="comment">//See RFC2461: Section 6.3.4</span>

        <span class="comment">//Possible options</span>
        <a class="code" href="class_m_a_c_address.html" title="Stores an IEEE 802 MAC address (6 octets = 48 bits).">MACAddress</a> macAddress = ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a705aaac520402119b8aa6e9efc5ceb64">getSourceLinkLayerAddress</a>();
        <a class="code" href="_i_n_e_t_defs_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> mtu = ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#ac81af8393ce5a310e51a126d37a50751">getMTU</a>();
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (int)ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a5189c47459ce2df26c6067b00bf6a670">getPrefixInformationArraySize</a>(); i++)
        {
            <a class="code" href="class_i_pv6_n_d_prefix_information.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6NDPrefixInformation</a>&amp; prefixInfo = ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#ab0392fb8b0189220ef2c47c8fa3dc898">getPrefixInformation</a>(i);
            <span class="keywordflow">if</span> (prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a8d2e5ddefb6960d75a594dad8574c1c6">getAutoAddressConfFlag</a>() == <span class="keyword">true</span>)<span class="comment">//If auto addr conf is set</span>
            {
<span class="preprocessor">#ifndef WITH_xMIPv6</span>
<span class="preprocessor"></span>                <a class="code" href="class_i_pv6_neighbour_discovery.html#ae187033477823763f0fc0063353821f6">processRAPrefixInfoForAddrAutoConf</a>(prefixInfo, ie); <span class="comment">//We process prefix Info and form an addr</span>
<span class="preprocessor">#else </span><span class="comment">/* WITH_xMIPv6 */</span>
                <a class="code" href="class_i_pv6_neighbour_discovery.html#ae187033477823763f0fc0063353821f6">processRAPrefixInfoForAddrAutoConf</a>(prefixInfo, ie, ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#ab561e70dc80f515f1780a8e9dc6866a7">getHomeAgentFlag</a>() ); <span class="comment">// then calling the overloaded function for address configuration. The address conf for MN is different from other nodes as it needs to classify the newly formed address as HoA or CoA, depending on the status of the H-Flag. (Zarrar Yousaf 20.07.07)</span>
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>
            }

<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>            <span class="comment">// When in foreign network(s), the MN needs info about its HA address and its own Home Address (HoA), when sending BU to HA and CN(s). Therefore while in the home network I intialise struct HomeNetworkInfo{} with HoA and HA address, which will eventually be used by the MN while sending BUs from within visit networks. (Zarrar Yousaf 12.07.07)</span>
            <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#ab561e70dc80f515f1780a8e9dc6866a7">getHomeAgentFlag</a>() &amp;&amp; (prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a78f3b981cb083763869ff787e3987e99">getRouterAddressFlag</a>() == <span class="keyword">true</span>))<span class="comment">//If R-Flag is set and RA is from HA</span>
            {
                <span class="comment">// homeNetworkInfo now carries HoA, global unicast HA address and the home network prefix</span>
                <span class="comment">// update 4.9.07 - CB</span>
                <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> HoA = ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;getGlobalAddress(); <span class="comment">//MN&#39;s home address</span>
                <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> HA = raCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a8980bdcd6051ae3fe071bf2c18a0215e">getSrcAddr</a>().<a class="code" href="class_i_pv6_address.html#a6820830388fdffcd01de42d2f9fe2762" title="Overwrites the first prefixLength bits of the address with the bits from the address passed as argume...">setPrefix</a>(prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a769743b8ab554bc69cc0830652aa5c1d">getPrefix</a>(), prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#aefcf84ae46359b9030835aea70799795">getPrefixLength</a>());
                <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;The HoA of MN is: &quot;</span> &lt;&lt; HoA &lt;&lt; <span class="stringliteral">&quot;, MN&#39;s HA Address is: &quot;</span> &lt;&lt; HA
                   &lt;&lt; <span class="stringliteral">&quot; and the home prefix is &quot;</span> &lt;&lt; prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a769743b8ab554bc69cc0830652aa5c1d">getPrefix</a>() &lt;&lt; endl;
                ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;updateHomeNetworkInfo(HoA, HA, prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a769743b8ab554bc69cc0830652aa5c1d">getPrefix</a>(), prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#aefcf84ae46359b9030835aea70799795">getPrefixLength</a>()); <span class="comment">//populate the HoA of MN, the HA global scope address and the home network prefix</span>
            }
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>
        }
    }
    <span class="keyword">delete</span> raCtrlInfo;
    <span class="keyword">delete</span> ra;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5acf0814f6ca500c38d87763c0a5aef7"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processRAPrefixInfo" ref="a5acf0814f6ca500c38d87763c0a5aef7" args="(IPv6RouterAdvertisement *ra, InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a5acf0814f6ca500c38d87763c0a5aef7">IPv6NeighbourDiscovery::processRAPrefixInfo</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *&#160;</td>
          <td class="paramname"><em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a41da6658d387e46e3e656d4704bf908f">processRAForRouterUpdates()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//Continued from section 6.3.4</span>
    <span class="comment">/*Prefix Information options that have the &quot;on-link&quot; (L) flag set indicate a</span>
<span class="comment">    prefix identifying a range of addresses that should be considered on-link.</span>
<span class="comment">    Note, however, that a Prefix Information option with the on-link flag set to</span>
<span class="comment">    zero conveys no information concerning on-link determination and MUST NOT be</span>
<span class="comment">    interpreted to mean that addresses covered by the prefix are off-link. The</span>
<span class="comment">    only way to cancel a previous on-link indication is to advertise that prefix</span>
<span class="comment">    with the L-bit set and the Lifetime set to zero. The default behavior (see</span>
<span class="comment">    Section 5.2) when sending a packet to an address for which no information is</span>
<span class="comment">    known about the on-link status of the address is to forward the packet to a</span>
<span class="comment">    default router; the reception of a Prefix Information option with the &quot;on-link &quot;</span>
<span class="comment">    (L) flag set to zero does not change this behavior. The reasons for an address</span>
<span class="comment">    being treated as on-link is specified in the definition of &quot;on-link&quot; in</span>
<span class="comment">    Section 2.1. Prefixes with the on-link flag set to zero would normally have</span>
<span class="comment">    the autonomous flag set and be used by [ADDRCONF].*/</span>
    <a class="code" href="class_i_pv6_n_d_prefix_information.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6NDPrefixInformation</a> prefixInfo;
    <span class="comment">//For each Prefix Information option</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (int)ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a5189c47459ce2df26c6067b00bf6a670">getPrefixInformationArraySize</a>(); i++)
    {
        prefixInfo = ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#ab0392fb8b0189220ef2c47c8fa3dc898">getPrefixInformation</a>(i);
        <span class="keywordflow">if</span> (!prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a62f9e56892d77b017288a1461d8edba1">getOnlinkFlag</a>()) <span class="keywordflow">break</span>; <span class="comment">//skip to next prefix option</span>

        <span class="comment">//with the on-link flag set, a host does the following:</span>
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Fetching Prefix Information:&quot;</span> &lt;&lt; i+1 &lt;&lt; <span class="stringliteral">&quot; of &quot;</span>
           &lt;&lt; ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a5189c47459ce2df26c6067b00bf6a670">getPrefixInformationArraySize</a>() &lt;&lt; endl;
        <a class="code" href="_i_n_e_t_defs_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> prefixLength = prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#aefcf84ae46359b9030835aea70799795">getPrefixLength</a>();
        simtime_t validLifetime = prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a93e32dbccf0d60cff0269f4450d6323e">getValidLifetime</a>();
        <a class="code" href="_i_n_e_t_defs_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> preferredLifetime = prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a4bbcfaafccb44d3e136cd17627f46641">getPreferredLifetime</a>();
        <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> prefix = prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a769743b8ab554bc69cc0830652aa5c1d">getPrefix</a>();

        <span class="comment">//- If the prefix is the link-local prefix, silently ignore the Prefix</span>
        <span class="comment">//Information option.</span>
        <span class="keywordflow">if</span> (prefix.<a class="code" href="class_i_pv6_address.html#a304edc5014ff3c991ae531aca21d2260" title="Utility function based on getScope()">isLinkLocal</a>())
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Prefix is link-local, ignoring prefix.\n&quot;</span>;
            <span class="keywordflow">return</span>;
        }

        <span class="comment">//- If the prefix is not already present in the Prefix List,</span>
        <span class="keywordflow">if</span> (!<a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#afef0aa2431b02b3744b58238c7a73547" title="Checks if the given prefix already exists in the routing table (prefix list)">isPrefixPresent</a>(prefix))
        {
            <span class="comment">//and the Prefix Information option&#39;s Valid Lifetime field is non-zero,</span>
            <span class="keywordflow">if</span> (validLifetime != 0)
            {
                <span class="comment">/*create a new entry for the prefix and initialize its invalidation</span>
<span class="comment">                timer to the Valid Lifetime value in the Prefix Information option.*/</span>
                <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#ad942d6cb5b1376b132947f75924344f6" title="Add on-link prefix (route of type FROM_RA), or update existing one.">addOrUpdateOnLinkPrefix</a>(prefix, prefixLength, ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>(),
                    simTime()+validLifetime);
            }
            <span class="comment">/*- If the Prefix Information option&#39;s Valid Lifetime field is zero,</span>
<span class="comment">            and the prefix is not present in the host&#39;s Prefix List,</span>
<span class="comment">            silently ignore the option.*/</span>
        }
        <span class="keywordflow">else</span>
        {
            <span class="comment">/* If the new Lifetime value is zero, time-out the prefix immediately</span>
<span class="comment">            (see Section 6.3.5).*/</span>
            <span class="keywordflow">if</span> (validLifetime == 0)
            {
                <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Prefix Info&#39;s valid lifetime is 0, time-out prefix\n&quot;</span>;
                <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#a85e00922381c188efc0ad51197e5f718" title="Remove an on-link prefix.">removeOnLinkPrefix</a>(prefix, prefixLength);
                <span class="keywordflow">return</span>;
            }

            <span class="comment">/*- If the prefix is already present in the host&#39;s Prefix List as</span>
<span class="comment">            the result of a previously-received advertisement, reset its</span>
<span class="comment">            invalidation timer to the Valid Lifetime value in the Prefix</span>
<span class="comment">            Information option.*/</span>
            <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#ad942d6cb5b1376b132947f75924344f6" title="Add on-link prefix (route of type FROM_RA), or update existing one.">addOrUpdateOnLinkPrefix</a>(prefix, prefixLength, ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>(),
                    simTime() + validLifetime);
        }

        <span class="comment">/*Stateless address autoconfiguration [ADDRCONF] may in some</span>
<span class="comment">        circumstances increase the Valid Lifetime of a prefix or ignore it</span>
<span class="comment">        completely in order to prevent a particular denial of service attack.</span>
<span class="comment">        However, since the effect of the same denial of service targeted at</span>
<span class="comment">        the on-link prefix list is not catastrophic (hosts would send packets</span>
<span class="comment">        to a default router and receive a redirect rather than sending</span>
<span class="comment">        packets directly to a neighbor) the Neighbor Discovery protocol does</span>
<span class="comment">        not impose such a check on the prefix lifetime values.*/</span>
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae187033477823763f0fc0063353821f6"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processRAPrefixInfoForAddrAutoConf" ref="ae187033477823763f0fc0063353821f6" args="(IPv6NDPrefixInformation &amp;prefixInfo, InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#ae187033477823763f0fc0063353821f6">IPv6NeighbourDiscovery::processRAPrefixInfoForAddrAutoConf</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_n_d_prefix_information.html">IPv6NDPrefixInformation</a> &amp;&#160;</td>
          <td class="paramname"><em>prefixInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a4482770f35807ddc238a9259e85752e3">processRAPacket()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Processing Prefix Info for address auto-configuration.\n&quot;</span>;
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> prefix = prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a769743b8ab554bc69cc0830652aa5c1d">getPrefix</a>();
    <a class="code" href="_i_n_e_t_defs_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> prefixLength = prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#aefcf84ae46359b9030835aea70799795">getPrefixLength</a>();
    simtime_t preferredLifetime = prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a4bbcfaafccb44d3e136cd17627f46641">getPreferredLifetime</a>();
    simtime_t validLifetime = prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a93e32dbccf0d60cff0269f4450d6323e">getValidLifetime</a>();

    <span class="comment">//RFC 2461: Section 5.5.3</span>
    <span class="comment">//First condition tested, the autonomous flag is already set</span>

    <span class="comment">//b) If the prefix is the link-local prefix, silently ignore the Prefix</span>
    <span class="comment">//Information option.</span>
    <span class="keywordflow">if</span> (prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a769743b8ab554bc69cc0830652aa5c1d">getPrefix</a>().<a class="code" href="class_i_pv6_address.html#a304edc5014ff3c991ae531aca21d2260" title="Utility function based on getScope()">isLinkLocal</a>() == <span class="keyword">true</span>)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Prefix is link-local, ignore Prefix Information Option\n&quot;</span>;
        <span class="keywordflow">return</span>;
    }

    <span class="comment">//c) If the preferred lifetime is greater than the valid lifetime, silently</span>
    <span class="comment">//ignore the Prefix Information option. A node MAY wish to log a system</span>
    <span class="comment">//management error in this case.</span>
    <span class="keywordflow">if</span> (preferredLifetime &gt; validLifetime)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Preferred lifetime is greater than valid lifetime, ignore Prefix Information\n&quot;</span>;
        <span class="keywordflow">return</span>;
    }

    <span class="keywordtype">bool</span> isPrefixAssignedToInterface = <span class="keyword">false</span>;
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ae4fe7ab839b3c7f08226eed79f224103" title="Returns the number of addresses the interface has.">getNumAddresses</a>(); i++)
    {
        <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a908a45071d8685ebbb01f73bb086525b" title="Returns ith address of the interface.">getAddress</a>(i).<a class="code" href="class_i_pv6_address.html#a4d9102b52fcf98d1945c75a098bc678a" title="Returns true if the address matches the given prefix.">matches</a>(prefix, prefixLength) == <span class="keyword">true</span>)
            isPrefixAssignedToInterface = <span class="keyword">true</span>;
    }

    <span class="comment">/*d) If the prefix advertised does not match the prefix of an address already</span>
<span class="comment">         in the list, and the Valid Lifetime is not 0, form an address (and add</span>
<span class="comment">         it to the list) by combining the advertised prefix with the link�s</span>
<span class="comment">         interface identifier as follows:*/</span>
    <span class="keywordflow">if</span> (isPrefixAssignedToInterface == <span class="keyword">false</span> &amp;&amp; validLifetime != 0)
    {
        <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> linkLocalAddress = ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a3b9fa2d8e186014cf9c758e45b5a56df" title="Returns the first valid link-local address of the interface, or UNSPECIFIED_ADDRESS if there&#39;s none...">getLinkLocalAddress</a>();
        ASSERT(linkLocalAddress.<a class="code" href="class_i_pv6_address.html#af526cffcc3a4aa5bb96d307de6e8d448" title="Check if the IPv6 Address is undefined.">isUnspecified</a>() == <span class="keyword">false</span>);
        <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> newAddr = linkLocalAddress.<a class="code" href="class_i_pv6_address.html#a6820830388fdffcd01de42d2f9fe2762" title="Overwrites the first prefixLength bits of the address with the bits from the address passed as argume...">setPrefix</a>(prefix, prefixLength);
        <span class="comment">//TODO: for now we leave the newly formed address as not tentative,</span>
        <span class="comment">//according to Greg, we have to always perform DAD for a newly formed address.</span>
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Assigning new address to: &quot;</span> &lt;&lt; ie-&gt;getName() &lt;&lt; endl;
        ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a715b339dc41612149940ed0607af1535" title="Assigns the given address to the interface.">assignAddress</a>(newAddr, <span class="keyword">false</span>, simTime()+validLifetime,
                simTime()+preferredLifetime);
    }

    <span class="comment">//TODO: this is the simplified version.</span>
    <span class="comment">/*e) If the advertised prefix matches the prefix of an autoconfigured</span>
<span class="comment">       address (i.e., one obtained via stateless or stateful address</span>
<span class="comment">       autoconfiguration) in the list of addresses associated with the</span>
<span class="comment">       interface, the specific action to perform depends on the Valid</span>
<span class="comment">       Lifetime in the received advertisement and the Lifetime</span>
<span class="comment">       associated with the previously autoconfigured address (which we</span>
<span class="comment">       call StoredLifetime in the discussion that follows):</span>
<span class="comment"></span>
<span class="comment">       1) If the received Lifetime is greater than 2 hours or greater</span>
<span class="comment">          than StoredLifetime, update the stored Lifetime of the</span>
<span class="comment">          corresponding address.</span>
<span class="comment"></span>
<span class="comment">       2) If the StoredLifetime is less than or equal to 2 hours and the</span>
<span class="comment">          received Lifetime is less than or equal to StoredLifetime,</span>
<span class="comment">          ignore the prefix, unless the Router Advertisement from which</span>
<span class="comment"></span>
<span class="comment">          this Prefix Information option was obtained has been</span>
<span class="comment">          authenticated (e.g., via IPSec [RFC2402]). If the Router</span>
<span class="comment">          Advertisment was authenticated, the StoredLifetime should be</span>
<span class="comment">          set to the Lifetime in the received option.</span>
<span class="comment"></span>
<span class="comment">       3) Otherwise, reset the stored Lifetime in the corresponding</span>
<span class="comment">          address to two hours.*/</span>

}
</pre></div>
</div>
</div>
<a class="anchor" id="a860a64e4fbb311fef343ec7044c0a10b"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processRDTimeout" ref="a860a64e4fbb311fef343ec7044c0a10b" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a860a64e4fbb311fef343ec7044c0a10b">IPv6NeighbourDiscovery::processRDTimeout</a> </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#ad90a981569779940aaffe6df55b6285b">handleMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = (<a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *)msg-&gt;getContextPointer();
    RDEntry *rdEntry = <a class="code" href="class_i_pv6_neighbour_discovery.html#ab83db378f6596fd37ab6657b13707aa4">fetchRDEntry</a>(ie);

    <span class="keywordflow">if</span> (rdEntry-&gt;numRSSent &lt; ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a69b000519d337acd94ce828a7c3f2373">_getMaxRtrSolicitations</a>())
    {
        bubble(<span class="stringliteral">&quot;Sending another RS message.&quot;</span>);
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a75431d6a5076b17ae0630f2fc4aa441a">createAndSendRSPacket</a>(ie);
        rdEntry-&gt;numRSSent++;

        <span class="comment">//Need to find out if this is the last RS we are sending out.</span>
        <span class="keywordflow">if</span> (rdEntry-&gt;numRSSent == ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a69b000519d337acd94ce828a7c3f2373">_getMaxRtrSolicitations</a>())
            scheduleAt(simTime() + ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a988083d3c03f3c9c04ba6b85bbdcca4d">_getMaxRtrSolicitationDelay</a>(), msg);
        <span class="keywordflow">else</span>
            scheduleAt(simTime() + ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ae0ae3a3184f559d08910a20e3ea7c2c6">_getRtrSolicitationInterval</a>(), msg);
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">//RFC 2461, Section 6.3.7</span>
        <span class="comment">/*If a host sends MAX_RTR_SOLICITATIONS solicitations, and receives no Router</span>
<span class="comment">        Advertisements after having waited MAX_RTR_SOLICITATION_DELAY seconds after</span>
<span class="comment">        sending the last solicitation, the host concludes that there are no routers</span>
<span class="comment">        on the link for the purpose of [ADDRCONF]. However, the host continues to</span>
<span class="comment">        receive and process Router Advertisements messages in the event that routers</span>
<span class="comment">        appear on the link.*/</span>
        bubble(<span class="stringliteral">&quot;Max number of RS messages sent&quot;</span>);
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;No RA messages were received. Assume no routers are on-link&quot;</span>;
        <span class="keyword">delete</span> rdEntry;
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a7f075a086f580756337ef6f59223727c">rdList</a>.erase(rdEntry);
        <span class="keyword">delete</span> msg;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab95f9c30abcda08c3b762d191df4a3ae"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processRedirectPacket" ref="ab95f9c30abcda08c3b762d191df4a3ae" args="(IPv6Redirect *redirect, IPv6ControlInfo *ctrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#ab95f9c30abcda08c3b762d191df4a3ae">IPv6NeighbourDiscovery::processRedirectPacket</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_redirect.html">IPv6Redirect</a> *&#160;</td>
          <td class="paramname"><em>redirect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&#160;</td>
          <td class="paramname"><em>ctrlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a7662f293fab21a873bb22edab70de5ce">processNDMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//First we need to extract information from the redirect message</span>
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> targetAddr = redirect-&gt;<a class="code" href="class_i_pv6_redirect.html#abb02c3892f73bd9bec0a57f9c839ab19">getTargetAddress</a>(); <span class="comment">//Addressed to me</span>
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> destAddr = redirect-&gt;<a class="code" href="class_i_pv6_redirect.html#a786a7735f06ed73eeb90776ea962c74b">getDestinationAddress</a>(); <span class="comment">//new dest addr</span>

    <span class="comment">//Optional</span>
    <a class="code" href="class_m_a_c_address.html" title="Stores an IEEE 802 MAC address (6 octets = 48 bits).">MACAddress</a> macAddr = redirect-&gt;<a class="code" href="class_i_pv6_redirect.html#a5b137567866a7f466420021270f2f865">getTargetLinkLayerAddress</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac6f2316e1a19d2816bab83e96d11ef57"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processRSPacket" ref="ac6f2316e1a19d2816bab83e96d11ef57" args="(IPv6RouterSolicitation *rs, IPv6ControlInfo *rsCtrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#ac6f2316e1a19d2816bab83e96d11ef57">IPv6NeighbourDiscovery::processRSPacket</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_router_solicitation.html">IPv6RouterSolicitation</a> *&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&#160;</td>
          <td class="paramname"><em>rsCtrlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a7662f293fab21a873bb22edab70de5ce">processNDMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a09f8b6d13b8546d9c3d735589df9e37f">validateRSPacket</a>(rs, rsCtrlInfo) == <span class="keyword">false</span>)
        <span class="keywordflow">return</span>;

    <span class="comment">//Find out which interface the RS message arrived on.</span>
    <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7" title="Returns an interface by its Id.">getInterfaceById</a>(rsCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a74046fa005d98f0c304eb39eb28a1ec3">getInterfaceId</a>());
    AdvIfEntry *advIfEntry = <a class="code" href="class_i_pv6_neighbour_discovery.html#a44d5adf445298a56e275377d70d620ef">fetchAdvIfEntry</a>(ie); <span class="comment">//fetch advertising interface entry.</span>

    <span class="comment">//RFC 2461: Section 6.2.6</span>
    <span class="comment">//A host MUST silently discard any received Router Solicitation messages.</span>
    <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ad25e520c7730fff1647b57ba206573ed">getAdvSendAdvertisements</a>())
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;This is an advertising interface, processing RS\n&quot;</span>;

        <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a09f8b6d13b8546d9c3d735589df9e37f">validateRSPacket</a>(rs, rsCtrlInfo) == <span class="keyword">false</span>)
            <span class="keywordflow">return</span>;

        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;RS message validated\n&quot;</span>;

        <span class="comment">//First we extract RS specific information from the received message</span>
        <a class="code" href="class_m_a_c_address.html" title="Stores an IEEE 802 MAC address (6 octets = 48 bits).">MACAddress</a> macAddr = rs-&gt;<a class="code" href="class_i_pv6_router_solicitation.html#ac27e5211d09ebbfe316b4c2b28e3a232">getSourceLinkLayerAddress</a>();
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;MAC Address extracted\n&quot;</span>;
        <span class="keyword">delete</span> rs;

        <span class="comment">/*A router MAY choose to unicast the response directly to the soliciting</span>
<span class="comment">        host&#39;s address (if the solicitation&#39;s source address is not the unspecified</span>
<span class="comment">        address), but the usual case is to multicast the response to the</span>
<span class="comment">        all-nodes group. In the latter case, the interface&#39;s interval timer is</span>
<span class="comment">        reset to a new random value, as if an unsolicited advertisement had just</span>
<span class="comment">        been sent(see Section 6.2.4).*/</span>

        <span class="comment">/*In all cases, Router Advertisements sent in response to a Router</span>
<span class="comment">        Solicitation MUST be delayed by a random time between 0 and</span>
<span class="comment">        MAX_RA_DELAY_TIME seconds. (If a single advertisement is sent in</span>
<span class="comment">        response to multiple solicitations, the delay is relative to the</span>
<span class="comment">        first solicitation.)  In addition, consecutive Router Advertisements</span>
<span class="comment">        sent to the all-nodes multicast address MUST be rate limited to no</span>
<span class="comment">        more than one advertisement every MIN_DELAY_BETWEEN_RAS seconds.*/</span>

        <span class="comment">/*A router might process Router Solicitations as follows:</span>
<span class="comment">        - Upon receipt of a Router Solicitation, compute a random delay</span>
<span class="comment">        within the range 0 through MAX_RA_DELAY_TIME. If the computed</span>
<span class="comment">        value corresponds to a time later than the time the next multicast</span>
<span class="comment">        Router Advertisement is scheduled to be sent, ignore the random</span>
<span class="comment">        delay and send the advertisement at the already-scheduled time.*/</span>
        cMessage *msg = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;sendSolicitedRA&quot;</span>, <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#ab76c2fe672ed307b0a91f9efa35a7548">MK_SEND_SOL_RTRADV</a>);
        msg-&gt;setContextPointer(ie);
        simtime_t interval = uniform(0, ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a17f373d78125432dfe421216b7e6eba6">_getMaxRADelayTime</a>());

        <span class="keywordflow">if</span> (interval &lt; advIfEntry-&gt;nextScheduledRATime)
        {
            simtime_t nextScheduledTime;
            nextScheduledTime = simTime()+interval;
            scheduleAt(nextScheduledTime, msg);
            advIfEntry-&gt;nextScheduledRATime = nextScheduledTime;
        }
        <span class="comment">//else we ignore the generate interval and send it at the next scheduled time.</span>

        <span class="comment">//We need to keep a log here each time an RA is sent. Not implemented yet.</span>
        <span class="comment">//Assume the first course of action.</span>
        <span class="comment">/*- If the router sent a multicast Router Advertisement (solicited or</span>
<span class="comment">        unsolicited) within the last MIN_DELAY_BETWEEN_RAS seconds,</span>
<span class="comment">        schedule the advertisement to be sent at a time corresponding to</span>
<span class="comment">        MIN_DELAY_BETWEEN_RAS plus the random value after the previous</span>
<span class="comment">        advertisement was sent. This ensures that the multicast Router</span>
<span class="comment">        Advertisements are rate limited.</span>
<span class="comment"></span>
<span class="comment">        - Otherwise, schedule the sending of a Router Advertisement at the</span>
<span class="comment">        time given by the random value.*/</span>
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;This interface is a host, discarding RA message\n&quot;</span>;
        <span class="keyword">delete</span> rs;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="abcd9999f935e23b593499f8d23a970bf"></a><!-- doxytag: member="IPv6NeighbourDiscovery::reachabilityConfirmed" ref="abcd9999f935e23b593499f8d23a970bf" args="(const IPv6Address &amp;neighbour, int interfaceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#abcd9999f935e23b593499f8d23a970bf">IPv6NeighbourDiscovery::reachabilityConfirmed</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>neighbour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interfaceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Public method, it can be invoked from the <a class="el" href="class_i_pv6.html" title="IPv6 implementation.">IPv6</a> module or any other module to let Neighbour Discovery know that the reachability of the given neighbor has just been confirmed (e.g. </p>
<p><a class="el" href="class_t_c_p.html" title="Implements the TCP protocol.">TCP</a> received ACK of new data from it). Neighbour Discovery can then update the neighbour cache with this information, and cancel the Neighbour Unreachability Detection procedure if it is currently running. </p>
<div class="fragment"><pre class="fragment">{
    Enter_Method(<span class="stringliteral">&quot;reachabilityConfirmed(%s,if=%d)&quot;</span>, neighbour.<a class="code" href="class_i_pv6_address.html#a7c42fb066db81588a439aed1de5e4b3a" title="Returns the textual representation of the address in the standard notation.">str</a>().c_str(), interfaceId);
    <span class="comment">//hmmm... this should only be invoked if a TCP ACK was received and NUD is</span>
    <span class="comment">//currently being performed on the neighbour where the TCP ACK was received from.</span>

    <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *nce = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#af88ebc30d5f18f0a628ead79f1fc3cb9" title="Returns a neighbour entry, or NULL.">lookup</a>(neighbour, interfaceId);

    cMessage *msg = nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a861411e349fda127a4b66659f155659f">nudTimeoutEvent</a>;
    <span class="keywordflow">if</span> (msg != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NUD in progress. Cancelling NUD Timer\n&quot;</span>;
        bubble(<span class="stringliteral">&quot;Reachability Confirmed via NUD.&quot;</span>);
        cancelAndDelete(msg);
        nce-&gt;nudTimeoutEvent = <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
    }

    <span class="comment">// TODO (see header file for description)</span>
    <span class="comment">/*A neighbor is considered reachable if the node has recently received</span>
<span class="comment">    a confirmation that packets sent recently to the neighbor were</span>
<span class="comment">    received by its IP layer.  Positive confirmation can be gathered in</span>
<span class="comment">    two ways: hints from upper layer protocols that indicate a connection</span>
<span class="comment">    is making &quot;forward progress&quot;, or receipt of a Neighbor Advertisement</span>
<span class="comment">    message that is a response to a Neighbor Solicitation message.</span>
<span class="comment"></span>
<span class="comment">    A connection makes &quot;forward progress&quot; if the packets received from a</span>
<span class="comment">    remote peer can only be arriving if recent packets sent to that peer</span>
<span class="comment">    are actually reaching it.  In TCP, for example, receipt of a (new)</span>
<span class="comment">    acknowledgement indicates that previously sent data reached the peer.</span>
<span class="comment">    Likewise, the arrival of new (non-duplicate) data indicates that</span>
<span class="comment"></span>
<span class="comment">    earlier acknowledgements are being delivered to the remote peer.  If</span>
<span class="comment">    packets are reaching the peer, they must also be reaching the</span>
<span class="comment">    sender&#39;s next-hop neighbor; thus &quot;forward progress&quot; is a confirmation</span>
<span class="comment">    that the next-hop neighbor is reachable.  For off-link destinations,</span>
<span class="comment">    forward progress implies that the first-hop router is reachable.</span>
<span class="comment">    When available, this upper-layer information SHOULD be used.</span>
<span class="comment"></span>
<span class="comment">    In some cases (e.g., UDP-based protocols and routers forwarding</span>
<span class="comment">    packets to hosts) such reachability information may not be readily</span>
<span class="comment">    available from upper-layer protocols.  When no hints are available</span>
<span class="comment">    and a node is sending packets to a neighbor, the node actively probes</span>
<span class="comment">    the neighbor using unicast Neighbor Solicitation messages to verify</span>
<span class="comment">    that the forward path is still working.</span>
<span class="comment"></span>
<span class="comment">    The receipt of a solicited Neighbor Advertisement serves as</span>
<span class="comment">    reachability confirmation, since advertisements with the Solicited</span>
<span class="comment">    flag set to one are sent only in response to a Neighbor Solicitation.</span>
<span class="comment">    Receipt of other Neighbor Discovery messages such as Router</span>
<span class="comment">    Advertisements and Neighbor Advertisement with the Solicited flag set</span>
<span class="comment">    to zero MUST NOT be treated as a reachability confirmation.  Receipt</span>
<span class="comment">    of unsolicited messages only confirm the one-way path from the sender</span>
<span class="comment">    to the recipient node.  In contrast, Neighbor Unreachability</span>
<span class="comment">    Detection requires that a node keep track of the reachability of the</span>
<span class="comment">    forward path to a neighbor from the its perspective, not the</span>
<span class="comment">    neighbor&#39;s perspective.  Note that receipt of a solicited</span>
<span class="comment">    advertisement indicates that a path is working in both directions.</span>
<span class="comment">    The solicitation must have reached the neighbor, prompting it to</span>
<span class="comment">    generate an advertisement.  Likewise, receipt of an advertisement</span>
<span class="comment">    indicates that the path from the sender to the recipient is working.</span>
<span class="comment">    However, the latter fact is known only to the recipient; the</span>
<span class="comment">    advertisement&#39;s sender has no direct way of knowing that the</span>
<span class="comment">    advertisement it sent actually reached a neighbor.  From the</span>
<span class="comment">    perspective of Neighbor Unreachability Detection, only the</span>
<span class="comment">    reachability of the forward path is of interest.*/</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="acd79bbeb030e0105e39d63cab1cee297"></a><!-- doxytag: member="IPv6NeighbourDiscovery::resetRATimer" ref="acd79bbeb030e0105e39d63cab1cee297" args="(InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#acd79bbeb030e0105e39d63cab1cee297">IPv6NeighbourDiscovery::resetRATimer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the given interface entry's Router Advertisement timer. </p>
<p>This is usually done when a router interface responds (by replying with a Router Advertisement sent to the All-Node multicast group)to a router solicitation Also see: RFC 2461, Section 6.2.6 </p>
<div class="fragment"><pre class="fragment">{<span class="comment">//Not used yet but could be useful later on.-WEI</span>
    <span class="comment">//Iterate through all RA timers within the Neighbour Discovery module.</span>
<span class="comment">/*</span>
<span class="comment">    for (RATimerList::iterator it=raTimerList.begin(); it != raTimerList.end(); it++)</span>
<span class="comment">    {</span>
<span class="comment">        cMessage *msg = (*it);</span>
<span class="comment">        InterfaceEntry *msgIE = (InterfaceEntry *)msg-&gt;getContextPointer();</span>
<span class="comment">        //Find the timer that matches the given Interface Entry.</span>
<span class="comment">        if (msgIE-&gt;outputPort() == ie-&gt;outputPort())</span>
<span class="comment">        {</span>
<span class="comment">            EV &lt;&lt; &quot;Resetting RA timer for port: &quot; &lt;&lt; ie-&gt;outputPort();</span>
<span class="comment">            cancelEvent(msg);//Cancel the next scheduled msg.</span>
<span class="comment">            simtime_t interval</span>
<span class="comment">                = uniform(ie-&gt;ipv6Data()-&gt;getMinRtrAdvInterval(),ie-&gt;ipv6Data()-&gt;getMaxRtrAdvInterval());</span>
<span class="comment">            scheduleAt(simTime()+interval, msg);</span>
<span class="comment">        }</span>
<span class="comment">    }</span>
<span class="comment">*/</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a567588762bff7af739e72916df55aebc"></a><!-- doxytag: member="IPv6NeighbourDiscovery::resolveNeighbour" ref="a567588762bff7af739e72916df55aebc" args="(const IPv6Address &amp;nextHop, int interfaceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_a_c_address.html">MACAddress</a> &amp; <a class="el" href="class_i_pv6_neighbour_discovery.html#a567588762bff7af739e72916df55aebc">IPv6NeighbourDiscovery::resolveNeighbour</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>nextHop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interfaceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Public method, to be invoked from the <a class="el" href="class_i_pv6.html" title="IPv6 implementation.">IPv6</a> module to determine link-layer address and the output interface of the next hop. </p>
<p>If the neighbor cache does not contain this address or it's in the state INCOMPLETE, this method will return the NULL address, and the <a class="el" href="class_i_pv6.html" title="IPv6 implementation.">IPv6</a> module should then send the datagram here to <a class="el" href="class_i_pv6_neighbour_discovery.html" title="Implements RFC 2461 Neighbor Discovery for IPv6.">IPv6NeighbourDiscovery</a> where it will be stored until neighbour resolution completes.</p>
<p>If the neighbour cache entry is STALE (or REACHABLE but more than reachableTime elapsed since reachability was last confirmed), the link-layer address is still returned and <a class="el" href="class_i_pv6.html" title="IPv6 implementation.">IPv6</a> can send the datagram, but simultaneously, this call should trigger the Neighbour Unreachability Detection procedure to start in the <a class="el" href="class_i_pv6_neighbour_discovery.html" title="Implements RFC 2461 Neighbor Discovery for IPv6.">IPv6NeighbourDiscovery</a> module. </p>

<p>Referenced by <a class="el" href="class_i_pv6.html#a33a99910431c17c57350ee894d9024e3">IPv6::routePacket()</a>.</p>
<div class="fragment"><pre class="fragment">{
    Enter_Method(<span class="stringliteral">&quot;resolveNeighbor(%s,if=%d)&quot;</span>, nextHop.<a class="code" href="class_i_pv6_address.html#a7c42fb066db81588a439aed1de5e4b3a" title="Returns the textual representation of the address in the standard notation.">str</a>().c_str(), interfaceId);

    <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *nce = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#af88ebc30d5f18f0a628ead79f1fc3cb9" title="Returns a neighbour entry, or NULL.">lookup</a>(nextHop, interfaceId);
    <span class="comment">//InterfaceEntry *ie = ift-&gt;getInterfaceById(interfaceId);</span>

    <span class="keywordflow">if</span> (!nce || nce-&gt;reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1ac2cfd6c9d21c7d34d2f6f53d6cfe6638">IPv6NeighbourCache::INCOMPLETE</a>)
        <span class="keywordflow">return</span> <a class="code" href="class_m_a_c_address.html#a9083fdb636ab09f77e7af806f2d471b6" title="The unspecified MAC address, 00:00:00:00:00:00.">MACAddress::UNSPECIFIED_ADDRESS</a>;

    <span class="keywordflow">if</span> (nce-&gt;reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a115199155dd43585124db1d8f471025b">IPv6NeighbourCache::STALE</a>)
    {
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a9f14cc2bfe0cce622308be4388b3b397">initiateNeighbourUnreachabilityDetection</a>(nce);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nce-&gt;reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a537cfe5cd6d576deab91b256b6da873a">IPv6NeighbourCache::REACHABLE</a> &amp;&amp;
            simTime() &gt; nce-&gt;reachabilityExpires)
    {
        nce-&gt;reachabilityState = <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a115199155dd43585124db1d8f471025b">IPv6NeighbourCache::STALE</a>;
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a9f14cc2bfe0cce622308be4388b3b397">initiateNeighbourUnreachabilityDetection</a>(nce);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nce-&gt;reachabilityState != <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a537cfe5cd6d576deab91b256b6da873a">IPv6NeighbourCache::REACHABLE</a>)
    {
        <span class="comment">//reachability state must be either in DELAY or PROBE</span>
        ASSERT(nce-&gt;reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a815cc3dd5d8b220495a69641b00f5bdb">IPv6NeighbourCache::DELAY</a> ||
               nce-&gt;reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a8fdd2d1853264aa8f5479ebfa6502054">IPv6NeighbourCache::PROBE</a>);
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NUD in progress.\n&quot;</span>;
    }

    <span class="comment">//else the entry is REACHABLE and no further action is required here.</span>
    <span class="keywordflow">return</span> nce-&gt;macAddress;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9f6c83de24b3e270c3843cc213b5250a"></a><!-- doxytag: member="IPv6NeighbourDiscovery::selectDefaultRouter" ref="a9f6c83de24b3e270c3843cc213b5250a" args="(int &amp;outIfID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_address.html">IPv6Address</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a9f6c83de24b3e270c3843cc213b5250a">IPv6NeighbourDiscovery::selectDefaultRouter</a> </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>outIfID</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a4bddad274cd8eb1472d37ddcd559c629">determineNextHop()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Selecting default router...\n&quot;</span>;
    <span class="comment">//draft-ietf-ipv6-2461bis-04.txt Section 6.3.6</span>
    <span class="comment">/*The algorithm for selecting a router depends in part on whether or not a</span>
<span class="comment">    router is known to be reachable. The exact details of how a node keeps track</span>
<span class="comment">    of a neighbor&#39;s reachability state are covered in Section 7.3.  The algorithm</span>
<span class="comment">    for selecting a default router is invoked during next-hop determination when</span>
<span class="comment">    no Destination Cache entry exists for an off-link destination or when</span>
<span class="comment">    communication through an existing router appears to be failing.  Under normal</span>
<span class="comment">    conditions, a router would be selected the first time traffic is sent to a</span>
<span class="comment">    destination, with subsequent traffic for that destination using the same router</span>
<span class="comment">    as indicated in the Destination Cache modulo any changes to the Destination</span>
<span class="comment">    Cache caused by Redirect messages.</span>
<span class="comment"></span>
<span class="comment">    The policy for selecting routers from the Default Router List is as</span>
<span class="comment">    follows:*/</span>

    <span class="comment">/*1) Routers that are reachable or probably reachable (i.e., in any state</span>
<span class="comment">    other than INCOMPLETE) SHOULD be preferred over routers whose reachability</span>
<span class="comment">    is unknown or suspect (i.e., in the INCOMPLETE state, or for which no Neighbor</span>
<span class="comment">    Cache entry exists). An implementation may choose to always return the same</span>
<span class="comment">    router or cycle through the router list in a round-robin fashion as long as</span>
<span class="comment">    it always returns a reachable or a probably reachable router when one is</span>
<span class="comment">    available.*/</span>
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a78b96883d134769d492bd3c4cd89d982">DefaultRouterList</a> &amp;defaultRouters = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#a949aafe89b2ced9a3cba25ec476473a3">getDefaultRouterList</a>();
    <span class="keywordflow">for</span> (DefaultRouterList::iterator it = defaultRouters.begin(); it != defaultRouters.end();)
    {
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> &amp;nce = *it;
        <span class="keywordflow">if</span> (simTime() &gt; nce.routerExpiryTime)
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Found an expired default router. Deleting entry...\n&quot;</span>;
            ++it;
            <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#a877bc367ca422baabc22199c5036df83" title="Deletes the given neighbour from the cache.">remove</a>(nce.nceKey-&gt;address, nce.nceKey-&gt;interfaceID);
            <span class="keywordflow">continue</span>;
        }
        <span class="keywordflow">if</span> (nce.reachabilityState != <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1ac2cfd6c9d21c7d34d2f6f53d6cfe6638">IPv6NeighbourCache::INCOMPLETE</a>)
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Found a probably reachable router in the default router list.\n&quot;</span>;
            defaultRouters.setHead(*nce.nextDefaultRouter);
            outIfID = nce.nceKey-&gt;interfaceID;
            <span class="keywordflow">return</span> nce.nceKey-&gt;address;
        }
        ++it;
    }

    <span class="comment">/*2) When no routers on the list are known to be reachable or probably</span>
<span class="comment">    reachable, routers SHOULD be selected in a round-robin fashion, so that</span>
<span class="comment">    subsequent requests for a default router do not return the same router until</span>
<span class="comment">    all other routers have been selected.</span>
<span class="comment"></span>
<span class="comment">    Cycling through the router list in this case ensures that all available</span>
<span class="comment">    routers are actively probed by the Neighbor Unreachability Detection algorithm.</span>
<span class="comment">    A request for a default router is made in conjunction with the sending of a</span>
<span class="comment">    packet to a router, and the selected router will be probed for reachability</span>
<span class="comment">    as a side effect.*/</span>
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *defaultRouter = defaultRouters.getHead();
    <span class="keywordflow">if</span> (defaultRouter != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Found a router in the neighbour cache (default router list).\n&quot;</span>;
        defaultRouters.setHead(*defaultRouter-&gt;nextDefaultRouter);
        outIfID = defaultRouter-&gt;nceKey-&gt;interfaceID;
        <span class="keywordflow">return</span> defaultRouter-&gt;nceKey-&gt;address;
    }

    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;No suitable routers found.\n&quot;</span>;
    outIfID = -1;
    <span class="keywordflow">return</span> <a class="code" href="class_i_pv6_address.html#a0c1e137cb3b1470ec6b8d9a95e03dbe5" title="The unspecified address.">IPv6Address::UNSPECIFIED_ADDRESS</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a58642b1dc383266b43abc6d6e4a74e5e"></a><!-- doxytag: member="IPv6NeighbourDiscovery::sendPacketToIPv6Module" ref="a58642b1dc383266b43abc6d6e4a74e5e" args="(cMessage *msg, const IPv6Address &amp;destAddr, const IPv6Address &amp;srcAddr, int interfaceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a58642b1dc383266b43abc6d6e4a74e5e">IPv6NeighbourDiscovery::sendPacketToIPv6Module</a> </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>destAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>srcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interfaceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create control info and assigns it to a msg. </p>
<p>Returns a copy of the msg with the control info. </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#aedad2b550812f9be54ab691296e5876d">createAndSendNSPacket()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a50d09a125fd3477828643875b72573ec">createAndSendRAPacket()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a75431d6a5076b17ae0630f2fc4aa441a">createAndSendRSPacket()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#ade69131623bc5b13205ced3ff54a16d3">processIPv6Datagram()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#ac2a5f2e2cbd6845ecd10038fce448ead">sendSolicitedNA()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#a30bc9cd2bec93e40e238fe91b573ca9f">sendUnsolicitedNA()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_i_pv6_control_info.html" title="Control information for sending/receiving packets over IPv6.">IPv6ControlInfo</a> *controlInfo = <span class="keyword">new</span> <a class="code" href="class_i_pv6_control_info.html" title="Control information for sending/receiving packets over IPv6.">IPv6ControlInfo</a>();
    controlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a95b27ccb8d018e7387cdbcd512791e30">setProtocol</a>(<a class="code" href="_i_p_protocol_id__m_8h.html#a4297c2f400ba53cf6866e6d45bc81b70a3f40fb193e9edf4e297fcd7952acb024">IP_PROT_IPv6_ICMP</a>);
    controlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a061a09229c1cb5c450e90fda062d278f">setDestAddr</a>(destAddr);
    controlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a319cf2aaec7229cc010ae83ab6e18604">setSrcAddr</a>(srcAddr);
    controlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a182f2489bf1cc08d0af6c2d04dff24e0">setHopLimit</a>(255);
    controlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#ac800b6ba75f90922ff85c73c30dee1ee">setInterfaceId</a>(interfaceId);
    msg-&gt;setControlInfo(controlInfo);

    send(msg, <span class="stringliteral">&quot;ipv6Out&quot;</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7ab6b1fc3d01da2bc31d772a31013e08"></a><!-- doxytag: member="IPv6NeighbourDiscovery::sendPeriodicRA" ref="a7ab6b1fc3d01da2bc31d772a31013e08" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a7ab6b1fc3d01da2bc31d772a31013e08">IPv6NeighbourDiscovery::sendPeriodicRA</a> </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#ad90a981569779940aaffe6df55b6285b">handleMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = (<a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *)msg-&gt;getContextPointer();
    AdvIfEntry *advIfEntry = <a class="code" href="class_i_pv6_neighbour_discovery.html#a44d5adf445298a56e275377d70d620ef">fetchAdvIfEntry</a>(ie);
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> destAddr = <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a>(<span class="stringliteral">&quot;FF02::1&quot;</span>);
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a50d09a125fd3477828643875b72573ec">createAndSendRAPacket</a>(destAddr, ie);
    advIfEntry-&gt;numRASent++;
    simtime_t nextScheduledTime;

    <span class="comment">//RFC 2461, Section 6.2.4</span>
    <span class="comment">/*Whenever a multicast advertisement is sent from an interface, the timer is</span>
<span class="comment">    reset to a uniformly-distributed random value between the interface&#39;s</span>
<span class="comment">    configured MinRtrAdvInterval and MaxRtrAdvInterval; expiration of the timer</span>
<span class="comment">    causes the next advertisement to be sent and a new random value to be chosen.*/</span>

    simtime_t interval;

<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;\n+=+=+= MIPv6 Feature: &quot;</span> &lt;&lt; <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;hasMIPv6Support() &lt;&lt; <span class="stringliteral">&quot; +=+=+=\n&quot;</span>;
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

    interval = uniform(ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a9ef09c4f701d015e4c99229fbcde0694">getMinRtrAdvInterval</a>(), ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a31355ab369205f9fa820c873a8088b81">getMaxRtrAdvInterval</a>());

<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;\n +=+=+= The random calculated interval is: &quot;</span> &lt;&lt; interval &lt;&lt; <span class="stringliteral">&quot; +=+=+=\n&quot;</span>;
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

    nextScheduledTime = simTime() + interval;

    <span class="comment">/*For the first few advertisements (up to MAX_INITIAL_RTR_ADVERTISEMENTS)</span>
<span class="comment">    sent from an interface when it becomes an advertising interface,*/</span>
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Num RA sent is: &quot;</span> &lt;&lt; advIfEntry-&gt;numRASent &lt;&lt; endl;
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;maxInitialRtrAdvertisements is: &quot;</span> &lt;&lt; ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a87fe88b5fa1adcacfa5e02f331ebedf2">_getMaxInitialRtrAdvertisements</a>() &lt;&lt; endl;

    <span class="keywordflow">if</span> (advIfEntry-&gt;numRASent &lt;= ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a87fe88b5fa1adcacfa5e02f331ebedf2">_getMaxInitialRtrAdvertisements</a>())
    {
        <span class="keywordflow">if</span> (interval &gt; ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#aa6cf4063fb219732b4dbdddd5034266d" title="Getters/Setters for all variables and constants defined in RFC 2461/2462 can be found here...">_getMaxInitialRtrAdvertInterval</a>())
        {
            <span class="comment">//if the randomly chosen interval is greater than MAX_INITIAL_RTR_ADVERT_INTERVAL,</span>
            <span class="comment">//the timer SHOULD be set to MAX_INITIAL_RTR_ADVERT_INTERVAL instead.</span>
            nextScheduledTime = simTime() + ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#aa6cf4063fb219732b4dbdddd5034266d" title="Getters/Setters for all variables and constants defined in RFC 2461/2462 can be found here...">_getMaxInitialRtrAdvertInterval</a>();
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Sending initial RA but interval is too long. Using default value.&quot;</span> &lt;&lt; endl;
        }
        <span class="keywordflow">else</span>
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Sending initial RA. Using randomly generated interval.&quot;</span> &lt;&lt; endl;
    }

    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Next scheduled time: &quot;</span> &lt;&lt; nextScheduledTime &lt;&lt; endl;
    advIfEntry-&gt;nextScheduledRATime = nextScheduledTime;
    ASSERT(nextScheduledTime &gt; simTime());
    scheduleAt(nextScheduledTime, msg);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6cc2bafedafa13f79df2410b6617ff4b"></a><!-- doxytag: member="IPv6NeighbourDiscovery::sendQueuedPacketsToIPv6Module" ref="a6cc2bafedafa13f79df2410b6617ff4b" args="(Neighbour *nce)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a6cc2bafedafa13f79df2410b6617ff4b">IPv6NeighbourDiscovery::sendQueuedPacketsToIPv6Module</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *&#160;</td>
          <td class="paramname"><em>nce</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send off any queued packets within the Neighbour Discovery module awaiting address resolution. </p>
<p>Not used yet-unsure if we really need it.</p>
<p>--DELETED, Andras </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a093219842e9055dc413f8f6d401001ee">processNAForIncompleteNCEState()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a0e2372b38f3787dd836bcee6b77eb268">MsgPtrVector</a>&amp; pendingPackets = nce-&gt;pendingPackets;

    <span class="keywordflow">while</span> (!pendingPackets.empty())<span class="comment">//FIXME: pendingPackets are always empty!!!!</span>
    {
        MsgPtrVector::iterator i = pendingPackets.begin();
        cMessage *msg = (*i);
        pendingPackets.erase(i);
        <a class="code" href="class_i_pv6_neighbour_discovery.html#a8cebccf199f96d0903c4663b203199ca">pendingQueue</a>.remove(msg);
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Sending queued packet &quot;</span> &lt;&lt; msg &lt;&lt; endl;
        send(msg, <span class="stringliteral">&quot;ipv6Out&quot;</span>);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac2a5f2e2cbd6845ecd10038fce448ead"></a><!-- doxytag: member="IPv6NeighbourDiscovery::sendSolicitedNA" ref="ac2a5f2e2cbd6845ecd10038fce448ead" args="(IPv6NeighbourSolicitation *ns, IPv6ControlInfo *nsCtrlInfo, InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#ac2a5f2e2cbd6845ecd10038fce448ead">IPv6NeighbourDiscovery::sendSolicitedNA</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&#160;</td>
          <td class="paramname"><em>nsCtrlInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#abccb93f2300252252370c5cfab5017c6">processNSForNonTentativeAddress()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#a8106a5866c58a9c6372c741a15ce943b">processNSWithSpecifiedSrcAddr()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_i_pv6_neighbour_advertisement.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6NeighbourAdvertisement</a> *na = <span class="keyword">new</span> <a class="code" href="class_i_pv6_neighbour_advertisement.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6NeighbourAdvertisement</a>(<span class="stringliteral">&quot;NApacket&quot;</span>);
    <span class="comment">//RFC 2461: Section 7.2.4</span>
    <span class="comment">/*A node sends a Neighbor Advertisement in response to a valid Neighbor</span>
<span class="comment">    Solicitation targeting one of the node&#39;s assigned addresses.  The</span>
<span class="comment">    Target Address of the advertisement is copied from the Target Address</span>
<span class="comment">    of the solicitation.*/</span>
    na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a4dbf28ee1af4a9c9c61f25d078ce66e4">setTargetAddress</a>(ns-&gt;<a class="code" href="class_i_pv6_neighbour_solicitation.html#aa8758b1539001a247c925ead4856ec69">getTargetAddress</a>());

    <span class="comment">/*If the solicitation&#39;s IP Destination Address is not a multicast address,</span>
<span class="comment">    the Target Link-Layer Address option MAY be omitted; the neighboring node&#39;s</span>
<span class="comment">    cached value must already be current in order for the solicitation to have</span>
<span class="comment">    been received. If the solicitation&#39;s IP Destination Address is a multicast</span>
<span class="comment">    address, the Target Link-Layer option MUST be included in the advertisement.*/</span>
    na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#ad43f296481e28e422b8d0e78b9a19c79">setTargetLinkLayerAddress</a>(ie-&gt;<a class="code" href="class_interface_entry.html#af8004a12e9aac171699ff1f7f08ee4c4">getMacAddress</a>()); <span class="comment">//here, we always include the MAC addr.</span>

    <span class="comment">/*Furthermore, if the node is a router, it MUST set the Router flag to one;</span>
<span class="comment">    otherwise it MUST set the flag to zero.*/</span>
    na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a8101b8ec549618915982e7601c0f8c49">setRouterFlag</a>(<a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#a79a742fa2d94543412e183ebe0e83d3a" title="IP forwarding on/off.">isRouter</a>());

    <span class="comment">/*If the (NS)Target Address is either an anycast address or a unicast</span>
<span class="comment">    address for which the node is providing proxy service, or the Target</span>
<span class="comment">    Link-Layer Address option is not included,*/</span>
    <span class="comment">//TODO:ANYCAST will not be implemented here!</span>

    <span class="keywordflow">if</span> (ns-&gt;<a class="code" href="class_i_pv6_neighbour_solicitation.html#ade4c8874a206e1696e204264db63d415">getSourceLinkLayerAddress</a>().<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107" title="Returns true if all address bytes are zero.">isUnspecified</a>())
        <span class="comment">//the Override flag SHOULD be set to zero.</span>
        na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#ae13ff28ccd2a9c41661295e28940a95e">setOverrideFlag</a>(<span class="keyword">false</span>);
    <span class="keywordflow">else</span>
        <span class="comment">//Otherwise, the Override flag SHOULD be set to one.</span>
        na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#ae13ff28ccd2a9c41661295e28940a95e">setOverrideFlag</a>(<span class="keyword">true</span>);

    <span class="comment">/*Proper setting of the Override flag ensures that nodes give preference to</span>
<span class="comment">    non-proxy advertisements, even when received after proxy advertisements, and</span>
<span class="comment">    also ensures that the first advertisement for an anycast address &quot;wins&quot;.*/</span>

    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> naDestAddr;
    <span class="comment">//If the source of the solicitation is the unspecified address,</span>
    <span class="keywordflow">if</span> (nsCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a8980bdcd6051ae3fe071bf2c18a0215e">getSrcAddr</a>().<a class="code" href="class_i_pv6_address.html#af526cffcc3a4aa5bb96d307de6e8d448" title="Check if the IPv6 Address is undefined.">isUnspecified</a>())
    {
        <span class="comment">/*the node MUST set the Solicited flag to zero and multicast the advertisement</span>
<span class="comment">        to the all-nodes address.*/</span>
        na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a23026a5eb96daf912cde5c6c90c0cf20">setSolicitedFlag</a>(<span class="keyword">false</span>);
        naDestAddr = <a class="code" href="class_i_pv6_address.html#af71ff608917fe0fc14baf50d11815aeb" title="All-nodes multicast address, scope 2 (link-local)">IPv6Address::ALL_NODES_2</a>;
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">/*Otherwise, the node MUST set the Solicited flag to one and unicast</span>
<span class="comment">        the advertisement to the Source Address of the solicitation.*/</span>
        na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a23026a5eb96daf912cde5c6c90c0cf20">setSolicitedFlag</a>(<span class="keyword">true</span>);
        naDestAddr = nsCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a8980bdcd6051ae3fe071bf2c18a0215e">getSrcAddr</a>();
    }

    <span class="comment">/*If the Target Address is an anycast address the sender SHOULD delay sending</span>
<span class="comment">    a response for a random time between 0 and MAX_ANYCAST_DELAY_TIME seconds.*/</span>
    <span class="comment">/*TODO: More associated complexity for this one. We will have to delay</span>
<span class="comment">    sending off the solicitation. Perhaps the self message could have a context</span>
<span class="comment">    pointer pointing to a struct with enough info to create and send a NA packet.*/</span>

    <span class="comment">/*Because unicast Neighbor Solicitations are not required to include a</span>
<span class="comment">    Source Link-Layer Address, it is possible that a node sending a</span>
<span class="comment">    solicited Neighbor Advertisement does not have a corresponding link-</span>
<span class="comment">    layer address for its neighbor in its Neighbor Cache.  In such</span>
<span class="comment">    situations, a node will first have to use Neighbor Discovery to</span>
<span class="comment">    determine the link-layer address of its neighbor (i.e, send out a</span>
<span class="comment">    multicast Neighbor Solicitation).*/</span>
    <span class="comment">//TODO: if above mentioned happens, can addr resolution be performed for ND messages?</span>
    <span class="comment">//if no link-layer addr exists for unicast addr when sending solicited NA, we should</span>
    <span class="comment">//add the NA to the list of queued packets. What if we have a list of queued</span>
    <span class="comment">//packets for different unicast solicitations? each time addr resolution is</span>
    <span class="comment">//done we should check the destinations of the list of queued packets and send</span>
    <span class="comment">//off the respective ones.</span>
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> myIPv6Addr = ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a56f3fe4007e3df66dc88edd008f059b9" title="Chooses a preferred address for the interface and returns it.">getPreferredAddress</a>();
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a58642b1dc383266b43abc6d6e4a74e5e" title="Create control info and assigns it to a msg.">sendPacketToIPv6Module</a>(na, naDestAddr, myIPv6Addr, ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>());
}
</pre></div>
</div>
</div>
<a class="anchor" id="a32ed95da45989efe4509946492299d34"></a><!-- doxytag: member="IPv6NeighbourDiscovery::sendSolicitedRA" ref="a32ed95da45989efe4509946492299d34" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a32ed95da45989efe4509946492299d34">IPv6NeighbourDiscovery::sendSolicitedRA</a> </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#ad90a981569779940aaffe6df55b6285b">handleMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Send Solicited RA invoked!\n&quot;</span>;
    <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = (<a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *)msg-&gt;getContextPointer();
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> destAddr = <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a>(<span class="stringliteral">&quot;FF02::1&quot;</span>);
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Testing condition!\n&quot;</span>;
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a50d09a125fd3477828643875b72573ec">createAndSendRAPacket</a>(destAddr, ie);
    <span class="keyword">delete</span> msg;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a30bc9cd2bec93e40e238fe91b573ca9f"></a><!-- doxytag: member="IPv6NeighbourDiscovery::sendUnsolicitedNA" ref="a30bc9cd2bec93e40e238fe91b573ca9f" args="(InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a30bc9cd2bec93e40e238fe91b573ca9f">IPv6NeighbourDiscovery::sendUnsolicitedNA</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="classx_m_i_pv6.html#a9ffb963794e347fcf4112e95ad920405">xMIPv6::processBAMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//RFC 2461</span>
    <span class="comment">//Section 7.2.6: Sending Unsolicited Neighbor Advertisements</span>
<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>    Enter_Method_Silent();
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

<span class="preprocessor">#ifndef WITH_xMIPv6</span>
<span class="preprocessor"></span>    <span class="comment">// In some cases a node may be able to determine that its link-layer</span>
    <span class="comment">// address has changed (e.g., hot-swap of an interface card) and may</span>
    <span class="comment">// wish to inform its neighbors of the new link-layer address quickly.</span>
    <span class="comment">// In such cases a node MAY send up to MAX_NEIGHBOR_ADVERTISEMENT</span>
    <span class="comment">// unsolicited Neighbor Advertisement messages to the all-nodes</span>
    <span class="comment">// multicast address.  These advertisements MUST be separated by at</span>
    <span class="comment">// least RetransTimer seconds.</span>
<span class="preprocessor">#else </span><span class="comment">/* WITH_xMIPv6 */</span>
    <a class="code" href="class_i_pv6_neighbour_advertisement.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6NeighbourAdvertisement</a> *na = <span class="keyword">new</span> <a class="code" href="class_i_pv6_neighbour_advertisement.html" title="Class generated from networklayer/icmpv6/IPv6NDMessage.msg by opp_msgc.">IPv6NeighbourAdvertisement</a>(<span class="stringliteral">&quot;NApacket&quot;</span>);
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> myIPv6Addr = ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a56f3fe4007e3df66dc88edd008f059b9" title="Chooses a preferred address for the interface and returns it.">getPreferredAddress</a>();
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

    <span class="comment">// The Target Address field in the unsolicited advertisement is set to</span>
    <span class="comment">// an IP address of the interface, and the Target Link-Layer Address</span>
    <span class="comment">// option is filled with the new link-layer address.</span>
<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>    na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a4dbf28ee1af4a9c9c61f25d078ce66e4">setTargetAddress</a>(myIPv6Addr);
    na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#ad43f296481e28e422b8d0e78b9a19c79">setTargetLinkLayerAddress</a>( ie-&gt;<a class="code" href="class_interface_entry.html#af8004a12e9aac171699ff1f7f08ee4c4">getMacAddress</a>() );
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

    <span class="comment">// The Solicited flag MUST be set to zero, in order to avoid confusing</span>
    <span class="comment">// the Neighbor Unreachability Detection algorithm.</span>
<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>    na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a23026a5eb96daf912cde5c6c90c0cf20">setSolicitedFlag</a>(<span class="keyword">false</span>);
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

    <span class="comment">// If the node is a router, it MUST set the Router flag to one;</span>
    <span class="comment">// otherwise it MUST set it to zero.</span>
<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>    na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a8101b8ec549618915982e7601c0f8c49">setRouterFlag</a>( <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#a79a742fa2d94543412e183ebe0e83d3a" title="IP forwarding on/off.">isRouter</a>() );
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

    <span class="comment">// The Override flag MAY be set to either zero or one.  In either case,</span>
    <span class="comment">// neighboring nodes will immediately change the state of their Neighbor</span>
    <span class="comment">// Cache entries for the Target Address to STALE, prompting them to</span>
    <span class="comment">// verify the path for reachability.  If the Override flag is set to</span>
    <span class="comment">// one, neighboring nodes will install the new link-layer address in</span>
    <span class="comment">// their caches.  Otherwise, they will ignore the new link-layer</span>
    <span class="comment">// address, choosing instead to probe the cached address.</span>
<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>    na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#ae13ff28ccd2a9c41661295e28940a95e">setOverrideFlag</a>(<span class="keyword">true</span>);
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

    <span class="comment">// A node that has multiple IP addresses assigned to an interface MAY</span>
    <span class="comment">// multicast a separate Neighbor Advertisement for each address.  In</span>
    <span class="comment">// such a case the node SHOULD introduce a small delay between the</span>
    <span class="comment">// sending of each advertisement to reduce the probability of the</span>
    <span class="comment">// advertisements being lost due to congestion.</span>

    <span class="comment">// A proxy MAY multicast Neighbor Advertisements when its link-layer</span>
    <span class="comment">// address changes or when it is configured (by system management or</span>
    <span class="comment">// other mechanisms) to proxy for an address.  If there are multiple</span>
    <span class="comment">// nodes that are providing proxy services for the same set of addresses</span>
    <span class="comment">// the proxies SHOULD provide a mechanism that prevents multiple proxies</span>
    <span class="comment">// from multicasting advertisements for any one address, in order to</span>
    <span class="comment">// reduce the risk of excessive multicast traffic.</span>

    <span class="comment">// Also, a node belonging to an anycast address MAY multicast</span>
    <span class="comment">// unsolicited Neighbor Advertisements for the anycast address when the</span>
    <span class="comment">// node&#39;s link-layer address changes.</span>

    <span class="comment">// Note that because unsolicited Neighbor Advertisements do not reliably</span>
    <span class="comment">// update caches in all nodes (the advertisements might not be received</span>
    <span class="comment">// by all nodes), they should only be viewed as a performance</span>
    <span class="comment">// optimization to quickly update the caches in most neighbors.  The</span>
    <span class="comment">// Neighbor Unreachability Detection algorithm ensures that all nodes</span>
    <span class="comment">// obtain a reachable link-layer address, though the delay may be</span>
    <span class="comment">// slightly longer.</span>
<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>    <a class="code" href="class_i_pv6_neighbour_discovery.html#a58642b1dc383266b43abc6d6e4a74e5e" title="Create control info and assigns it to a msg.">sendPacketToIPv6Module</a>(na, <a class="code" href="class_i_pv6_address.html#af71ff608917fe0fc14baf50d11815aeb" title="All-nodes multicast address, scope 2 (link-local)">IPv6Address::ALL_NODES_2</a>, myIPv6Addr, ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>());
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a303391440ad2004ff69cfc5e4cf7504a"></a><!-- doxytag: member="IPv6NeighbourDiscovery::timeoutDefaultRouter" ref="a303391440ad2004ff69cfc5e4cf7504a" args="(const IPv6Address &amp;addr, int interfaceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a303391440ad2004ff69cfc5e4cf7504a">IPv6NeighbourDiscovery::timeoutDefaultRouter</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interfaceID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>RFC 2461: Section 6.3.5 Whenever the Lifetime of an entry in the Default Router List expires, that entry is discarded. </p>
<p>When removing a router from the Default Router list, the node MUST update the Destination Cache in such a way that all entries using the router perform next-hop determination again rather than continue sending traffic to the (deleted) router. </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a41da6658d387e46e3e656d4704bf908f">processRAForRouterUpdates()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//RFC 2461: Section 6.3.5</span>
    <span class="comment">/*Whenever the Lifetime of an entry in the Default Router List expires,</span>
<span class="comment">    that entry is discarded.*/</span>
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#a877bc367ca422baabc22199c5036df83" title="Deletes the given neighbour from the cache.">remove</a>(addr, interfaceID);

    <span class="comment">/*When removing a router from the Default Router list, the node MUST update</span>
<span class="comment">    the Destination Cache in such a way that all entries using the router perform</span>
<span class="comment">    next-hop determination again rather than continue sending traffic to the</span>
<span class="comment">    (deleted) router.*/</span>
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#a1b4f1c86d678de8ac3f873ac7de0687f" title="Discard all entries in destination cache where next hop is the given address on the given interface...">purgeDestCacheEntriesToNeighbour</a>(addr, interfaceID);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0e59b5c2995f7bdec6b6a67e60a1e675"></a><!-- doxytag: member="IPv6NeighbourDiscovery::timeoutPrefixEntry" ref="a0e59b5c2995f7bdec6b6a67e60a1e675" args="(const IPv6Address &amp;destPrefix, int prefixLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a0e59b5c2995f7bdec6b6a67e60a1e675">IPv6NeighbourDiscovery::timeoutPrefixEntry</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>destPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prefixLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>RFC 2461: Section 6.3.5 Whenever the invalidation timer expires for a Prefix List entry, that entry is discarded. </p>
<p>No existing Destination Cache entries need be updated, however. Should a reachability problem arise with an existing Neighbor Cache entry, Neighbor Unreachability Detection will perform any needed recovery. </p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//RFC 2461: Section 6.3.5</span>
    <span class="comment">/*Whenever the invalidation timer expires for a Prefix List entry, that</span>
<span class="comment">    entry is discarded.*/</span>
    <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#a85e00922381c188efc0ad51197e5f718" title="Remove an on-link prefix.">removeOnLinkPrefix</a>(destPrefix, prefixLength);
    <span class="comment">//hmmm... should the unicast address associated with this prefix be deleted</span>
    <span class="comment">//as well?-TODO: The address should be timeout/deleted as well!!</span>

    <span class="comment">/*No existing Destination Cache entries need be updated, however. Should a</span>
<span class="comment">    reachability problem arise with an existing Neighbor Cache entry, Neighbor</span>
<span class="comment">    Unreachability Detection will perform any needed recovery.*/</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8f18a6e238820911ee6253f12b766fad"></a><!-- doxytag: member="IPv6NeighbourDiscovery::validateNAPacket" ref="a8f18a6e238820911ee6253f12b766fad" args="(IPv6NeighbourAdvertisement *na, IPv6ControlInfo *naCtrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_i_pv6_neighbour_discovery.html#a8f18a6e238820911ee6253f12b766fad">IPv6NeighbourDiscovery::validateNAPacket</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *&#160;</td>
          <td class="paramname"><em>na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&#160;</td>
          <td class="paramname"><em>naCtrlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a348ba5dd9e93f4640d465a74b8a73d53">processNAPacket()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> result = <span class="keyword">true</span>; <span class="comment">//adopt optimistic approach</span>

    <span class="comment">//RFC 2461:7.1.2 Validation of Neighbor Advertisments(some checks are omitted)</span>
    <span class="comment">//A node MUST silently discard any received Neighbor Advertisment messages</span>
    <span class="comment">//that do not satisfy all of the following validity checks:</span>

    <span class="comment">//- The IP Hop Limit field has a value of 255, i.e., the packet</span>
    <span class="comment">//  could not possibly have been forwarded by a router.</span>
    <span class="keywordflow">if</span> (naCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a2eea197980c0c35518b3285ab9c123da">getHopLimit</a>() != 255)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Hop Limit is not 255! NA validation failed!\n&quot;</span>;
        result = <span class="keyword">false</span>;
    }

    <span class="comment">//- Target Address is not a multicast address.</span>
    <span class="keywordflow">if</span> (na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#ab4ced614f69b3cf120dbb835fbd7c11b">getTargetAddress</a>().<a class="code" href="class_i_pv6_address.html#a3c3bb6898821e044b12cf31911c90201" title="Utility function based on getScope()">isMulticast</a>() == <span class="keyword">true</span>)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Target Address is a multicast address! NA validation failed!\n&quot;</span>;
        result = <span class="keyword">false</span>;
    }

    <span class="comment">//- If the IP Destination Address is a multicast address the Solicited flag</span>
    <span class="comment">//  is zero.</span>
    <span class="keywordflow">if</span> (naCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#abd1d2c1cca62a40e351304d8584b4fd7">getDestAddr</a>().<a class="code" href="class_i_pv6_address.html#a3c3bb6898821e044b12cf31911c90201" title="Utility function based on getScope()">isMulticast</a>())
    {
        <span class="keywordflow">if</span> (na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a930381145de395cf787734ae40ea7361">getSolicitedFlag</a>() == <span class="keyword">true</span>)
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Dest Address is multicast address but solicted flag is 0!\n&quot;</span>;
            result = <span class="keyword">false</span>;
        }
    }

    <span class="keywordflow">if</span> (result == <span class="keyword">true</span>)
        bubble(<span class="stringliteral">&quot;NA validation passed.&quot;</span>);
    <span class="keywordflow">else</span>
        bubble(<span class="stringliteral">&quot;NA validation failed.&quot;</span>);

    <span class="keywordflow">return</span> result;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a72d9ee3401361c560c47f5172c05c1a4"></a><!-- doxytag: member="IPv6NeighbourDiscovery::validateNSPacket" ref="a72d9ee3401361c560c47f5172c05c1a4" args="(IPv6NeighbourSolicitation *ns, IPv6ControlInfo *nsCtrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_i_pv6_neighbour_discovery.html#a72d9ee3401361c560c47f5172c05c1a4">IPv6NeighbourDiscovery::validateNSPacket</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&#160;</td>
          <td class="paramname"><em>nsCtrlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a8d7676502f17ed01eb095afadab7bb33">processNSPacket()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> result = <span class="keyword">true</span>;

    <span class="comment">/*RFC 2461:7.1.1. Validation of Neighbor Solicitations(some checks are omitted)</span>
<span class="comment">    A node MUST silently discard any received Neighbor Solicitation</span>
<span class="comment">    messages that do not satisfy all of the following validity checks:*/</span>
    <span class="comment">//- The IP Hop Limit field has a value of 255, i.e., the packet</span>
    <span class="comment">//could not possibly have been forwarded by a router.</span>
    <span class="keywordflow">if</span> (nsCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a2eea197980c0c35518b3285ab9c123da">getHopLimit</a>() != 255)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Hop limit is not 255! NS validation failed!\n&quot;</span>;
        result = <span class="keyword">false</span>;
    }

    <span class="comment">//- Target Address is not a multicast address.</span>
    <span class="keywordflow">if</span> (ns-&gt;<a class="code" href="class_i_pv6_neighbour_solicitation.html#aa8758b1539001a247c925ead4856ec69">getTargetAddress</a>().<a class="code" href="class_i_pv6_address.html#a3c3bb6898821e044b12cf31911c90201" title="Utility function based on getScope()">isMulticast</a>() == <span class="keyword">true</span>)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Target address is a multicast address! NS validation failed!\n&quot;</span>;
        result = <span class="keyword">false</span>;
    }

    <span class="comment">//- If the IP source address is the unspecified address,</span>
    <span class="keywordflow">if</span> (nsCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a8980bdcd6051ae3fe071bf2c18a0215e">getSrcAddr</a>().<a class="code" href="class_i_pv6_address.html#af526cffcc3a4aa5bb96d307de6e8d448" title="Check if the IPv6 Address is undefined.">isUnspecified</a>())
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Source Address is unspecified\n&quot;</span>;

        <span class="comment">//the IP destination address is a solicited-node multicast address.</span>
        <span class="keywordflow">if</span> (nsCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#abd1d2c1cca62a40e351304d8584b4fd7">getDestAddr</a>().<a class="code" href="class_i_pv6_address.html#a4d9102b52fcf98d1945c75a098bc678a" title="Returns true if the address matches the given prefix.">matches</a>(<a class="code" href="class_i_pv6_address.html#a05683ca5f1a158a96c9a319314cb47bd" title="The solicited-node multicast address prefix (prefix length = 104)">IPv6Address::SOLICITED_NODE_PREFIX</a>, 104) == <span class="keyword">false</span>)
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot; but IP dest address is not a solicited-node multicast address! NS validation failed!\n&quot;</span>;
            result = <span class="keyword">false</span>;
        }
        <span class="comment">//there is no source link-layer address option in the message.</span>
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ns-&gt;<a class="code" href="class_i_pv6_neighbour_solicitation.html#ade4c8874a206e1696e204264db63d415">getSourceLinkLayerAddress</a>().<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107" title="Returns true if all address bytes are zero.">isUnspecified</a>() == <span class="keyword">false</span>)
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot; but Source link-layer address is not empty! NS validation failed!\n&quot;</span>;
            result = <span class="keyword">false</span>;
        }
        <span class="keywordflow">else</span>
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NS Validation Passed\n&quot;</span>;
    }

    <span class="keywordflow">return</span> result;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a902261563ea0bd130700a148a062781c"></a><!-- doxytag: member="IPv6NeighbourDiscovery::validateRAPacket" ref="a902261563ea0bd130700a148a062781c" args="(IPv6RouterAdvertisement *ra, IPv6ControlInfo *raCtrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_i_pv6_neighbour_discovery.html#a902261563ea0bd130700a148a062781c">IPv6NeighbourDiscovery::validateRAPacket</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *&#160;</td>
          <td class="paramname"><em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&#160;</td>
          <td class="paramname"><em>raCtrlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a4482770f35807ddc238a9259e85752e3">processRAPacket()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> result = <span class="keyword">true</span>;

    <span class="comment">//RFC 2461: Section 6.1.2 Validation of Router Advertisement Messages</span>
    <span class="comment">/*A node MUST silently discard any received Router Advertisement</span>
<span class="comment">    messages that do not satisfy all of the following validity checks:*/</span>
    raCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a8980bdcd6051ae3fe071bf2c18a0215e">getSrcAddr</a>();

    <span class="comment">//- IP Source Address is a link-local address.  Routers must use</span>
    <span class="comment">//  their link-local address as the source for Router Advertisement</span>
    <span class="comment">//  and Redirect messages so that hosts can uniquely identify</span>
    <span class="comment">//  routers.</span>
    <span class="keywordflow">if</span> (raCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a8980bdcd6051ae3fe071bf2c18a0215e">getSrcAddr</a>().<a class="code" href="class_i_pv6_address.html#a304edc5014ff3c991ae531aca21d2260" title="Utility function based on getScope()">isLinkLocal</a>() == <span class="keyword">false</span>)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;RA source address is not link-local. RA validation failed!\n&quot;</span>;
        result = <span class="keyword">false</span>;
    }

    <span class="comment">//- The IP Hop Limit field has a value of 255, i.e., the packet</span>
    <span class="comment">//  could not possibly have been forwarded by a router.</span>
    <span class="keywordflow">if</span> (raCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a2eea197980c0c35518b3285ab9c123da">getHopLimit</a>() != 255)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Hop limit is not 255! RA validation failed!\n&quot;</span>;
        result = <span class="keyword">false</span>;
    }

    <span class="comment">//- ICMP Code is 0.</span>
    <span class="keywordflow">if</span> (raCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a6ddd9db30da22159c80f34a5512f9833">getProtocol</a>() != <a class="code" href="_i_p_protocol_id__m_8h.html#a4297c2f400ba53cf6866e6d45bc81b70a3f40fb193e9edf4e297fcd7952acb024">IP_PROT_IPv6_ICMP</a>)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;ICMP Code is not 0! RA validation failed!\n&quot;</span>;
        result = <span class="keyword">false</span>;
    }

<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>    <span class="comment">// - All included options have a length that is greater than zero.</span>
    <span class="comment">// CB</span>
    <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a5189c47459ce2df26c6067b00bf6a670">getPrefixInformationArraySize</a>() == 0)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;No prefix information available! RA validation failed\n&quot;</span>;
        result = <span class="keyword">false</span>;
    }
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

    <span class="keywordflow">return</span> result;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a09f8b6d13b8546d9c3d735589df9e37f"></a><!-- doxytag: member="IPv6NeighbourDiscovery::validateRSPacket" ref="a09f8b6d13b8546d9c3d735589df9e37f" args="(IPv6RouterSolicitation *rs, IPv6ControlInfo *rsCtrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_i_pv6_neighbour_discovery.html#a09f8b6d13b8546d9c3d735589df9e37f">IPv6NeighbourDiscovery::validateRSPacket</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_router_solicitation.html">IPv6RouterSolicitation</a> *&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&#160;</td>
          <td class="paramname"><em>rsCtrlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#ac6f2316e1a19d2816bab83e96d11ef57">processRSPacket()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> result = <span class="keyword">true</span>;
    <span class="comment">/*6.1.1.  Validation of Router Solicitation Messages</span>
<span class="comment">    A router MUST silently discard any received Router Solicitation</span>
<span class="comment">    messages that do not satisfy all of the following validity checks:</span>
<span class="comment"></span>
<span class="comment">    - The IP Hop Limit field has a value of 255, i.e., the packet</span>
<span class="comment">    could not possibly have been forwarded by a router.*/</span>
    <span class="keywordflow">if</span> (rsCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a2eea197980c0c35518b3285ab9c123da">getHopLimit</a>() != 255)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Hop limit is not 255! RS validation failed!\n&quot;</span>;
        result = <span class="keyword">false</span>;
    }

    <span class="comment">//- ICMP Code is 0.</span>
    <span class="keywordflow">if</span> (rsCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a6ddd9db30da22159c80f34a5512f9833">getProtocol</a>() != <a class="code" href="_i_p_protocol_id__m_8h.html#a4297c2f400ba53cf6866e6d45bc81b70a3f40fb193e9edf4e297fcd7952acb024">IP_PROT_IPv6_ICMP</a>)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;ICMP Code is not 0! RS validation failed!\n&quot;</span>;
        result = <span class="keyword">false</span>;
    }

    <span class="comment">//- If the IP source address is the unspecified address, there is no</span>
    <span class="comment">//source link-layer address option in the message.</span>
    <span class="keywordflow">if</span> (rsCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a8980bdcd6051ae3fe071bf2c18a0215e">getSrcAddr</a>().<a class="code" href="class_i_pv6_address.html#af526cffcc3a4aa5bb96d307de6e8d448" title="Check if the IPv6 Address is undefined.">isUnspecified</a>())
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;IP source address is unspecified\n&quot;</span>;

        <span class="keywordflow">if</span> (rs-&gt;<a class="code" href="class_i_pv6_router_solicitation.html#ac27e5211d09ebbfe316b4c2b28e3a232">getSourceLinkLayerAddress</a>().<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107" title="Returns true if all address bytes are zero.">isUnspecified</a>() == <span class="keyword">false</span>)
        {
            <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot; but source link layer address is provided. RS validation failed!\n&quot;</span>;
        }
    }

    <span class="keywordflow">return</span> result;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a868ef2afa69950bd536b1fb5cd10569a"></a><!-- doxytag: member="IPv6NeighbourDiscovery::advIfList" ref="a868ef2afa69950bd536b1fb5cd10569a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_neighbour_discovery.html#a74d1e81840eb6742f1f595691e43ac29">AdvIfList</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a868ef2afa69950bd536b1fb5cd10569a">IPv6NeighbourDiscovery::advIfList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a6e0f7e782e7b912a683c653b30e7b957">createRATimer()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#a44d5adf445298a56e275377d70d620ef">fetchAdvIfEntry()</a>.</p>

</div>
</div>
<a class="anchor" id="a750d70366700481befd66c567d420a7e"></a><!-- doxytag: member="IPv6NeighbourDiscovery::dadList" ref="a750d70366700481befd66c567d420a7e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_neighbour_discovery.html#a516186e680ba4eaf87de697019421987">DADList</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a750d70366700481befd66c567d420a7e">IPv6NeighbourDiscovery::dadList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#aab8e413cb12b66797d5e497f9fe6fddd">initiateDAD()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#a13117cd0ac035e0a0fd198d872b209c3">processDADTimeout()</a>.</p>

</div>
</div>
<a class="anchor" id="a78cfa038ef771566c18a2eec28fd740b"></a><!-- doxytag: member="IPv6NeighbourDiscovery::icmpv6" ref="a78cfa038ef771566c18a2eec28fd740b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_c_m_pv6.html">ICMPv6</a>* <a class="el" href="class_i_pv6_neighbour_discovery.html#a78cfa038ef771566c18a2eec28fd740b">IPv6NeighbourDiscovery::icmpv6</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a888724269369dc1aa87aa73586216b8c">dropQueuedPacketsAwaitingAR()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a6855729184a9f8c2e0072f6773f5e96c">initialize()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#ade69131623bc5b13205ced3ff54a16d3">processIPv6Datagram()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b4f35b761b93c397e2a5a36c1e08d38"></a><!-- doxytag: member="IPv6NeighbourDiscovery::ift" ref="a4b4f35b761b93c397e2a5a36c1e08d38" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_interface_table.html">IInterfaceTable</a>* <a class="el" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">IPv6NeighbourDiscovery::ift</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a5438ceb3077ec49d9b393136a9a5e768">assignLinkLocalAddress()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a6855729184a9f8c2e0072f6773f5e96c">initialize()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a6afff1bf1db0e7b69f3f6782a87b5b82">initiateAddressResolution()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a9f14cc2bfe0cce622308be4388b3b397">initiateNeighbourUnreachabilityDetection()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a61e880bea24c63e2661d2722077ac172">processARTimeout()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a13117cd0ac035e0a0fd198d872b209c3">processDADTimeout()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#ade69131623bc5b13205ced3ff54a16d3">processIPv6Datagram()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a093219842e9055dc413f8f6d401001ee">processNAForIncompleteNCEState()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a58a8a7aaf00643c4eb0044cc1380413b">processNAForOtherNCEStates()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a348ba5dd9e93f4640d465a74b8a73d53">processNAPacket()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a8d7676502f17ed01eb095afadab7bb33">processNSPacket()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a623b4069795d46d2b421d5aee4f1eb59">processNUDTimeout()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a41da6658d387e46e3e656d4704bf908f">processRAForRouterUpdates()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a4482770f35807ddc238a9259e85752e3">processRAPacket()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#ac6f2316e1a19d2816bab83e96d11ef57">processRSPacket()</a>.</p>

</div>
</div>
<a class="anchor" id="a2034aa8fe938bda7f5e032d95892cf84"></a><!-- doxytag: member="IPv6NeighbourDiscovery::neighbourCache" ref="a2034aa8fe938bda7f5e032d95892cf84" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_neighbour_cache.html">IPv6NeighbourCache</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">IPv6NeighbourDiscovery::neighbourCache</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a888724269369dc1aa87aa73586216b8c">dropQueuedPacketsAwaitingAR()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#ade69131623bc5b13205ced3ff54a16d3">processIPv6Datagram()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a093219842e9055dc413f8f6d401001ee">processNAForIncompleteNCEState()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a58a8a7aaf00643c4eb0044cc1380413b">processNAForOtherNCEStates()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a348ba5dd9e93f4640d465a74b8a73d53">processNAPacket()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a8106a5866c58a9c6372c741a15ce943b">processNSWithSpecifiedSrcAddr()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a623b4069795d46d2b421d5aee4f1eb59">processNUDTimeout()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a41da6658d387e46e3e656d4704bf908f">processRAForRouterUpdates()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#abcd9999f935e23b593499f8d23a970bf">reachabilityConfirmed()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a567588762bff7af739e72916df55aebc">resolveNeighbour()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a9f6c83de24b3e270c3843cc213b5250a">selectDefaultRouter()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#a303391440ad2004ff69cfc5e4cf7504a">timeoutDefaultRouter()</a>.</p>

</div>
</div>
<a class="anchor" id="a8cebccf199f96d0903c4663b203199ca"></a><!-- doxytag: member="IPv6NeighbourDiscovery::pendingQueue" ref="a8cebccf199f96d0903c4663b203199ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cQueue <a class="el" href="class_i_pv6_neighbour_discovery.html#a8cebccf199f96d0903c4663b203199ca">IPv6NeighbourDiscovery::pendingQueue</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a888724269369dc1aa87aa73586216b8c">dropQueuedPacketsAwaitingAR()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a6855729184a9f8c2e0072f6773f5e96c">initialize()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#ade69131623bc5b13205ced3ff54a16d3">processIPv6Datagram()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#a6cc2bafedafa13f79df2410b6617ff4b">sendQueuedPacketsToIPv6Module()</a>.</p>

</div>
</div>
<a class="anchor" id="ad8d41d97624aa9ba4878adea476018d0"></a><!-- doxytag: member="IPv6NeighbourDiscovery::raTimerList" ref="ad8d41d97624aa9ba4878adea476018d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_neighbour_discovery.html#af7b0af85c2810acc01d715305818f59b">RATimerList</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#ad8d41d97624aa9ba4878adea476018d0">IPv6NeighbourDiscovery::raTimerList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f075a086f580756337ef6f59223727c"></a><!-- doxytag: member="IPv6NeighbourDiscovery::rdList" ref="a7f075a086f580756337ef6f59223727c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_neighbour_discovery.html#a99d6acdeeccceb22d5b199a46c1a0e78">RDList</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a7f075a086f580756337ef6f59223727c">IPv6NeighbourDiscovery::rdList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a01e12e84e38baf2539a8335f8f01abc6">cancelRouterDiscovery()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#ab83db378f6596fd37ab6657b13707aa4">fetchRDEntry()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a53cb1f954b65272ad826f3daaec29136">initiateRouterDiscovery()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#a860a64e4fbb311fef343ec7044c0a10b">processRDTimeout()</a>.</p>

</div>
</div>
<a class="anchor" id="a0f6a26512cd490f5a09e9bd7ec3bf61f"></a><!-- doxytag: member="IPv6NeighbourDiscovery::rt6" ref="a0f6a26512cd490f5a09e9bd7ec3bf61f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_routing_table6.html">RoutingTable6</a>* <a class="el" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">IPv6NeighbourDiscovery::rt6</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a50d09a125fd3477828643875b72573ec">createAndSendRAPacket()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a4bddad274cd8eb1472d37ddcd559c629">determineNextHop()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a6855729184a9f8c2e0072f6773f5e96c">initialize()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#ab645e6aeaba5afb6cfede0a13d0de5a5">makeTentativeAddressPermanent()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a1d21eff02fed770d1bf56dbb995c3db9">processNSForTentativeAddress()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a41da6658d387e46e3e656d4704bf908f">processRAForRouterUpdates()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a5acf0814f6ca500c38d87763c0a5aef7">processRAPrefixInfo()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a7ab6b1fc3d01da2bc31d772a31013e08">sendPeriodicRA()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#ac2a5f2e2cbd6845ecd10038fce448ead">sendSolicitedNA()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a30bc9cd2bec93e40e238fe91b573ca9f">sendUnsolicitedNA()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a303391440ad2004ff69cfc5e4cf7504a">timeoutDefaultRouter()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#a0e59b5c2995f7bdec6b6a67e60a1e675">timeoutPrefixEntry()</a>.</p>

</div>
</div>
<a class="anchor" id="a22051cc7aeebf83e295e30dfff069e36"></a><!-- doxytag: member="IPv6NeighbourDiscovery::startDADSignal" ref="a22051cc7aeebf83e295e30dfff069e36" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">simsignal_t <a class="el" href="class_i_pv6_neighbour_discovery.html#a22051cc7aeebf83e295e30dfff069e36">IPv6NeighbourDiscovery::startDADSignal</a> = SIMSIGNAL_NULL<code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a6855729184a9f8c2e0072f6773f5e96c">initialize()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#aab8e413cb12b66797d5e497f9fe6fddd">initiateDAD()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_i_pv6_neighbour_discovery_8h.html">IPv6NeighbourDiscovery.h</a></li>
<li><a class="el" href="_i_pv6_neighbour_discovery_8cc.html">IPv6NeighbourDiscovery.cc</a></li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="class_i_pv6_neighbour_discovery.html">IPv6NeighbourDiscovery</a>      </li>

    <li class="footer">Generated on Tue Aug 7 2012 16:01:27 for INET Framework for OMNeT++/OMNEST by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
