<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>INET Framework for OMNeT++/OMNEST: OSPF::Router Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">INET Framework for OMNeT++/OMNEST</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_o_s_p_f_1_1_router.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">OSPF::Router Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="OSPF::Router" -->
<p><code>#include &lt;OSPFRouter.h&gt;</code></p>

<p><a href="class_o_s_p_f_1_1_router-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a35bbf6cd398015ef42d76223e745ba2e">Router</a> (<a class="el" href="namespace_o_s_p_f.html#ad64f22839cca7ec05fee5b7596411197">RouterID</a> id, cSimpleModule *containingModule)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#afbabadb5293a72cd1e1bffde128df247">~Router</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#acc3ff0effb2c8b74440b479b201880df">SetRouterID</a> (<a class="el" href="namespace_o_s_p_f.html#ad64f22839cca7ec05fee5b7596411197">RouterID</a> id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_o_s_p_f.html#ad64f22839cca7ec05fee5b7596411197">RouterID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a12b09f4263d005f7b0cd808502c1de48">GetRouterID</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#ae27ea511ced12487b158e87d4582ea21">SetRFC1583Compatibility</a> (bool compatibility)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#affd6a398ee914b26e5c06e72c9998e8d">GetRFC1583Compatibility</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a69d95bca021305439e63ebb712a9559c">GetAreaCount</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_message_handler.html">MessageHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#ab2b6452dadb00d2970e3432b0b29e17f">GetMessageHandler</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a18459104f498a4de761216210665220a">GetASExternalLSACount</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#abfec528130746982c850c80084a9502b">GetASExternalLSA</a> (unsigned long i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a53df3fd45ff91fa56b853289dc23a435">GetASExternalLSA</a> (unsigned long i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#ac380db94a6b8c16941d338a11b3b6b11">GetASBoundaryRouter</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a07874bd84b94970be2c08b01a50bff9e">GetRoutingTableEntryCount</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#adc36bddb2349df8c7f013e0c1062909e">GetRoutingTableEntry</a> (unsigned long i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a9464f6da7a2b4028f100d18952984eb8">GetRoutingTableEntry</a> (unsigned long i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a429edf824d86c3200851393676608603">AddRoutingTableEntry</a> (<a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> *entry)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a41c5b61bcaa1c23247f64d5eebba64b3">AddWatches</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#aeb3b4bfce0df4171c50b5d174112b130">AddArea</a> (<a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> *area)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#af1593be786d4bdd63bb6805d5bdefb50">GetArea</a> (<a class="el" href="namespace_o_s_p_f.html#a8d10c460f2da4aae5dd61d2a082dfc56">AreaID</a> areaID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a3c81e4d286cf26f247db7940b6775580">GetArea</a> (<a class="el" href="struct_o_s_p_f_1_1_i_pv4_address.html">IPv4Address</a> address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_interface.html">Interface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a1b1dc6a8a245040f1202d833090ce8b3">GetNonVirtualInterface</a> (unsigned char ifIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a0b35533c0a9820cdd8887d5812c2db9b">InstallLSA</a> (OSPFLSA *lsa, <a class="el" href="namespace_o_s_p_f.html#a8d10c460f2da4aae5dd61d2a082dfc56">AreaID</a> areaID=<a class="el" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">BackboneAreaID</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSPFLSA *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#ab0c1b846020c1b0f5d2853cd849891df">FindLSA</a> (LSAType lsaType, <a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">LSAKeyType</a> lsaKey, <a class="el" href="namespace_o_s_p_f.html#a8d10c460f2da4aae5dd61d2a082dfc56">AreaID</a> areaID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#ae6711720d55119affde22ea9baeda7d2">AgeDatabase</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#afc4272a1f634c3329523df334e67aa3c">HasAnyNeighborInStates</a> (int states) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#ac754f8ed7d454fc7bfe53ac877eebe53">RemoveFromAllRetransmissionLists</a> (<a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">LSAKeyType</a> lsaKey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#aae605eb327107bfecd3b8f2307f788f4">IsOnAnyRetransmissionList</a> (<a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">LSAKeyType</a> lsaKey) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a2cfb1ebf041766dadf2fcd6e1fdebe27">FloodLSA</a> (OSPFLSA *lsa, <a class="el" href="namespace_o_s_p_f.html#a8d10c460f2da4aae5dd61d2a082dfc56">AreaID</a> areaID=<a class="el" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">BackboneAreaID</a>, <a class="el" href="class_o_s_p_f_1_1_interface.html">Interface</a> *intf=NULL, <a class="el" href="class_o_s_p_f_1_1_neighbor.html">Neighbor</a> *neighbor=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a1e457a90074dfce50e04ba85571ccff6">IsLocalAddress</a> (<a class="el" href="struct_o_s_p_f_1_1_i_pv4_address.html">IPv4Address</a> address) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a2ac64ff56b3bcde574fde26a5247286d">HasAddressRange</a> (<a class="el" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">IPv4AddressRange</a> addressRange) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#ad3bfc2d2a7560d2ba946288aa241725b">IsDestinationUnreachable</a> (OSPFLSA *lsa) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a99174613edc2cf3b3305ff55b67ec173">Lookup</a> (<a class="el" href="class_i_p_address.html">IPAddress</a> destination, std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; *table=NULL) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a184025a0ac2c61dc9c580b2321a9c9a1">RebuildRoutingTable</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">IPv4AddressRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a9a35624ca66179bda14774a1fbdc44bf">GetContainingAddressRange</a> (<a class="el" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">IPv4AddressRange</a> addressRange, bool *advertise=NULL) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#aed64d2915aba911a976c06f053ecf19f">UpdateExternalRoute</a> (<a class="el" href="struct_o_s_p_f_1_1_i_pv4_address.html">IPv4Address</a> networkAddress, const OSPFASExternalLSAContents &amp;externalRouteContents, int ifIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a5ec34d1a9d49f94ddd6c2552c1f100a6">RemoveExternalRoute</a> (<a class="el" href="struct_o_s_p_f_1_1_i_pv4_address.html">IPv4Address</a> networkAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a8f9ec654c6f68af3180f7d9fb9f2c87c">GetPreferredEntry</a> (const OSPFLSA &amp;lsa, bool skipSelfOriginated, std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; *fromRoutingTable=NULL)</td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a8615120ec6c21bfd812b533e5532ddcb">InstallASExternalLSA</a> (OSPFASExternalLSA *lsa)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a5aec9d69b413708dd0617190268af187">FindASExternalLSA</a> (<a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">LSAKeyType</a> lsaKey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#ae8bdbafe5f6d9219c34cea801132b232">FindASExternalLSA</a> (<a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">LSAKeyType</a> lsaKey) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#adf337b0a712b070d288f208ea5cd591a">OriginateASExternalLSA</a> (<a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> *lsa)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_o_s_p_f.html#a8ac3195d08bc351276d08e1c28e0d2dc">LinkStateID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a711150516e1e27419e4c2c9770a3d9db">GetUniqueLinkStateID</a> (<a class="el" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">IPv4AddressRange</a> destination, <a class="el" href="namespace_o_s_p_f.html#a4a99812a2d079df0f7208f2740cdb0ad">Metric</a> destinationCost, <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a> *&amp;lsaToReoriginate, bool externalMetricIsType2=false) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a3949265e72dab00a009aaa0758cd2623">CalculateASExternalRoutes</a> (std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;newRoutingTable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a57df70b2d8008b2ea1827e06ab750500">NotifyAboutRoutingTableChanges</a> (std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;oldRoutingTable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a5bb62fe635f3bbe881e9917564334751">HasRouteToASBoundaryRouter</a> (const std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;inRoutingTable, <a class="el" href="namespace_o_s_p_f.html#ad64f22839cca7ec05fee5b7596411197">OSPF::RouterID</a> <a class="el" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9">routerID</a>) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#adbda9fd0e0f79eb6131659ae5685817b">GetRoutesToASBoundaryRouter</a> (const std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;fromRoutingTable, <a class="el" href="namespace_o_s_p_f.html#ad64f22839cca7ec05fee5b7596411197">OSPF::RouterID</a> <a class="el" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9">routerID</a>) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#aa28b138458a39381a75d969e82dbfde0">PruneASBoundaryRouterEntries</a> (std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;asbrEntries) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a46ac75abdaab6c761720ce6bb6b43c37">SelectLeastCostRoutingEntry</a> (std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;entries) const </td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_o_s_p_f.html#ad64f22839cca7ec05fee5b7596411197">RouterID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9">routerID</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The router ID assigned by the <a class="el" href="class_i_p.html">IP</a> layer.  <a href="#a3ebbdb2a44054edf297b21360de68cb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="namespace_o_s_p_f.html#a8d10c460f2da4aae5dd61d2a082dfc56">AreaID</a>, <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5">areasByID</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of the contained areas with the AreaID as key.  <a href="#ab2c936939863bd82c6628c794e6409e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8">areas</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of the contained areas.  <a href="#a5ce9c0ecf94cbc5872c346750e4de6b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">LSAKeyType</a>, <br class="typebreak"/>
<a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> <br class="typebreak"/>
*, <a class="el" href="class_o_s_p_f_1_1_l_s_a_key_type___less.html">LSAKeyType_Less</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2">asExternalLSAsByID</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of the ASExternalLSAs advertised by this router.  <a href="#abbdacd52ab234eb19f6eeb24a06222c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36">asExternalLSAs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of the ASExternalLSAs advertised by this router.  <a href="#a20e18099b999ef4fd3eebca715173f36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="struct_o_s_p_f_1_1_i_pv4_address.html">IPv4Address</a>, <br class="typebreak"/>
OSPFASExternalLSAContents, <br class="typebreak"/>
<a class="el" href="class_o_s_p_f_1_1_i_pv4_address___less.html">IPv4Address_Less</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a2fa24502500b746a3056832733228a65">externalRoutes</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of the external route advertised by this router.  <a href="#a2fa24502500b746a3056832733228a65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSPFTimer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5">ageTimer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Database age timer - fires every second.  <a href="#acafd411e92c5c3bc952daadbc0d53cf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090">routingTable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespace_o_s_p_f.html">OSPF</a> routing table - contains more information than the one in the <a class="el" href="class_i_p.html">IP</a> layer.  <a href="#aff527f73b1c4068c21abb9fe9dd9f090"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_message_handler.html">MessageHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a532e99a63a766b3aabc007fd929fb48f">messageHandler</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The message dispatcher class.  <a href="#a532e99a63a766b3aabc007fd929fb48f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a10f71a71f20baa02d35f94d602758357">rfc1583Compatibility</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides whether to handle the preferred routing table entry to an AS boundary router as defined in RFC1583 or not.  <a href="#a10f71a71f20baa02d35f94d602758357"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Represents the full <a class="el" href="namespace_o_s_p_f.html">OSPF</a> datastructure as laid out in RFC2328. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a35bbf6cd398015ef42d76223e745ba2e"></a><!-- doxytag: member="OSPF::Router::Router" ref="a35bbf6cd398015ef42d76223e745ba2e" args="(RouterID id, cSimpleModule *containingModule)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSPF::Router::Router </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_o_s_p_f.html#ad64f22839cca7ec05fee5b7596411197">OSPF::RouterID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cSimpleModule *&#160;</td>
          <td class="paramname"><em>containingModule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor. Initializes internal variables, adds a <a class="el" href="class_o_s_p_f_1_1_message_handler.html">MessageHandler</a> and starts the Database Age timer. </p>
<div class="fragment"><pre class="fragment">                                                                   :
    <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>(<span class="keywordtype">id</span>),
    <a class="code" href="class_o_s_p_f_1_1_router.html#a10f71a71f20baa02d35f94d602758357" title="Decides whether to handle the preferred routing table entry to an AS boundary router as defined in RF...">rfc1583Compatibility</a>(<span class="keyword">false</span>)
{
    <a class="code" href="class_o_s_p_f_1_1_router.html#a532e99a63a766b3aabc007fd929fb48f" title="The message dispatcher class.">messageHandler</a> = <span class="keyword">new</span> <a class="code" href="class_o_s_p_f_1_1_message_handler.html">OSPF::MessageHandler</a>(<span class="keyword">this</span>, containingModule);
    <a class="code" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5" title="Database age timer - fires every second.">ageTimer</a> = <span class="keyword">new</span> OSPFTimer;
    <a class="code" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5" title="Database age timer - fires every second.">ageTimer</a>-&gt;setTimerKind(DatabaseAgeTimer);
    <a class="code" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5" title="Database age timer - fires every second.">ageTimer</a>-&gt;setContextPointer(<span class="keyword">this</span>);
    <a class="code" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5" title="Database age timer - fires every second.">ageTimer</a>-&gt;setName(<span class="stringliteral">&quot;OSPF::Router::DatabaseAgeTimer&quot;</span>);
    <a class="code" href="class_o_s_p_f_1_1_router.html#a532e99a63a766b3aabc007fd929fb48f" title="The message dispatcher class.">messageHandler</a>-&gt;StartTimer(<a class="code" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5" title="Database age timer - fires every second.">ageTimer</a>, 1.0);
}
</pre></div>
</div>
</div>
<a class="anchor" id="afbabadb5293a72cd1e1bffde128df247"></a><!-- doxytag: member="OSPF::Router::~Router" ref="afbabadb5293a72cd1e1bffde128df247" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSPF::Router::~Router </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor. Clears all LSA lists and kills the Database Age timer. </p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
        <span class="keyword">delete</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i];
    }
    <span class="keywordtype">long</span> lsaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> j = 0; j &lt; lsaCount; j++) {
        <span class="keyword">delete</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[j];
    }
    <span class="keywordtype">long</span> routeCount = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> k = 0; k &lt; routeCount; k++) {
        <span class="keyword">delete</span> <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k];
    }
    <a class="code" href="class_o_s_p_f_1_1_router.html#a532e99a63a766b3aabc007fd929fb48f" title="The message dispatcher class.">messageHandler</a>-&gt;ClearTimer(<a class="code" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5" title="Database age timer - fires every second.">ageTimer</a>);
    <span class="keyword">delete</span> <a class="code" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5" title="Database age timer - fires every second.">ageTimer</a>;
    <span class="keyword">delete</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a532e99a63a766b3aabc007fd929fb48f" title="The message dispatcher class.">messageHandler</a>;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aeb3b4bfce0df4171c50b5d174112b130"></a><!-- doxytag: member="OSPF::Router::AddArea" ref="aeb3b4bfce0df4171c50b5d174112b130" args="(Area *area)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OSPF::Router::AddArea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_s_p_f_1_1_area.html">OSPF::Area</a> *&#160;</td>
          <td class="paramname"><em>area</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a new <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> to the <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">area</td><td>[in] The <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="class_o_s_p_f_routing.html#a366e9d2f93bcb10efe24da101a6cf4a8">OSPFRouting::LoadAreaFromXML()</a>.</p>
<div class="fragment"><pre class="fragment">{

    area-&gt;<a class="code" href="class_o_s_p_f_1_1_area.html#a350562bd30814f42f8ec22a2380cd128">SetRouter</a>(<span class="keyword">this</span>);
    <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>[area-&gt;<a class="code" href="class_o_s_p_f_1_1_area.html#a5cbe0e459923e9c74db35df51031cb8d">GetAreaID</a>()] = area;
    <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.push_back(area);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a429edf824d86c3200851393676608603"></a><!-- doxytag: member="OSPF::Router::AddRoutingTableEntry" ref="a429edf824d86c3200851393676608603" args="(RoutingTableEntry *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OSPF::Router::AddRoutingTableEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.push_back(entry); }
</pre></div>
</div>
</div>
<a class="anchor" id="a41c5b61bcaa1c23247f64d5eebba64b3"></a><!-- doxytag: member="OSPF::Router::AddWatches" ref="a41c5b61bcaa1c23247f64d5eebba64b3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OSPF::Router::AddWatches </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds OMNeT++ watches for the routerID, the list of Areas and the list of AS External LSAs. </p>

<p>Referenced by <a class="el" href="class_o_s_p_f_routing.html#a757ca2b86873671c421c65e092630f42">OSPFRouting::initialize()</a>.</p>
<div class="fragment"><pre class="fragment">{
    WATCH(<a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>);
    WATCH_PTRVECTOR(<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>);
    WATCH_PTRVECTOR(<a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae6711720d55119affde22ea9baeda7d2"></a><!-- doxytag: member="OSPF::Router::AgeDatabase" ref="ae6711720d55119affde22ea9baeda7d2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OSPF::Router::AgeDatabase </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ages the LSAs in the Router's database. This method is called on every firing of the DatabaseAgeTimer(every second). </p>
<dl class="see"><dt><b>See also:</b></dt><dd>RFC2328 Section 14. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> lsaCount            = <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>.size();
    <span class="keywordtype">bool</span> rebuildRoutingTable = <span class="keyword">false</span>;

    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; lsaCount; i++) {
        <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>       lsAge          = <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[i]-&gt;getHeader().getLsAge();
        <span class="keywordtype">bool</span>                 selfOriginated = (<a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[i]-&gt;getHeader().getAdvertisingRouter().getInt() == <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>);
        <span class="keywordtype">bool</span>                 unreachable    = <a class="code" href="class_o_s_p_f_1_1_router.html#ad3bfc2d2a7560d2ba946288aa241725b">IsDestinationUnreachable</a>(<a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[i]);
        <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>* lsa            = <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[i];

        <span class="keywordflow">if</span> ((selfOriginated &amp;&amp; (lsAge &lt; (<a class="code" href="_o_s_p_fcommon_8h.html#ab08ddbd72ec04be1ff6959a492fc3795">LS_REFRESH_TIME</a> - 1))) || (!selfOriginated &amp;&amp; (lsAge &lt; (<a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a> - 1)))) {
            lsa-&gt;getHeader().setLsAge(lsAge + 1);
            <span class="keywordflow">if</span> ((lsAge + 1) % <a class="code" href="_o_s_p_fcommon_8h.html#a1dae649919191832d818cf9bba6be0e4">CHECK_AGE</a> == 0) {
                <span class="keywordflow">if</span> (!lsa-&gt;<a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html#a28349b0233b3e4e767e9e3c59ad2ecce">ValidateLSChecksum</a>()) {
                    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Invalid LS checksum. Memory error detected!\n&quot;</span>;
                }
            }
            lsa-&gt;<a class="code" href="class_o_s_p_f_1_1_l_s_a_tracking_info.html#abf7755405bc9db270e9d3db6beb9f13d">IncrementInstallTime</a>();
        }
        <span class="keywordflow">if</span> (selfOriginated &amp;&amp; (lsAge == (<a class="code" href="_o_s_p_fcommon_8h.html#ab08ddbd72ec04be1ff6959a492fc3795">LS_REFRESH_TIME</a> - 1))) {
            <span class="keywordflow">if</span> (unreachable) {
                lsa-&gt;getHeader().setLsAge(<a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a>);
                <a class="code" href="class_o_s_p_f_1_1_router.html#a2cfb1ebf041766dadf2fcd6e1fdebe27">FloodLSA</a>(lsa, <a class="code" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">OSPF::BackboneAreaID</a>);
                lsa-&gt;<a class="code" href="class_o_s_p_f_1_1_l_s_a_tracking_info.html#abf7755405bc9db270e9d3db6beb9f13d">IncrementInstallTime</a>();
            } <span class="keywordflow">else</span> {
                <span class="keywordtype">long</span> sequenceNumber = lsa-&gt;getHeader().getLsSequenceNumber();
                <span class="keywordflow">if</span> (sequenceNumber == <a class="code" href="_o_s_p_fcommon_8h.html#a35f49b34e56993fe20d3a21d144c16d3">MAX_SEQUENCE_NUMBER</a>) {
                    lsa-&gt;getHeader().setLsAge(<a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a>);
                    <a class="code" href="class_o_s_p_f_1_1_router.html#a2cfb1ebf041766dadf2fcd6e1fdebe27">FloodLSA</a>(lsa, <a class="code" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">OSPF::BackboneAreaID</a>);
                    lsa-&gt;<a class="code" href="class_o_s_p_f_1_1_l_s_a_tracking_info.html#abf7755405bc9db270e9d3db6beb9f13d">IncrementInstallTime</a>();
                } <span class="keywordflow">else</span> {
                    <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>* newLSA = <a class="code" href="class_o_s_p_f_1_1_router.html#adf337b0a712b070d288f208ea5cd591a">OriginateASExternalLSA</a>(lsa);

                    newLSA-&gt;getHeader().setLsSequenceNumber(sequenceNumber + 1);
                    newLSA-&gt;getHeader().setLsChecksum(0);    <span class="comment">// TODO: calculate correct LS checksum</span>
                    rebuildRoutingTable |= lsa-&gt;<a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html#a3bfdf218c05ec4d4b3056b656b2ee6c7">Update</a>(newLSA);
                    <span class="keyword">delete</span> newLSA;

                    <a class="code" href="class_o_s_p_f_1_1_router.html#a2cfb1ebf041766dadf2fcd6e1fdebe27">FloodLSA</a>(lsa, <a class="code" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">OSPF::BackboneAreaID</a>);
                }
            }
        }
        <span class="keywordflow">if</span> (!selfOriginated &amp;&amp; (lsAge == <a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a> - 1)) {
            lsa-&gt;getHeader().setLsAge(<a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a>);
            <a class="code" href="class_o_s_p_f_1_1_router.html#a2cfb1ebf041766dadf2fcd6e1fdebe27">FloodLSA</a>(lsa, <a class="code" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">OSPF::BackboneAreaID</a>);
            lsa-&gt;<a class="code" href="class_o_s_p_f_1_1_l_s_a_tracking_info.html#abf7755405bc9db270e9d3db6beb9f13d">IncrementInstallTime</a>();
        }
        <span class="keywordflow">if</span> (lsAge == <a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a>) {
            <a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a> lsaKey;

            lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a>       = lsa-&gt;getHeader().getLinkStateID();
            lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = lsa-&gt;getHeader().getAdvertisingRouter().getInt();

            <span class="keywordflow">if</span> (!<a class="code" href="class_o_s_p_f_1_1_router.html#aae605eb327107bfecd3b8f2307f788f4">IsOnAnyRetransmissionList</a>(lsaKey) &amp;&amp;
                !<a class="code" href="class_o_s_p_f_1_1_router.html#afc4272a1f634c3329523df334e67aa3c">HasAnyNeighborInStates</a>(<a class="code" href="class_o_s_p_f_1_1_neighbor.html#abe30518a64009a9ae44944c1036a4c0aab642c302eb79dfe9cd827bc8af960e28">OSPF::Neighbor::ExchangeState</a> | <a class="code" href="class_o_s_p_f_1_1_neighbor.html#abe30518a64009a9ae44944c1036a4c0aa8a2da2947457a95e834ef3a256b2717a">OSPF::Neighbor::LoadingState</a>))
            {
                <span class="keywordflow">if</span> (!selfOriginated || unreachable) {
                    <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.erase(lsaKey);
                    <span class="keyword">delete</span> lsa;
                    <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[i] = NULL;
                    rebuildRoutingTable = <span class="keyword">true</span>;
                } <span class="keywordflow">else</span> {
                    <span class="keywordflow">if</span> (lsa-&gt;<a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html#a64d8238a6678ab6f7e9ec666fb517adb">GetPurgeable</a>()) {
                        <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.erase(lsaKey);
                        <span class="keyword">delete</span> lsa;
                        <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[i] = NULL;
                        rebuildRoutingTable = <span class="keyword">true</span>;
                    } <span class="keywordflow">else</span> {
                        <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>* newLSA              = <a class="code" href="class_o_s_p_f_1_1_router.html#adf337b0a712b070d288f208ea5cd591a">OriginateASExternalLSA</a>(lsa);
                        <span class="keywordtype">long</span>                 sequenceNumber      = lsa-&gt;getHeader().getLsSequenceNumber();

                        newLSA-&gt;getHeader().setLsSequenceNumber((sequenceNumber == <a class="code" href="_o_s_p_fcommon_8h.html#a35f49b34e56993fe20d3a21d144c16d3">MAX_SEQUENCE_NUMBER</a>) ? <a class="code" href="_o_s_p_fcommon_8h.html#ad441394da087bc61e24a5b99455c5589">INITIAL_SEQUENCE_NUMBER</a> : sequenceNumber + 1);
                        newLSA-&gt;getHeader().setLsChecksum(0);    <span class="comment">// TODO: calculate correct LS checksum</span>
                        rebuildRoutingTable |= lsa-&gt;<a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html#a3bfdf218c05ec4d4b3056b656b2ee6c7">Update</a>(newLSA);
                        <span class="keyword">delete</span> newLSA;

                        <a class="code" href="class_o_s_p_f_1_1_router.html#a2cfb1ebf041766dadf2fcd6e1fdebe27">FloodLSA</a>(lsa, <a class="code" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">OSPF::BackboneAreaID</a>);
                    }
                }
            }
        }
    }

    std::vector&lt;ASExternalLSA*&gt;::iterator it = <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>.begin();
    <span class="keywordflow">while</span> (it != <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>.end()) {
        <span class="keywordflow">if</span> ((*it) == NULL) {
            it = <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>.erase(it);
        } <span class="keywordflow">else</span> {
            it++;
        }
    }

    <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> j = 0; j &lt; areaCount; j++) {
        <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[j]-&gt;AgeDatabase();
    }
    <a class="code" href="class_o_s_p_f_1_1_router.html#a532e99a63a766b3aabc007fd929fb48f" title="The message dispatcher class.">messageHandler</a>-&gt;StartTimer(<a class="code" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5" title="Database age timer - fires every second.">ageTimer</a>, 1.0);

    <span class="keywordflow">if</span> (rebuildRoutingTable) {
        <a class="code" href="class_o_s_p_f_1_1_router.html#a184025a0ac2c61dc9c580b2321a9c9a1">RebuildRoutingTable</a>();
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3949265e72dab00a009aaa0758cd2623"></a><!-- doxytag: member="OSPF::Router::CalculateASExternalRoutes" ref="a3949265e72dab00a009aaa0758cd2623" args="(std::vector&lt; RoutingTableEntry * &gt; &amp;newRoutingTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OSPF::Router::CalculateASExternalRoutes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>newRoutingTable</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the AS External Routes from the ASExternalLSAs in the database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newRoutingTable</td><td>[in/out] Push the new RoutingTableEntries into this routing table, and also use this for path calculations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>RFC2328 Section 16.4. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lsaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>.size();
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i;

    <span class="keywordflow">for</span> (i = 0; i &lt; lsaCount; i++) {
        <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>* currentLSA        = <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[i];
        OSPFLSAHeader&amp;       currentHeader     = currentLSA-&gt;getHeader();
        <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>       externalCost      = currentLSA-&gt;getContents().getRouteCost();
        <a class="code" href="namespace_o_s_p_f.html#ad64f22839cca7ec05fee5b7596411197">OSPF::RouterID</a>       originatingRouter = currentHeader.getAdvertisingRouter().getInt();

        <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* preferredEntry = <a class="code" href="class_o_s_p_f_1_1_router.html#a8f9ec654c6f68af3180f7d9fb9f2c87c">GetPreferredEntry</a>(*currentLSA, <span class="keyword">true</span>, &amp;newRoutingTable);
        <span class="keywordflow">if</span> (preferredEntry == NULL) {
            <span class="keywordflow">continue</span>;
        }

        <a class="code" href="class_i_p_address.html">IPAddress</a> destination = currentHeader.getLinkStateID() &amp; currentLSA-&gt;getContents().getNetworkMask().getInt();

        <a class="code" href="namespace_o_s_p_f.html#a4a99812a2d079df0f7208f2740cdb0ad">Metric</a>                   preferredCost    = preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a098e2d41bad2cd9236ee0581e6bda190">GetCost</a>();
        <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* destinationEntry = <a class="code" href="class_o_s_p_f_1_1_router.html#a99174613edc2cf3b3305ff55b67ec173">Lookup</a>(destination, &amp;newRoutingTable);   <span class="comment">// (5)</span>
        <span class="keywordflow">if</span> (destinationEntry == NULL) {
            <span class="keywordtype">bool</span>                     type2ExternalMetric = currentLSA-&gt;getContents().getE_ExternalMetricType();
            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>             nextHopCount        = preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ace9a54276cd9bc6b32ff0931d8d98bf4">GetNextHopCount</a>();
            <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* newEntry            = <span class="keyword">new</span> <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>;

            newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ae75063f049d56aa1209e02e0767c170c">SetDestinationID</a>(destination);
            newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#affeb736e63b6a2387d9a3c9ee23baa35">SetAddressMask</a>(currentLSA-&gt;getContents().getNetworkMask().getInt());
            newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a8af24090ee7cfa811b46e2aed1d282a5">SetArea</a>(preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aa1f39ae9bee53ff52d744012c9adefdf">GetArea</a>());
            newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a7ca15b35b5d0c9d2818ba07ef50b7419">SetPathType</a>(type2ExternalMetric ? <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254aa63a69910a414a0c0b98c96f51395766">OSPF::RoutingTableEntry::Type2External</a> : <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254aa222aff0a2b4a30f1a3f2020b697e558">OSPF::RoutingTableEntry::Type1External</a>);
            <span class="keywordflow">if</span> (type2ExternalMetric) {
                newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a6e9bfa59d5a79d87894d26e48f08043d">SetCost</a>(preferredCost);
                newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a06e98e3f9b93ec4c977298a484a107f9">SetType2Cost</a>(externalCost);
            } <span class="keywordflow">else</span> {
                newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a6e9bfa59d5a79d87894d26e48f08043d">SetCost</a>(preferredCost + externalCost);
            }
            newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a6f721739fbc1c2a18341afb4d8916db6">SetDestinationType</a>(<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aaf930613a21a30bef97cab3284d0648f">OSPF::RoutingTableEntry::NetworkDestination</a>);
            newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a0188055090c62f98d6c140188ab739e5">SetOptionalCapabilities</a>(currentHeader.getLsOptions());
            newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#af4963909ac78a70f0a029f5fbfef54d6">SetLinkStateOrigin</a>(currentLSA);

            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; nextHopCount; j++) {
                NextHop nextHop = preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a57125558c11e6228690587d03d6f356a">GetNextHop</a>(j);

                nextHop.advertisingRouter = originatingRouter;
                newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a4f9abc98f521b252330a7682225fdc10">AddNextHop</a>(nextHop);
            }

            newRoutingTable.push_back(newEntry);
        } <span class="keywordflow">else</span> {
            <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254">OSPF::RoutingTableEntry::RoutingPathType</a> destinationPathType = destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ae6952c69005f7d3d6421ea52439c776e">GetPathType</a>();
            <span class="keywordtype">bool</span>                                     type2ExternalMetric = currentLSA-&gt;getContents().getE_ExternalMetricType();
            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                             nextHopCount        = preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ace9a54276cd9bc6b32ff0931d8d98bf4">GetNextHopCount</a>();

            <span class="keywordflow">if</span> ((destinationPathType == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254aada3ad1646360d0d106905c77733f600">OSPF::RoutingTableEntry::IntraArea</a>) ||
                (destinationPathType == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a9e19536f5d4fede2389e66c6ff4969fa">OSPF::RoutingTableEntry::InterArea</a>))   <span class="comment">// (6) (a)</span>
            {
                <span class="keywordflow">continue</span>;
            }

            <span class="keywordflow">if</span> (((destinationPathType == OSPF::RoutingTableEntry::Type1External) &amp;&amp;
                 (type2ExternalMetric)) ||
                ((destinationPathType == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254aa63a69910a414a0c0b98c96f51395766">OSPF::RoutingTableEntry::Type2External</a>) &amp;&amp;
                 (type2ExternalMetric) &amp;&amp;
                 (destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ab4c8f56884183673fae30f0e6e98f0d6">GetType2Cost</a>() &lt; externalCost))) <span class="comment">// (6) (b)</span>
            {
                <span class="keywordflow">continue</span>;
            }

            <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* destinationPreferredEntry = <a class="code" href="class_o_s_p_f_1_1_router.html#a8f9ec654c6f68af3180f7d9fb9f2c87c">GetPreferredEntry</a>(*(destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a8a6ed86efbf4b0b456e26321fcd31c03">GetLinkStateOrigin</a>()), <span class="keyword">false</span>, &amp;newRoutingTable);
            <span class="keywordflow">if</span> ((!<a class="code" href="class_o_s_p_f_1_1_router.html#a10f71a71f20baa02d35f94d602758357" title="Decides whether to handle the preferred routing table entry to an AS boundary router as defined in RF...">rfc1583Compatibility</a>) &amp;&amp;
                (destinationPreferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ae6952c69005f7d3d6421ea52439c776e">GetPathType</a>() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254aada3ad1646360d0d106905c77733f600">OSPF::RoutingTableEntry::IntraArea</a>) &amp;&amp;
                (destinationPreferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aa1f39ae9bee53ff52d744012c9adefdf">GetArea</a>() != <a class="code" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">OSPF::BackboneAreaID</a>) &amp;&amp;
                ((preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ae6952c69005f7d3d6421ea52439c776e">GetPathType</a>() != <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254aada3ad1646360d0d106905c77733f600">OSPF::RoutingTableEntry::IntraArea</a>) ||
                 (preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aa1f39ae9bee53ff52d744012c9adefdf">GetArea</a>() == <a class="code" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">OSPF::BackboneAreaID</a>)))
            {
                <span class="keywordflow">continue</span>;
            }

            <span class="keywordflow">if</span> ((((destinationPathType == OSPF::RoutingTableEntry::Type1External) &amp;&amp;
                  (!type2ExternalMetric) &amp;&amp;
                  (destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a098e2d41bad2cd9236ee0581e6bda190">GetCost</a>() &lt; preferredCost + externalCost))) ||
                ((destinationPathType == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254aa63a69910a414a0c0b98c96f51395766">OSPF::RoutingTableEntry::Type2External</a>) &amp;&amp;
                 (type2ExternalMetric) &amp;&amp;
                 (destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ab4c8f56884183673fae30f0e6e98f0d6">GetType2Cost</a>() == externalCost) &amp;&amp;
                 (destinationPreferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a098e2d41bad2cd9236ee0581e6bda190">GetCost</a>() &lt; preferredCost)))
            {
                <span class="keywordflow">continue</span>;
            }

            <span class="keywordflow">if</span> (((destinationPathType == OSPF::RoutingTableEntry::Type1External) &amp;&amp;
                 (!type2ExternalMetric) &amp;&amp;
                 (destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a098e2d41bad2cd9236ee0581e6bda190">GetCost</a>() == (preferredCost + externalCost))) ||
                ((destinationPathType == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254aa63a69910a414a0c0b98c96f51395766">OSPF::RoutingTableEntry::Type2External</a>) &amp;&amp;
                 (type2ExternalMetric) &amp;&amp;
                 (destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ab4c8f56884183673fae30f0e6e98f0d6">GetType2Cost</a>() == externalCost) &amp;&amp;
                 (destinationPreferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a098e2d41bad2cd9236ee0581e6bda190">GetCost</a>() == preferredCost)))   <span class="comment">// equal cost</span>
            {
                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; nextHopCount; j++) {
                    <span class="comment">// TODO: merge next hops, not add</span>
                    NextHop nextHop = preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a57125558c11e6228690587d03d6f356a">GetNextHop</a>(j);

                    nextHop.advertisingRouter = originatingRouter;
                    destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a4f9abc98f521b252330a7682225fdc10">AddNextHop</a>(nextHop);
                }
                <span class="keywordflow">continue</span>;
            }

            <span class="comment">// LSA is better</span>
            destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a8af24090ee7cfa811b46e2aed1d282a5">SetArea</a>(preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aa1f39ae9bee53ff52d744012c9adefdf">GetArea</a>());
            destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a7ca15b35b5d0c9d2818ba07ef50b7419">SetPathType</a>(type2ExternalMetric ? <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254aa63a69910a414a0c0b98c96f51395766">OSPF::RoutingTableEntry::Type2External</a> : OSPF::RoutingTableEntry::Type1External);
            <span class="keywordflow">if</span> (type2ExternalMetric) {
                destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a6e9bfa59d5a79d87894d26e48f08043d">SetCost</a>(preferredCost);
                destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a06e98e3f9b93ec4c977298a484a107f9">SetType2Cost</a>(externalCost);
            } <span class="keywordflow">else</span> {
                destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a6e9bfa59d5a79d87894d26e48f08043d">SetCost</a>(preferredCost + externalCost);
            }
            destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a6f721739fbc1c2a18341afb4d8916db6">SetDestinationType</a>(<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aaf930613a21a30bef97cab3284d0648f">OSPF::RoutingTableEntry::NetworkDestination</a>);
            destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a0188055090c62f98d6c140188ab739e5">SetOptionalCapabilities</a>(currentHeader.getLsOptions());
            destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ac36685b249b13330263afc5000dea6bc">ClearNextHops</a>();

            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; nextHopCount; j++) {
                NextHop nextHop = preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a57125558c11e6228690587d03d6f356a">GetNextHop</a>(j);

                nextHop.advertisingRouter = originatingRouter;
                destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a4f9abc98f521b252330a7682225fdc10">AddNextHop</a>(nextHop);
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5aec9d69b413708dd0617190268af187"></a><!-- doxytag: member="OSPF::Router::FindASExternalLSA" ref="a5aec9d69b413708dd0617190268af187" args="(LSAKeyType lsaKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a> * OSPF::Router::FindASExternalLSA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a>&#160;</td>
          <td class="paramname"><em>lsaKey</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the AS External LSA identified by the input lsaKey in the database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsaKey</td><td>[in] Look for the AS External LSA which is identified by this key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The pointer to the AS External LSA if it was found, NULL otherwise. </dd></dl>
<div class="fragment"><pre class="fragment">{
    std::map&lt;OSPF::LSAKeyType, OSPF::ASExternalLSA*, OSPF::LSAKeyType_Less&gt;::iterator lsaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.find(lsaKey);
    <span class="keywordflow">if</span> (lsaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.end()) {
        <span class="keywordflow">return</span> lsaIt-&gt;second;
    } <span class="keywordflow">else</span> {
        <span class="keywordflow">return</span> NULL;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae8bdbafe5f6d9219c34cea801132b232"></a><!-- doxytag: member="OSPF::Router::FindASExternalLSA" ref="ae8bdbafe5f6d9219c34cea801132b232" args="(LSAKeyType lsaKey) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a> * OSPF::Router::FindASExternalLSA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a>&#160;</td>
          <td class="paramname"><em>lsaKey</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the AS External LSA identified by the input lsaKey in the database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsaKey</td><td>[in] Look for the AS External LSA which is identified by this key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The const pointer to the AS External LSA if it was found, NULL otherwise. </dd></dl>
<div class="fragment"><pre class="fragment">{
    std::map&lt;OSPF::LSAKeyType, OSPF::ASExternalLSA*, OSPF::LSAKeyType_Less&gt;::const_iterator lsaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.find(lsaKey);
    <span class="keywordflow">if</span> (lsaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.end()) {
        <span class="keywordflow">return</span> lsaIt-&gt;second;
    } <span class="keywordflow">else</span> {
        <span class="keywordflow">return</span> NULL;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab0c1b846020c1b0f5d2853cd849891df"></a><!-- doxytag: member="OSPF::Router::FindLSA" ref="ab0c1b846020c1b0f5d2853cd849891df" args="(LSAType lsaType, LSAKeyType lsaKey, AreaID areaID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSPFLSA * OSPF::Router::FindLSA </td>
          <td>(</td>
          <td class="paramtype">LSAType&#160;</td>
          <td class="paramname"><em>lsaType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a>&#160;</td>
          <td class="paramname"><em>lsaKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_p_f.html#a8d10c460f2da4aae5dd61d2a082dfc56">OSPF::AreaID</a>&#160;</td>
          <td class="paramname"><em>areaID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the LSA identified by the input lsaKey in the database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsaType</td><td>[in] Look for an LSA of this type. </td></tr>
    <tr><td class="paramname">lsaKey</td><td>[in] Look for the LSA which is identified by this key. </td></tr>
    <tr><td class="paramname">areaID</td><td>[in] In case of <a class="el" href="class_o_s_p_f_1_1_router.html">Router</a>, Network and Summary LSAs, look in the Area's database identified by this parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The pointer to the LSA if it was found, NULL otherwise. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">switch</span> (lsaType) {
        <span class="keywordflow">case</span> RouterLSAType:
            {
                std::map&lt;OSPF::AreaID, OSPF::Area*&gt;::iterator areaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.find(areaID);
                <span class="keywordflow">if</span> (areaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.end()) {
                    <span class="keywordflow">return</span> areaIt-&gt;second-&gt;FindRouterLSA(lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a>);
                }
            }
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> NetworkLSAType:
            {
                std::map&lt;OSPF::AreaID, OSPF::Area*&gt;::iterator areaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.find(areaID);
                <span class="keywordflow">if</span> (areaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.end()) {
                    <span class="keywordflow">return</span> areaIt-&gt;second-&gt;FindNetworkLSA(lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a>);
                }
            }
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> SummaryLSA_NetworksType:
        <span class="keywordflow">case</span> SummaryLSA_ASBoundaryRoutersType:
            {
                std::map&lt;OSPF::AreaID, OSPF::Area*&gt;::iterator areaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.find(areaID);
                <span class="keywordflow">if</span> (areaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.end()) {
                    <span class="keywordflow">return</span> areaIt-&gt;second-&gt;FindSummaryLSA(lsaKey);
                }
            }
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> ASExternalLSAType:
            {
                <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a5aec9d69b413708dd0617190268af187">FindASExternalLSA</a>(lsaKey);
            }
            <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>:
            ASSERT(<span class="keyword">false</span>);
            <span class="keywordflow">break</span>;
    }
    <span class="keywordflow">return</span> NULL;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2cfb1ebf041766dadf2fcd6e1fdebe27"></a><!-- doxytag: member="OSPF::Router::FloodLSA" ref="a2cfb1ebf041766dadf2fcd6e1fdebe27" args="(OSPFLSA *lsa, AreaID areaID=BackboneAreaID, Interface *intf=NULL, Neighbor *neighbor=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OSPF::Router::FloodLSA </td>
          <td>(</td>
          <td class="paramtype">OSPFLSA *&#160;</td>
          <td class="paramname"><em>lsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_p_f.html#a8d10c460f2da4aae5dd61d2a082dfc56">OSPF::AreaID</a>&#160;</td>
          <td class="paramname"><em>areaID</em> = <code><a class="el" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">BackboneAreaID</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_s_p_f_1_1_interface.html">OSPF::Interface</a> *&#160;</td>
          <td class="paramname"><em>intf</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_s_p_f_1_1_neighbor.html">OSPF::Neighbor</a> *&#160;</td>
          <td class="paramname"><em>neighbor</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Floods out the input lsa on a set of Interfaces. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>RFC2328 Section 13.3. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsa</td><td>[in] The LSA to be flooded out. </td></tr>
    <tr><td class="paramname">areaID</td><td>[in] If the lsa is a <a class="el" href="class_o_s_p_f_1_1_router.html">Router</a>, Network or Summary LSA, then flood it only in this <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a>. </td></tr>
    <tr><td class="paramname">intf</td><td>[in] The <a class="el" href="class_o_s_p_f_1_1_interface.html">Interface</a> this LSA arrived on. </td></tr>
    <tr><td class="paramname">neighbor</td><td>[in] The Nieghbor this LSA arrived from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the LSA was floooded back out on the receiving <a class="el" href="class_o_s_p_f_1_1_interface.html">Interface</a>, false otherwise. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> floodedBackOut = <span class="keyword">false</span>;

    <span class="keywordflow">if</span> (lsa != NULL) {
        <span class="keywordflow">if</span> (lsa-&gt;getHeader().getLsType() == ASExternalLSAType) {
            <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
            <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
                <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;GetExternalRoutingCapability()) {
                    <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;<a class="code" href="class_o_s_p_f_1_1_router.html#a2cfb1ebf041766dadf2fcd6e1fdebe27">FloodLSA</a>(lsa, intf, neighbor)) {
                        floodedBackOut = <span class="keyword">true</span>;
                    }
                }
            }
        } <span class="keywordflow">else</span> {
            std::map&lt;OSPF::AreaID, OSPF::Area*&gt;::iterator areaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.find(areaID);
            <span class="keywordflow">if</span> (areaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.end()) {
                floodedBackOut = areaIt-&gt;second-&gt;FloodLSA(lsa, intf, neighbor);
            }
        }
    }

    <span class="keywordflow">return</span> floodedBackOut;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3c81e4d286cf26f247db7940b6775580"></a><!-- doxytag: member="OSPF::Router::GetArea" ref="a3c81e4d286cf26f247db7940b6775580" args="(IPv4Address address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_area.html">OSPF::Area</a> * OSPF::Router::GetArea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_p_f_1_1_i_pv4_address.html">OSPF::IPv4Address</a>&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> pointer from the <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> list which contains the input <a class="el" href="class_i_p.html">IP</a> address, NULL if there's no such area connected to the <a class="el" href="class_o_s_p_f_1_1_router.html">Router</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>[in] The <a class="el" href="class_i_p.html">IP</a> address whose containing <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> we're looking for. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
        <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;ContainsAddress(address)) {
            <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i];
        }
    }
    <span class="keywordflow">return</span> NULL;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af1593be786d4bdd63bb6805d5bdefb50"></a><!-- doxytag: member="OSPF::Router::GetArea" ref="af1593be786d4bdd63bb6805d5bdefb50" args="(AreaID areaID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_area.html">OSPF::Area</a> * OSPF::Router::GetArea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_o_s_p_f.html#a8d10c460f2da4aae5dd61d2a082dfc56">OSPF::AreaID</a>&#160;</td>
          <td class="paramname"><em>areaID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the pointer to the <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> identified by the input areaID, if it's on the <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> list, NULL otherwise. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">areaID</td><td>[in] The <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> identifier. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="class_o_s_p_f_routing.html#aaaa7a0595a166970c8c6238b52dacfff">OSPFRouting::LoadHostRoute()</a>, <a class="el" href="class_o_s_p_f_routing.html#a2f4d972b5e0953bdfa621f22a72b8113">OSPFRouting::LoadInterfaceParameters()</a>, and <a class="el" href="class_o_s_p_f_routing.html#adb2da70e8f941e2904279f3d176bf0b5">OSPFRouting::LoadVirtualLink()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::map&lt;OSPF::AreaID, OSPF::Area*&gt;::iterator areaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.find(areaID);
    <span class="keywordflow">if</span> (areaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.end()) {
        <span class="keywordflow">return</span> (areaIt-&gt;second);
    }
    <span class="keywordflow">else</span> {
        <span class="keywordflow">return</span> NULL;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a69d95bca021305439e63ebb712a9559c"></a><!-- doxytag: member="OSPF::Router::GetAreaCount" ref="a69d95bca021305439e63ebb712a9559c" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long OSPF::Router::GetAreaCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size(); }
</pre></div>
</div>
</div>
<a class="anchor" id="ac380db94a6b8c16941d338a11b3b6b11"></a><!-- doxytag: member="OSPF::Router::GetASBoundaryRouter" ref="ac380db94a6b8c16941d338a11b3b6b11" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OSPF::Router::GetASBoundaryRouter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a2fa24502500b746a3056832733228a65" title="A map of the external route advertised by this router.">externalRoutes</a>.size() &gt; 0); }
</pre></div>
</div>
</div>
<a class="anchor" id="a53df3fd45ff91fa56b853289dc23a435"></a><!-- doxytag: member="OSPF::Router::GetASExternalLSA" ref="a53df3fd45ff91fa56b853289dc23a435" args="(unsigned long i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a>* OSPF::Router::GetASExternalLSA </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[i]; }
</pre></div>
</div>
</div>
<a class="anchor" id="abfec528130746982c850c80084a9502b"></a><!-- doxytag: member="OSPF::Router::GetASExternalLSA" ref="abfec528130746982c850c80084a9502b" args="(unsigned long i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a>* OSPF::Router::GetASExternalLSA </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_neighbor.html#a5f89aa9c034e0bd33eedab6b1bb72226">OSPF::Neighbor::CreateDatabaseSummary()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[i]; }
</pre></div>
</div>
</div>
<a class="anchor" id="a18459104f498a4de761216210665220a"></a><!-- doxytag: member="OSPF::Router::GetASExternalLSACount" ref="a18459104f498a4de761216210665220a" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long OSPF::Router::GetASExternalLSACount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_neighbor.html#a5f89aa9c034e0bd33eedab6b1bb72226">OSPF::Neighbor::CreateDatabaseSummary()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>.size(); }
</pre></div>
</div>
</div>
<a class="anchor" id="a9a35624ca66179bda14774a1fbdc44bf"></a><!-- doxytag: member="OSPF::Router::GetContainingAddressRange" ref="a9a35624ca66179bda14774a1fbdc44bf" args="(IPv4AddressRange addressRange, bool *advertise=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">OSPF::IPv4AddressRange</a> OSPF::Router::GetContainingAddressRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">OSPF::IPv4AddressRange</a>&#160;</td>
          <td class="paramname"><em>addressRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>advertise</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Scans through the router's areas' preconfigured address ranges and returns the one containing the input addressRange. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">addressRange</td><td>[in] The address range to look for. </td></tr>
    <tr><td class="paramname">advertise</td><td>[out] Whether the advertise flag is set in the returned preconfigured address range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The containing preconfigured address range if found, <a class="el" href="namespace_o_s_p_f.html#ad8bce8fb1420d6747aba9a122e7300ea">OSPF::NullIPv4AddressRange</a> otherwise. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
        <a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">OSPF::IPv4AddressRange</a> containingAddressRange = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;GetContainingAddressRange(addressRange, advertise);
        <span class="keywordflow">if</span> (containingAddressRange != <a class="code" href="namespace_o_s_p_f.html#ad8bce8fb1420d6747aba9a122e7300ea">OSPF::NullIPv4AddressRange</a>) {
            <span class="keywordflow">return</span> containingAddressRange;
        }
    }
    <span class="keywordflow">if</span> (advertise != NULL) {
        *advertise = <span class="keyword">false</span>;
    }
    <span class="keywordflow">return</span> <a class="code" href="namespace_o_s_p_f.html#ad8bce8fb1420d6747aba9a122e7300ea">OSPF::NullIPv4AddressRange</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab2b6452dadb00d2970e3432b0b29e17f"></a><!-- doxytag: member="OSPF::Router::GetMessageHandler" ref="ab2b6452dadb00d2970e3432b0b29e17f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_message_handler.html">MessageHandler</a>* OSPF::Router::GetMessageHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_o_s_p_f_routing.html#acdf1e955f64a259cad0ac496e2c846a2">OSPFRouting::handleMessage()</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor_state_two_way.html#a3088a5eaa889a2f1394fd891e74648a1">OSPF::NeighborStateTwoWay::ProcessEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor_state_loading.html#ae2fb7a1b73472a27b95b7fd370595a9c">OSPF::NeighborStateLoading::ProcessEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor_state_init.html#a17087f77a78bfd579667580af4314bd5">OSPF::NeighborStateInit::ProcessEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor_state_full.html#a12f0324da877b3cac8b5afbd509df0ae">OSPF::NeighborStateFull::ProcessEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor_state_exchange_start.html#ab759e2911bdf00193e6695400828978b">OSPF::NeighborStateExchangeStart::ProcessEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor_state_exchange.html#a3b983ffc2fdb9213d062f34e0fb18f00">OSPF::NeighborStateExchange::ProcessEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor_state_down.html#a16ce80eb3f947c2adb62b2d885e835fd">OSPF::NeighborStateDown::ProcessEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor_state_attempt.html#adc63475f921161565800b1c33e78f814">OSPF::NeighborStateAttempt::ProcessEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_interface_state_waiting.html#a1c171914cc5f51b2abfd31a2989f381f">OSPF::InterfaceStateWaiting::ProcessEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_interface_state_point_to_point.html#ad1f8cf4997cd0466739dc1f92bd729c5">OSPF::InterfaceStatePointToPoint::ProcessEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_interface_state_not_designated_router.html#a66a27381b680b112dff13e1eea9b1cdf">OSPF::InterfaceStateNotDesignatedRouter::ProcessEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_interface_state_down.html#a83cea8a35e1668a5c945c7deb8bf0c9b">OSPF::InterfaceStateDown::ProcessEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_interface_state_designated_router.html#a8d095bf645a3a0624395d66b694523e4">OSPF::InterfaceStateDesignatedRouter::ProcessEvent()</a>, and <a class="el" href="class_o_s_p_f_1_1_interface_state_backup.html#a3cf01c564824be047a09ccc879e3bbf2">OSPF::InterfaceStateBackup::ProcessEvent()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a532e99a63a766b3aabc007fd929fb48f" title="The message dispatcher class.">messageHandler</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a1b1dc6a8a245040f1202d833090ce8b3"></a><!-- doxytag: member="OSPF::Router::GetNonVirtualInterface" ref="a1b1dc6a8a245040f1202d833090ce8b3" args="(unsigned char ifIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_interface.html">OSPF::Interface</a> * OSPF::Router::GetNonVirtualInterface </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>ifIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the pointer of the physical <a class="el" href="class_o_s_p_f_1_1_interface.html">Interface</a> identified by the input interface index, NULL if the <a class="el" href="class_o_s_p_f_1_1_router.html">Router</a> doesn't have such an interface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ifIndex</td><td>[in] The interface index to look for. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
        <a class="code" href="class_o_s_p_f_1_1_interface.html">OSPF::Interface</a>* intf = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;GetInterface(ifIndex);
        <span class="keywordflow">if</span> (intf != NULL) {
            <span class="keywordflow">return</span> intf;
        }
    }
    <span class="keywordflow">return</span> NULL;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8f9ec654c6f68af3180f7d9fb9f2c87c"></a><!-- doxytag: member="OSPF::Router::GetPreferredEntry" ref="a8f9ec654c6f68af3180f7d9fb9f2c87c" args="(const OSPFLSA &amp;lsa, bool skipSelfOriginated, std::vector&lt; RoutingTableEntry * &gt; *fromRoutingTable=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a> * OSPF::Router::GetPreferredEntry </td>
          <td>(</td>
          <td class="paramtype">const OSPFLSA &amp;&#160;</td>
          <td class="paramname"><em>lsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipSelfOriginated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; *&#160;</td>
          <td class="paramname"><em>fromRoutingTable</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Selects the preferred routing table entry for the input LSA(which is either an <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> or a <a class="el" href="class_o_s_p_f_1_1_summary_l_s_a.html">SummaryLSA</a>) according to the algorithm defined in RFC2328 Section 16.4. points(1) through(3). This method is used when calculating the AS external routes and also when originating an <a class="el" href="class_o_s_p_f_1_1_summary_l_s_a.html">SummaryLSA</a> for an AS Boundary <a class="el" href="class_o_s_p_f_1_1_router.html">Router</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsa</td><td>[in] The LSA describing the destination for which the preferred Routing Entry is sought for. </td></tr>
    <tr><td class="paramname">skipSelfOriginated</td><td>[in] Whether to disregard this LSA if it was self-originated. </td></tr>
    <tr><td class="paramname">fromRoutingTable</td><td>[in] The Routing Table from which to select the preferred <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a>. If it is NULL then the router's current routing table is used instead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The preferred <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a>, or NULL if no such entry exists. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>RFC2328 Section 16.4. points(1) through(3) </dd>
<dd>
<a class="el" href="class_o_s_p_f_1_1_area.html#ad90ee6523ce24723074bbf184979c9ef">OSPF::Area::OriginateSummaryLSA</a> </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (fromRoutingTable == NULL) {
        fromRoutingTable = &amp;<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>;
    }

    <span class="keyword">const</span> OSPFLSAHeader&amp;     lsaHeader         = lsa.getHeader();
    <span class="keyword">const</span> OSPFASExternalLSA* asExternalLSA     = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>OSPFASExternalLSA*<span class="keyword">&gt;</span> (&amp;lsa);
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>            externalCost      = (asExternalLSA != NULL) ? asExternalLSA-&gt;getContents().getRouteCost() : 0;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>           lsAge             = lsaHeader.getLsAge();
    <a class="code" href="namespace_o_s_p_f.html#ad64f22839cca7ec05fee5b7596411197">OSPF::RouterID</a>           originatingRouter = lsaHeader.getAdvertisingRouter().getInt();
    <span class="keywordtype">bool</span>                     selfOriginated    = (originatingRouter == <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>);
    <a class="code" href="class_i_p_address.html">IPAddress</a>                forwardingAddress; <span class="comment">// 0.0.0.0</span>

    <span class="keywordflow">if</span> (asExternalLSA != NULL) {
        forwardingAddress = asExternalLSA-&gt;getContents().getForwardingAddress();
    }

    <span class="keywordflow">if</span> ((externalCost == <a class="code" href="_o_s_p_fcommon_8h.html#adae502e9fc4510696255aa68d1413fb1">LS_INFINITY</a>) || (lsAge == <a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a>) || (skipSelfOriginated &amp;&amp; selfOriginated)) { <span class="comment">// (1) and(2)</span>
        <span class="keywordflow">return</span> NULL;
    }

    <span class="keywordflow">if</span> (!<a class="code" href="class_o_s_p_f_1_1_router.html#a5bb62fe635f3bbe881e9917564334751">HasRouteToASBoundaryRouter</a>(*fromRoutingTable, originatingRouter)) { <span class="comment">// (3)</span>
        <span class="keywordflow">return</span> NULL;
    }

    <span class="keywordflow">if</span> (forwardingAddress.<a class="code" href="class_i_p_address.html#a7fb3c274d7a8600be890f83c028d5f96">isUnspecified</a>()) {   <span class="comment">// (3)</span>
        std::vector&lt;OSPF::RoutingTableEntry*&gt; asbrEntries = <a class="code" href="class_o_s_p_f_1_1_router.html#adbda9fd0e0f79eb6131659ae5685817b">GetRoutesToASBoundaryRouter</a>(*fromRoutingTable, originatingRouter);
        <span class="keywordflow">if</span> (!<a class="code" href="class_o_s_p_f_1_1_router.html#a10f71a71f20baa02d35f94d602758357" title="Decides whether to handle the preferred routing table entry to an AS boundary router as defined in RF...">rfc1583Compatibility</a>) {
            <a class="code" href="class_o_s_p_f_1_1_router.html#aa28b138458a39381a75d969e82dbfde0">PruneASBoundaryRouterEntries</a>(asbrEntries);
        }
        <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a46ac75abdaab6c761720ce6bb6b43c37">SelectLeastCostRoutingEntry</a>(asbrEntries);
    } <span class="keywordflow">else</span> {
        <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* forwardEntry = <a class="code" href="class_o_s_p_f_1_1_router.html#a99174613edc2cf3b3305ff55b67ec173">Lookup</a>(forwardingAddress, fromRoutingTable);

        <span class="keywordflow">if</span> (forwardEntry == NULL) {
            <span class="keywordflow">return</span> NULL;
        }

        <span class="keywordflow">if</span> ((forwardEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ae6952c69005f7d3d6421ea52439c776e">GetPathType</a>() != <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254aada3ad1646360d0d106905c77733f600">OSPF::RoutingTableEntry::IntraArea</a>) &amp;&amp;
            (forwardEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ae6952c69005f7d3d6421ea52439c776e">GetPathType</a>() != <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a9e19536f5d4fede2389e66c6ff4969fa">OSPF::RoutingTableEntry::InterArea</a>))
        {
            <span class="keywordflow">return</span> NULL;
        }

        <span class="keywordflow">return</span> forwardEntry;
    }

    <span class="keywordflow">return</span> NULL;
}
</pre></div>
</div>
</div>
<a class="anchor" id="affd6a398ee914b26e5c06e72c9998e8d"></a><!-- doxytag: member="OSPF::Router::GetRFC1583Compatibility" ref="affd6a398ee914b26e5c06e72c9998e8d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OSPF::Router::GetRFC1583Compatibility </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a10f71a71f20baa02d35f94d602758357" title="Decides whether to handle the preferred routing table entry to an AS boundary router as defined in RF...">rfc1583Compatibility</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a12b09f4263d005f7b0cd808502c1de48"></a><!-- doxytag: member="OSPF::Router::GetRouterID" ref="a12b09f4263d005f7b0cd808502c1de48" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_o_s_p_f.html#ad64f22839cca7ec05fee5b7596411197">RouterID</a> OSPF::Router::GetRouterID </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_interface_state.html#a4a784ea0a363117c123cdac528001767">OSPF::InterfaceState::CalculateDesignatedRouter()</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor_state.html#a2aaa9b77d04ee05f86463f5f468080d9">OSPF::NeighborState::ChangeState()</a>, <a class="el" href="class_o_s_p_f_1_1_interface_state.html#a10805e77b3f9a99f2e678f8e29f3b7bc">OSPF::InterfaceState::ChangeState()</a>, and <a class="el" href="class_o_s_p_f_routing.html#af1b821a07e9e6aa92b95d8b88c351675">OSPFRouting::LoadConfigFromXML()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="adbda9fd0e0f79eb6131659ae5685817b"></a><!-- doxytag: member="OSPF::Router::GetRoutesToASBoundaryRouter" ref="adbda9fd0e0f79eb6131659ae5685817b" args="(const std::vector&lt; RoutingTableEntry * &gt; &amp;fromRoutingTable, OSPF::RouterID routerID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a> * &gt; OSPF::Router::GetRoutesToASBoundaryRouter </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>fromRoutingTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_p_f.html#ad64f22839cca7ec05fee5b7596411197">OSPF::RouterID</a>&#160;</td>
          <td class="paramname"><em>routerID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an std::vector of routes leading to the AS Boundary <a class="el" href="class_o_s_p_f_1_1_router.html">Router</a> identified by asbrRouterID from the input fromRoutingTable. If there are no routes leading to the AS Boundary <a class="el" href="class_o_s_p_f_1_1_router.html">Router</a>, the returned std::vector is empty. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fromRoutingTable</td><td>[in] The routing table to look in. </td></tr>
    <tr><td class="paramname">asbrRouterID</td><td>[in] The ID of the AS Boundary <a class="el" href="class_o_s_p_f_1_1_router.html">Router</a> to look for. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    std::vector&lt;OSPF::RoutingTableEntry*&gt; results;
    <span class="keywordtype">long</span>                                  routeCount = fromRoutingTable.size();

    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; routeCount; i++) {
        <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* routingEntry = fromRoutingTable[i];
        <span class="keywordflow">if</span> (((routingEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ad8499eafeaedf12631fcf23389edaf44">GetDestinationType</a>() &amp; <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a5d17313f8ef2882f4e6c84dfbfb07a16">OSPF::RoutingTableEntry::ASBoundaryRouterDestination</a>) != 0) &amp;&amp;
            (routingEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aabd6e43c5ef3feb40a60b6c03163c2a7">GetDestinationID</a>().<a class="code" href="class_i_p_address.html#a807ca46964a8403cf0c70f0772179524">getInt</a>() == asbrRouterID))
        {
            results.push_back(routingEntry);
        }
    }
    <span class="keywordflow">return</span> results;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adc36bddb2349df8c7f013e0c1062909e"></a><!-- doxytag: member="OSPF::Router::GetRoutingTableEntry" ref="adc36bddb2349df8c7f013e0c1062909e" args="(unsigned long i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a>* OSPF::Router::GetRoutingTableEntry </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]; }
</pre></div>
</div>
</div>
<a class="anchor" id="a9464f6da7a2b4028f100d18952984eb8"></a><!-- doxytag: member="OSPF::Router::GetRoutingTableEntry" ref="a9464f6da7a2b4028f100d18952984eb8" args="(unsigned long i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a>* OSPF::Router::GetRoutingTableEntry </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]; }
</pre></div>
</div>
</div>
<a class="anchor" id="a07874bd84b94970be2c08b01a50bff9e"></a><!-- doxytag: member="OSPF::Router::GetRoutingTableEntryCount" ref="a07874bd84b94970be2c08b01a50bff9e" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long OSPF::Router::GetRoutingTableEntryCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.size(); }
</pre></div>
</div>
</div>
<a class="anchor" id="a711150516e1e27419e4c2c9770a3d9db"></a><!-- doxytag: member="OSPF::Router::GetUniqueLinkStateID" ref="a711150516e1e27419e4c2c9770a3d9db" args="(IPv4AddressRange destination, Metric destinationCost, OSPF::ASExternalLSA *&amp;lsaToReoriginate, bool externalMetricIsType2=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_o_s_p_f.html#a8ac3195d08bc351276d08e1c28e0d2dc">OSPF::LinkStateID</a> OSPF::Router::GetUniqueLinkStateID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">OSPF::IPv4AddressRange</a>&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_p_f.html#a4a99812a2d079df0f7208f2740cdb0ad">OSPF::Metric</a>&#160;</td>
          <td class="paramname"><em>destinationCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a> *&amp;&#160;</td>
          <td class="paramname"><em>lsaToReoriginate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>externalMetricIsType2</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generates a unique LinkStateID for a given destination. This may require the reorigination of an LSA already in the database(with a different LinkStateID). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>[in] The destination for which a unique LinkStateID is required. </td></tr>
    <tr><td class="paramname">destinationCost</td><td>[in] The path cost to the destination. </td></tr>
    <tr><td class="paramname">lsaToReoriginate</td><td>[out] The LSA to reoriginate(which was already in the database, and had to be changed). </td></tr>
    <tr><td class="paramname">externalMetricIsType2</td><td>[in] True if the destinationCost is given as a Type2 external metric. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the LinkStateID for the destination. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>RFC2328 Appendix E. </dd>
<dd>
<a class="el" href="class_o_s_p_f_1_1_area.html#a8f3e4d8ba4c2ef6e39aff7a894a0930d">OSPF::Area::GetUniqueLinkStateID</a> </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (lsaToReoriginate != NULL) {
        <span class="keyword">delete</span> lsaToReoriginate;
        lsaToReoriginate = NULL;
    }

    <a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a> lsaKey;

    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a> = <a class="code" href="_o_s_p_fcommon_8h.html#a4da9e68bb3ffcba090d1b07a5f812ce3">ULongFromIPv4Address</a>(destination.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a74993d6571119644535ac918c4240722">address</a>);
    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>;

    <span class="keyword">const</span> <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>* foundLSA = <a class="code" href="class_o_s_p_f_1_1_router.html#a5aec9d69b413708dd0617190268af187">FindASExternalLSA</a>(lsaKey);

    <span class="keywordflow">if</span> (foundLSA == NULL) {
        <span class="keywordflow">return</span> lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a>;
    } <span class="keywordflow">else</span> {
        <a class="code" href="struct_o_s_p_f_1_1_i_pv4_address.html">OSPF::IPv4Address</a> existingMask = <a class="code" href="_o_s_p_fcommon_8h.html#a5206656cf4131a17505ee9db0a60ddb6">IPv4AddressFromULong</a>(foundLSA-&gt;getContents().getNetworkMask().getInt());

        <span class="keywordflow">if</span> (destination.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a452878c3f507f27d1de9c5b7cda2ae70">mask</a> &gt;= existingMask) {
            <span class="keywordflow">return</span> (lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a> | (~(<a class="code" href="_o_s_p_fcommon_8h.html#a4da9e68bb3ffcba090d1b07a5f812ce3">ULongFromIPv4Address</a>(destination.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a452878c3f507f27d1de9c5b7cda2ae70">mask</a>))));
        } <span class="keywordflow">else</span> {
            <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>* asExternalLSA = <span class="keyword">new</span> <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>(*foundLSA);

            <span class="keywordtype">long</span> sequenceNumber = asExternalLSA-&gt;getHeader().getLsSequenceNumber();

            asExternalLSA-&gt;getHeader().setLsAge(0);
            asExternalLSA-&gt;getHeader().setLsSequenceNumber((sequenceNumber == <a class="code" href="_o_s_p_fcommon_8h.html#a35f49b34e56993fe20d3a21d144c16d3">MAX_SEQUENCE_NUMBER</a>) ? <a class="code" href="_o_s_p_fcommon_8h.html#ad441394da087bc61e24a5b99455c5589">INITIAL_SEQUENCE_NUMBER</a> : sequenceNumber + 1);
            asExternalLSA-&gt;getContents().setNetworkMask(<a class="code" href="_o_s_p_fcommon_8h.html#a4da9e68bb3ffcba090d1b07a5f812ce3">ULongFromIPv4Address</a>(destination.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a452878c3f507f27d1de9c5b7cda2ae70">mask</a>));
            asExternalLSA-&gt;getContents().setE_ExternalMetricType(externalMetricIsType2);
            asExternalLSA-&gt;getContents().setRouteCost(destinationCost);
            asExternalLSA-&gt;getHeader().setLsChecksum(0);    <span class="comment">// TODO: calculate correct LS checksum</span>

            lsaToReoriginate = asExternalLSA;

            <span class="keywordflow">return</span> (lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a> | (~(<a class="code" href="_o_s_p_fcommon_8h.html#a4da9e68bb3ffcba090d1b07a5f812ce3">ULongFromIPv4Address</a>(existingMask))));
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2ac64ff56b3bcde574fde26a5247286d"></a><!-- doxytag: member="OSPF::Router::HasAddressRange" ref="a2ac64ff56b3bcde574fde26a5247286d" args="(IPv4AddressRange addressRange) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OSPF::Router::HasAddressRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">OSPF::IPv4AddressRange</a>&#160;</td>
          <td class="paramname"><em>addressRange</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if one of the Router's Areas the same <a class="el" href="class_i_p.html">IP</a> address range configured as the input <a class="el" href="class_i_p.html">IP</a> address range, false otherwise. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">addressRange</td><td>[in] The <a class="el" href="class_i_p.html">IP</a> address range to look for. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
        <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;<a class="code" href="class_o_s_p_f_1_1_router.html#a2ac64ff56b3bcde574fde26a5247286d">HasAddressRange</a>(addressRange)) {
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="afc4272a1f634c3329523df334e67aa3c"></a><!-- doxytag: member="OSPF::Router::HasAnyNeighborInStates" ref="afc4272a1f634c3329523df334e67aa3c" args="(int states) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OSPF::Router::HasAnyNeighborInStates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>states</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if any <a class="el" href="class_o_s_p_f_1_1_neighbor.html">Neighbor</a> on any <a class="el" href="class_o_s_p_f_1_1_interface.html">Interface</a> in any of the Router's Areas is in any of the input states, false otherwise. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">states</td><td>[in] A bitfield combination of NeighborStateType values. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
        <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;<a class="code" href="class_o_s_p_f_1_1_router.html#afc4272a1f634c3329523df334e67aa3c">HasAnyNeighborInStates</a>(states)) {
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5bb62fe635f3bbe881e9917564334751"></a><!-- doxytag: member="OSPF::Router::HasRouteToASBoundaryRouter" ref="a5bb62fe635f3bbe881e9917564334751" args="(const std::vector&lt; RoutingTableEntry * &gt; &amp;inRoutingTable, OSPF::RouterID routerID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OSPF::Router::HasRouteToASBoundaryRouter </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>inRoutingTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_p_f.html#ad64f22839cca7ec05fee5b7596411197">OSPF::RouterID</a>&#160;</td>
          <td class="paramname"><em>routerID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if there is a route to the AS Boundary <a class="el" href="class_o_s_p_f_1_1_router.html">Router</a> identified by asbrRouterID in the input inRoutingTable, false otherwise. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inRoutingTable</td><td>[in] The routing table to look in. </td></tr>
    <tr><td class="paramname">asbrRouterID</td><td>[in] The ID of the AS Boundary <a class="el" href="class_o_s_p_f_1_1_router.html">Router</a> to look for. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> routeCount = inRoutingTable.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; routeCount; i++) {
        <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* routingEntry = inRoutingTable[i];
        <span class="keywordflow">if</span> (((routingEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ad8499eafeaedf12631fcf23389edaf44">GetDestinationType</a>() &amp; <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a5d17313f8ef2882f4e6c84dfbfb07a16">OSPF::RoutingTableEntry::ASBoundaryRouterDestination</a>) != 0) &amp;&amp;
            (routingEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aabd6e43c5ef3feb40a60b6c03163c2a7">GetDestinationID</a>().<a class="code" href="class_i_p_address.html#a807ca46964a8403cf0c70f0772179524">getInt</a>() == asbrRouterID))
        {
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8615120ec6c21bfd812b533e5532ddcb"></a><!-- doxytag: member="OSPF::Router::InstallASExternalLSA" ref="a8615120ec6c21bfd812b533e5532ddcb" args="(OSPFASExternalLSA *lsa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OSPF::Router::InstallASExternalLSA </td>
          <td>(</td>
          <td class="paramtype">OSPFASExternalLSA *&#160;</td>
          <td class="paramname"><em>lsa</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Installs a new AS External LSA into the Router's database. It tries to install keep one of multiple functionally equivalent AS External LSAs in the database. (See the comment in the method implementation.) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsa</td><td>[in] The LSA to install. It will be copied into the database. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the routing table needs to be updated, false otherwise. </dd></dl>

<p><p>From RFC2328 Section 12.4.4.1.: "If two routers, both reachable from one another, originate functionally equivalent AS-External-LSAs(i.e., same destination, cost and non-zero forwarding address), then the LSA originated by the router having the highest <a class="el" href="namespace_o_s_p_f.html">OSPF</a> <a class="el" href="class_o_s_p_f_1_1_router.html">Router</a> ID is used. The router having the lower <a class="el" href="namespace_o_s_p_f.html">OSPF</a> <a class="el" href="class_o_s_p_f_1_1_router.html">Router</a> ID can then flush its LSA." The problem is: how do we tell whether two routers are reachable from one another based on a Link State Update packet? 0. We can assume that if this LSA reached this router, then this router is reachable from the other router. But what about the other direction? 1. The update packet is most likely not sent by the router originating the functionally equivalent AS-External-LSA, so we cannot use the <a class="el" href="class_i_p.html">IP</a> packet source address. 2. The AS-External-LSA contains only the <a class="el" href="class_o_s_p_f_1_1_router.html">Router</a> ID of the advertising router, so we can only look up "router" type routing entries in the routing table(these contain the <a class="el" href="class_o_s_p_f_1_1_router.html">Router</a> ID as their Destination ID). However these entries are only inserted into the routing table for intra-area routers...</p>
</p>
<div class="fragment"><pre class="fragment">{
     <span class="comment">// TODO: how to solve this problem?</span>

    <a class="code" href="namespace_o_s_p_f.html#ad64f22839cca7ec05fee5b7596411197">OSPF::RouterID</a> advertisingRouter = lsa-&gt;getHeader().getAdvertisingRouter().getInt();
    <span class="keywordtype">bool</span>           reachable         = <span class="keyword">false</span>;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   routeCount        = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.size();

    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; routeCount; i++) {
        <span class="keywordflow">if</span> ((((<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]-&gt;GetDestinationType() &amp; <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#af92c5c5be248300e9c778f1a87dda704">OSPF::RoutingTableEntry::AreaBorderRouterDestination</a>) != 0) ||
             ((<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]-&gt;GetDestinationType() &amp; <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a5d17313f8ef2882f4e6c84dfbfb07a16">OSPF::RoutingTableEntry::ASBoundaryRouterDestination</a>) != 0)) &amp;&amp;
            (<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]-&gt;GetDestinationID().getInt() == advertisingRouter))
        {
            reachable = <span class="keyword">true</span>;
            <span class="keywordflow">break</span>;
        }
    }

    <span class="keywordtype">bool</span>             ownLSAFloodedOut = <span class="keyword">false</span>;
    <a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a> lsaKey;

    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a> = lsa-&gt;getHeader().getLinkStateID();
    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>;

    std::map&lt;OSPF::LSAKeyType, OSPF::ASExternalLSA*, OSPF::LSAKeyType_Less&gt;::iterator lsaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.find(lsaKey);
    <span class="keywordflow">if</span> ((lsaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.end()) &amp;&amp;
        reachable &amp;&amp;
        (lsaIt-&gt;second-&gt;getContents().getE_ExternalMetricType() == lsa-&gt;getContents().getE_ExternalMetricType()) &amp;&amp;
        (lsaIt-&gt;second-&gt;getContents().getRouteCost() == lsa-&gt;getContents().getRouteCost()) &amp;&amp;
        (lsa-&gt;getContents().getForwardingAddress().getInt() != 0) &amp;&amp;   <span class="comment">// forwarding address != 0.0.0.0</span>
        (lsaIt-&gt;second-&gt;getContents().getForwardingAddress() == lsa-&gt;getContents().getForwardingAddress()))
    {
        <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a> &gt; advertisingRouter) {
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
        } <span class="keywordflow">else</span> {
            lsaIt-&gt;second-&gt;getHeader().setLsAge(<a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a>);
            <a class="code" href="class_o_s_p_f_1_1_router.html#a2cfb1ebf041766dadf2fcd6e1fdebe27">FloodLSA</a>(lsaIt-&gt;second, <a class="code" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">OSPF::BackboneAreaID</a>);
            lsaIt-&gt;second-&gt;IncrementInstallTime();
            ownLSAFloodedOut = <span class="keyword">true</span>;
        }
    }

    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = advertisingRouter;

    lsaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.find(lsaKey);
    <span class="keywordflow">if</span> (lsaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.end()) {
        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
            <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;RemoveFromAllRetransmissionLists(lsaKey);
        }
        <span class="keywordflow">return</span> ((lsaIt-&gt;second-&gt;Update(lsa)) | ownLSAFloodedOut);
    } <span class="keywordflow">else</span> {
        <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>* lsaCopy = <span class="keyword">new</span> <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>(*lsa);
        <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>[lsaKey] = lsaCopy;
        <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>.push_back(lsaCopy);
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0b35533c0a9820cdd8887d5812c2db9b"></a><!-- doxytag: member="OSPF::Router::InstallLSA" ref="a0b35533c0a9820cdd8887d5812c2db9b" args="(OSPFLSA *lsa, AreaID areaID=BackboneAreaID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OSPF::Router::InstallLSA </td>
          <td>(</td>
          <td class="paramtype">OSPFLSA *&#160;</td>
          <td class="paramname"><em>lsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_p_f.html#a8d10c460f2da4aae5dd61d2a082dfc56">OSPF::AreaID</a>&#160;</td>
          <td class="paramname"><em>areaID</em> = <code><a class="el" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">BackboneAreaID</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Installs a new LSA into the <a class="el" href="class_o_s_p_f_1_1_router.html">Router</a> database. Checks the input LSA's type and installs it into either the selected Area's database, or if it's an AS External LSA then into the Router's common asExternalLSAs list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsa</td><td>[in] The LSA to install. It will be copied into the database. </td></tr>
    <tr><td class="paramname">areaID</td><td>[in] Identifies the input <a class="el" href="class_o_s_p_f_1_1_router.html">Router</a>, Network and Summary LSA's <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the routing table needs to be updated, false otherwise. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">switch</span> (lsa-&gt;getHeader().getLsType()) {
        <span class="keywordflow">case</span> RouterLSAType:
            {
                std::map&lt;OSPF::AreaID, OSPF::Area*&gt;::iterator areaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.find(areaID);
                <span class="keywordflow">if</span> (areaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.end()) {
                    OSPFRouterLSA* ospfRouterLSA = check_and_cast&lt;OSPFRouterLSA*&gt; (lsa);
                    <span class="keywordflow">return</span> areaIt-&gt;second-&gt;InstallRouterLSA(ospfRouterLSA);
                }
            }
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> NetworkLSAType:
            {
                std::map&lt;OSPF::AreaID, OSPF::Area*&gt;::iterator areaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.find(areaID);
                <span class="keywordflow">if</span> (areaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.end()) {
                    OSPFNetworkLSA* ospfNetworkLSA = check_and_cast&lt;OSPFNetworkLSA*&gt; (lsa);
                    <span class="keywordflow">return</span> areaIt-&gt;second-&gt;InstallNetworkLSA(ospfNetworkLSA);
                }
            }
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> SummaryLSA_NetworksType:
        <span class="keywordflow">case</span> SummaryLSA_ASBoundaryRoutersType:
            {
                std::map&lt;OSPF::AreaID, OSPF::Area*&gt;::iterator areaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.find(areaID);
                <span class="keywordflow">if</span> (areaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.end()) {
                    OSPFSummaryLSA* ospfSummaryLSA = check_and_cast&lt;OSPFSummaryLSA*&gt; (lsa);
                    <span class="keywordflow">return</span> areaIt-&gt;second-&gt;InstallSummaryLSA(ospfSummaryLSA);
                }
            }
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> ASExternalLSAType:
            {
                OSPFASExternalLSA* ospfASExternalLSA = check_and_cast&lt;OSPFASExternalLSA*&gt; (lsa);
                <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a8615120ec6c21bfd812b533e5532ddcb">InstallASExternalLSA</a>(ospfASExternalLSA);
            }
            <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>:
            ASSERT(<span class="keyword">false</span>);
            <span class="keywordflow">break</span>;
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad3bfc2d2a7560d2ba946288aa241725b"></a><!-- doxytag: member="OSPF::Router::IsDestinationUnreachable" ref="ad3bfc2d2a7560d2ba946288aa241725b" args="(OSPFLSA *lsa) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OSPF::Router::IsDestinationUnreachable </td>
          <td>(</td>
          <td class="paramtype">OSPFLSA *&#160;</td>
          <td class="paramname"><em>lsa</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the destination described by the input lsa is in the routing table, false otherwise. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsa</td><td>[in] The LSA which describes the destination to look for. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_i_p_address.html">IPAddress</a> destination = lsa-&gt;getHeader().getLinkStateID();

    OSPFRouterLSA* routerLSA         = <span class="keyword">dynamic_cast&lt;</span>OSPFRouterLSA*<span class="keyword">&gt;</span> (lsa);
    OSPFNetworkLSA* networkLSA       = <span class="keyword">dynamic_cast&lt;</span>OSPFNetworkLSA*<span class="keyword">&gt;</span> (lsa);
    OSPFSummaryLSA* summaryLSA       = <span class="keyword">dynamic_cast&lt;</span>OSPFSummaryLSA*<span class="keyword">&gt;</span> (lsa);
    OSPFASExternalLSA* asExternalLSA = <span class="keyword">dynamic_cast&lt;</span>OSPFASExternalLSA*<span class="keyword">&gt;</span> (lsa);
    <span class="comment">// TODO: verify</span>
    <span class="keywordflow">if</span> (routerLSA != NULL) {
        <a class="code" href="class_o_s_p_f_1_1_routing_info.html">OSPF::RoutingInfo</a>* routingInfo = check_and_cast&lt;<a class="code" href="class_o_s_p_f_1_1_routing_info.html">OSPF::RoutingInfo</a>*&gt; (routerLSA);
        <span class="keywordflow">if</span> (routerLSA-&gt;getHeader().getLinkStateID() == <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>) { <span class="comment">// this is spfTreeRoot</span>
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
        }

        <span class="comment">// get the interface address pointing backwards on the shortest path tree</span>
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     linkCount   = routerLSA-&gt;getLinksArraySize();
        <a class="code" href="class_o_s_p_f_1_1_router_l_s_a.html">OSPF::RouterLSA</a>* toRouterLSA = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_o_s_p_f_1_1_router_l_s_a.html">OSPF::RouterLSA</a>*<span class="keyword">&gt;</span> (routingInfo-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_info.html#acec4ddb814bd218432c247cf32912f48">GetParent</a>());
        <span class="keywordflow">if</span> (toRouterLSA != NULL) {
            <span class="keywordtype">bool</span>      destinationFound           = <span class="keyword">false</span>;
            <span class="keywordtype">bool</span>      unnumberedPointToPointLink = <span class="keyword">false</span>;
            <a class="code" href="class_i_p_address.html">IPAddress</a> firstNumberedIfAddress;

            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; linkCount; i++) {
                Link&amp; link = routerLSA-&gt;getLinks(i);

                <span class="keywordflow">if</span> (link.getType() == PointToPointLink) {
                    <span class="keywordflow">if</span> (link.getLinkID() == toRouterLSA-&gt;getHeader().getLinkStateID()) {
                        <span class="keywordflow">if</span> ((link.getLinkData() &amp; 0xFF000000) == 0) {
                            unnumberedPointToPointLink = <span class="keyword">true</span>;
                            <span class="keywordflow">if</span> (!firstNumberedIfAddress.<a class="code" href="class_i_p_address.html#a7fb3c274d7a8600be890f83c028d5f96">isUnspecified</a>()) {
                                <span class="keywordflow">break</span>;
                            }
                        } <span class="keywordflow">else</span> {
                            destination = link.getLinkData();
                            destinationFound = <span class="keyword">true</span>;
                            <span class="keywordflow">break</span>;
                        }
                    } <span class="keywordflow">else</span> {
                        <span class="keywordflow">if</span> (((link.getLinkData() &amp; 0xFF000000) != 0) &amp;&amp;
                             firstNumberedIfAddress.<a class="code" href="class_i_p_address.html#a7fb3c274d7a8600be890f83c028d5f96">isUnspecified</a>())
                        {
                            firstNumberedIfAddress = link.getLinkData();
                        }
                    }
                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (link.getType() == TransitLink) {
                    <span class="keywordflow">if</span> (firstNumberedIfAddress.<a class="code" href="class_i_p_address.html#a7fb3c274d7a8600be890f83c028d5f96">isUnspecified</a>()) {
                        firstNumberedIfAddress = link.getLinkData();
                    }
                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (link.getType() == VirtualLink) {
                    <span class="keywordflow">if</span> (link.getLinkID() == toRouterLSA-&gt;getHeader().getLinkStateID()) {
                        destination = link.getLinkData();
                        destinationFound = <span class="keyword">true</span>;
                        <span class="keywordflow">break</span>;
                    } <span class="keywordflow">else</span> {
                        <span class="keywordflow">if</span> (firstNumberedIfAddress.<a class="code" href="class_i_p_address.html#a7fb3c274d7a8600be890f83c028d5f96">isUnspecified</a>()) {
                            firstNumberedIfAddress = link.getLinkData();
                        }
                    }
                }
                <span class="comment">// There&#39;s no way to get an interface address for the router from a StubLink</span>
            }
            <span class="keywordflow">if</span> (unnumberedPointToPointLink) {
                <span class="keywordflow">if</span> (!firstNumberedIfAddress.<a class="code" href="class_i_p_address.html#a7fb3c274d7a8600be890f83c028d5f96">isUnspecified</a>()) {
                    destination = firstNumberedIfAddress;
                } <span class="keywordflow">else</span> {
                    <span class="keywordflow">return</span> <span class="keyword">true</span>;
                }
            }
            <span class="keywordflow">if</span> (!destinationFound) {
                <span class="keywordflow">return</span> <span class="keyword">true</span>;
            }
        } <span class="keywordflow">else</span> {
            <a class="code" href="class_o_s_p_f_1_1_network_l_s_a.html">OSPF::NetworkLSA</a>* toNetworkLSA = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_o_s_p_f_1_1_network_l_s_a.html">OSPF::NetworkLSA</a>*<span class="keyword">&gt;</span> (routingInfo-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_info.html#acec4ddb814bd218432c247cf32912f48">GetParent</a>());
            <span class="keywordflow">if</span> (toNetworkLSA != NULL) {
                <span class="comment">// get the interface address pointing backwards on the shortest path tree</span>
                <span class="keywordtype">bool</span> destinationFound = <span class="keyword">false</span>;
                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; linkCount; i++) {
                    Link&amp; link = routerLSA-&gt;getLinks(i);

                    <span class="keywordflow">if</span> ((link.getType() == TransitLink) &amp;&amp;
                        (link.getLinkID() == toNetworkLSA-&gt;getHeader().getLinkStateID()))
                    {
                        destination = link.getLinkData();
                        destinationFound = <span class="keyword">true</span>;
                        <span class="keywordflow">break</span>;
                    }
                }
                <span class="keywordflow">if</span> (!destinationFound) {
                    <span class="keywordflow">return</span> <span class="keyword">true</span>;
                }
            } <span class="keywordflow">else</span> {
                <span class="keywordflow">return</span> <span class="keyword">true</span>;
            }
        }
    }
    <span class="keywordflow">if</span> (networkLSA != NULL) {
        destination = networkLSA-&gt;getHeader().getLinkStateID() &amp; networkLSA-&gt;<a class="code" href="class_i_p_address.html#a3ec6972662238953d5704539601e9ecc">getNetworkMask</a>().<a class="code" href="class_i_p_address.html#a807ca46964a8403cf0c70f0772179524">getInt</a>();
    }
    <span class="keywordflow">if</span> ((summaryLSA != NULL) &amp;&amp; (summaryLSA-&gt;getHeader().getLsType() == SummaryLSA_NetworksType)) {
        destination = summaryLSA-&gt;getHeader().getLinkStateID() &amp; summaryLSA-&gt;<a class="code" href="class_i_p_address.html#a3ec6972662238953d5704539601e9ecc">getNetworkMask</a>().<a class="code" href="class_i_p_address.html#a807ca46964a8403cf0c70f0772179524">getInt</a>();
    }
    <span class="keywordflow">if</span> (asExternalLSA != NULL) {
        destination = asExternalLSA-&gt;getHeader().getLinkStateID() &amp; asExternalLSA-&gt;getContents().<a class="code" href="class_i_p_address.html#a3ec6972662238953d5704539601e9ecc">getNetworkMask</a>().<a class="code" href="class_i_p_address.html#a807ca46964a8403cf0c70f0772179524">getInt</a>();
    }

    <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a99174613edc2cf3b3305ff55b67ec173">Lookup</a>(destination) == NULL) {
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    } <span class="keywordflow">else</span> {
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1e457a90074dfce50e04ba85571ccff6"></a><!-- doxytag: member="OSPF::Router::IsLocalAddress" ref="a1e457a90074dfce50e04ba85571ccff6" args="(IPv4Address address) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OSPF::Router::IsLocalAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_p_f_1_1_i_pv4_address.html">OSPF::IPv4Address</a>&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the input <a class="el" href="class_i_p.html">IP</a> address falls into any of the Router's Areas' configured <a class="el" href="class_i_p.html">IP</a> address ranges, false otherwise. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>[in] The <a class="el" href="class_i_p.html">IP</a> address to look for. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
        <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;<a class="code" href="class_o_s_p_f_1_1_router.html#a1e457a90074dfce50e04ba85571ccff6">IsLocalAddress</a>(address)) {
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aae605eb327107bfecd3b8f2307f788f4"></a><!-- doxytag: member="OSPF::Router::IsOnAnyRetransmissionList" ref="aae605eb327107bfecd3b8f2307f788f4" args="(LSAKeyType lsaKey) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OSPF::Router::IsOnAnyRetransmissionList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a>&#160;</td>
          <td class="paramname"><em>lsaKey</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if there's at least one LSA on any Neighbor's retransmission list identified by the input lsaKey, false otherwise. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsaKey</td><td>[in] Identifies the LSAs to look for on the retransmission lists. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
        <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;<a class="code" href="class_o_s_p_f_1_1_router.html#aae605eb327107bfecd3b8f2307f788f4">IsOnAnyRetransmissionList</a>(lsaKey)) {
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a99174613edc2cf3b3305ff55b67ec173"></a><!-- doxytag: member="OSPF::Router::Lookup" ref="a99174613edc2cf3b3305ff55b67ec173" args="(IPAddress destination, std::vector&lt; RoutingTableEntry * &gt; *table=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a> * OSPF::Router::Lookup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_p_address.html">IPAddress</a>&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; *&#160;</td>
          <td class="paramname"><em>table</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Do a lookup in either the input <a class="el" href="namespace_o_s_p_f.html">OSPF</a> routing table, or if it's NULL then in the Router's own routing table. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>RFC2328 Section 11.1. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>[in] The destination to look up in the routing table. </td></tr>
    <tr><td class="paramname">table</td><td>[in] The routing table to do the lookup in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> describing the input destination if there's one, false otherwise. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> std::vector&lt;OSPF::RoutingTableEntry*&gt;&amp; rTable           = (table == NULL) ? <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a> : (*table);
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>                                dest             = destination.<a class="code" href="class_i_p_address.html#a807ca46964a8403cf0c70f0772179524">getInt</a>();
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>                                routingTableSize = rTable.size();
    <span class="keywordtype">bool</span>                                         unreachable      = <span class="keyword">false</span>;
    std::vector&lt;OSPF::RoutingTableEntry*&gt;        discard;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>                                i;

    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (i = 0; i &lt; areaCount; i++) {
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> addressRangeCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;GetAddressRangeCount();
        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; addressRangeCount; j++) {
            <a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">OSPF::IPv4AddressRange</a> range = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;GetAddressRange(j);

            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; routingTableSize; k++) {
                <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* entry = rTable[k];

                <span class="keywordflow">if</span> (entry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ad8499eafeaedf12631fcf23389edaf44">GetDestinationType</a>() != <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aaf930613a21a30bef97cab3284d0648f">OSPF::RoutingTableEntry::NetworkDestination</a>) {
                    <span class="keywordflow">continue</span>;
                }
                <span class="keywordflow">if</span> (((entry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aabd6e43c5ef3feb40a60b6c03163c2a7">GetDestinationID</a>().<a class="code" href="class_i_p_address.html#a807ca46964a8403cf0c70f0772179524">getInt</a>() &amp; entry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a9810faee6aeee3f09397f43d6b204703">GetAddressMask</a>().<a class="code" href="class_i_p_address.html#a807ca46964a8403cf0c70f0772179524">getInt</a>() &amp; <a class="code" href="_o_s_p_fcommon_8h.html#a4da9e68bb3ffcba090d1b07a5f812ce3">ULongFromIPv4Address</a>(range.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a452878c3f507f27d1de9c5b7cda2ae70">mask</a>)) == <a class="code" href="_o_s_p_fcommon_8h.html#a4da9e68bb3ffcba090d1b07a5f812ce3">ULongFromIPv4Address</a>(range.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a74993d6571119644535ac918c4240722">address</a> &amp; range.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a452878c3f507f27d1de9c5b7cda2ae70">mask</a>)) &amp;&amp;
                    (entry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ae6952c69005f7d3d6421ea52439c776e">GetPathType</a>() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254aada3ad1646360d0d106905c77733f600">OSPF::RoutingTableEntry::IntraArea</a>))
                {
                    <span class="comment">// active area address range</span>
                    <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* discardEntry = <span class="keyword">new</span> <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>;
                    discardEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ae75063f049d56aa1209e02e0767c170c">SetDestinationID</a>(<a class="code" href="_o_s_p_fcommon_8h.html#a4da9e68bb3ffcba090d1b07a5f812ce3">ULongFromIPv4Address</a>(range.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a74993d6571119644535ac918c4240722">address</a>));
                    discardEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#affeb736e63b6a2387d9a3c9ee23baa35">SetAddressMask</a>(<a class="code" href="_o_s_p_fcommon_8h.html#a4da9e68bb3ffcba090d1b07a5f812ce3">ULongFromIPv4Address</a>(range.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a452878c3f507f27d1de9c5b7cda2ae70">mask</a>));
                    discardEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a6f721739fbc1c2a18341afb4d8916db6">SetDestinationType</a>(<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aaf930613a21a30bef97cab3284d0648f">OSPF::RoutingTableEntry::NetworkDestination</a>);
                    discardEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a7ca15b35b5d0c9d2818ba07ef50b7419">SetPathType</a>(<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a9e19536f5d4fede2389e66c6ff4969fa">OSPF::RoutingTableEntry::InterArea</a>);
                    discardEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a8af24090ee7cfa811b46e2aed1d282a5">SetArea</a>(<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;GetAreaID());
                    discard.push_back(discardEntry);
                    <span class="keywordflow">break</span>;
                }
            }
        }
    }

    <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* bestMatch = NULL;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>            longestMatch = 0;

    <span class="keywordflow">for</span> (i = 0; i &lt; routingTableSize; i++) {
        <span class="keywordflow">if</span> (rTable[i]-&gt;GetDestinationType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aaf930613a21a30bef97cab3284d0648f">OSPF::RoutingTableEntry::NetworkDestination</a>) {
            <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* entry        = rTable[i];
            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>            entryAddress = entry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aabd6e43c5ef3feb40a60b6c03163c2a7">GetDestinationID</a>().<a class="code" href="class_i_p_address.html#a807ca46964a8403cf0c70f0772179524">getInt</a>();
            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>            entryMask    = entry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a9810faee6aeee3f09397f43d6b204703">GetAddressMask</a>().<a class="code" href="class_i_p_address.html#a807ca46964a8403cf0c70f0772179524">getInt</a>();

            <span class="keywordflow">if</span> ((entryAddress &amp; entryMask) == (dest &amp; entryMask)) {
                <span class="keywordflow">if</span> ((dest &amp; entryMask) &gt; longestMatch) {
                    longestMatch = (dest &amp; entryMask);
                    bestMatch    = entry;
                }
            }
        }
    }

    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> discardCount = discard.size();
    <span class="keywordflow">if</span> (bestMatch == NULL) {
        unreachable = <span class="keyword">true</span>;
    } <span class="keywordflow">else</span> {
        <span class="keywordflow">for</span> (i = 0; i &lt; discardCount; i++) {
            <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* entry        = discard[i];
            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>            entryAddress = entry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aabd6e43c5ef3feb40a60b6c03163c2a7">GetDestinationID</a>().<a class="code" href="class_i_p_address.html#a807ca46964a8403cf0c70f0772179524">getInt</a>();
            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>            entryMask    = entry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a9810faee6aeee3f09397f43d6b204703">GetAddressMask</a>().<a class="code" href="class_i_p_address.html#a807ca46964a8403cf0c70f0772179524">getInt</a>();

            <span class="keywordflow">if</span> ((entryAddress &amp; entryMask) == (dest &amp; entryMask)) {
                <span class="keywordflow">if</span> ((dest &amp; entryMask) &gt; longestMatch) {
                    unreachable = <span class="keyword">true</span>;
                    <span class="keywordflow">break</span>;
                }
            }
        }
    }

    <span class="keywordflow">for</span> (i = 0; i &lt; discardCount; i++) {
        <span class="keyword">delete</span> discard[i];
    }

    <span class="keywordflow">if</span> (unreachable) {
        <span class="keywordflow">return</span> NULL;
    } <span class="keywordflow">else</span> {
        <span class="keywordflow">return</span> bestMatch;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a57df70b2d8008b2ea1827e06ab750500"></a><!-- doxytag: member="OSPF::Router::NotifyAboutRoutingTableChanges" ref="a57df70b2d8008b2ea1827e06ab750500" args="(std::vector&lt; RoutingTableEntry * &gt; &amp;oldRoutingTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OSPF::Router::NotifyAboutRoutingTableChanges </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldRoutingTable</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After a routing table rebuild the changes in the routing table are identified and new SummaryLSAs are originated or old ones are flooded out in each area as necessary. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">oldRoutingTable</td><td>[in] The previous version of the routing table(which is then compared with the one in routingTable). </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>RFC2328 Section 12.4. points(5) through(6). </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size() &lt;= 1) {
        <span class="keywordflow">return</span>;
    }

    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>                                 routeCount = oldRoutingTable.size();
    std::map&lt;unsigned long, RoutingTableEntry*&gt;   oldTableMap;
    std::map&lt;unsigned long, RoutingTableEntry*&gt;   newTableMap;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>                                 i, j, k;

    <span class="keywordflow">for</span> (i = 0; i &lt; routeCount; i++) {
        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> destination = oldRoutingTable[i]-&gt;GetDestinationID().getInt() &amp; oldRoutingTable[i]-&gt;GetAddressMask().getInt();
        oldTableMap[destination] = oldRoutingTable[i];
    }

    routeCount = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.size();
    <span class="keywordflow">for</span> (i = 0; i &lt; routeCount; i++) {
        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>   destination = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]-&gt;GetDestinationID().getInt() &amp; <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]-&gt;GetAddressMask().getInt();
        newTableMap[destination] = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i];
    }

    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (i = 0; i &lt; areaCount; i++) {
        std::map&lt;OSPF::LSAKeyType, bool, OSPF::LSAKeyType_Less&gt; originatedLSAMap;
        std::map&lt;OSPF::LSAKeyType, bool, OSPF::LSAKeyType_Less&gt; deletedLSAMap;
        <a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a>                                        lsaKey;

        routeCount = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.size();
        <span class="keywordflow">for</span> (j = 0; j &lt; routeCount; j++) {
            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>                                         destination = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]-&gt;GetDestinationID().getInt() &amp; <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]-&gt;GetAddressMask().getInt();
            std::map&lt;unsigned long, RoutingTableEntry*&gt;::iterator destIt      = oldTableMap.find(destination);
            <span class="keywordflow">if</span> (destIt == oldTableMap.end()) { <span class="comment">// new routing entry</span>
                <a class="code" href="class_o_s_p_f_1_1_summary_l_s_a.html">OSPF::SummaryLSA</a>* lsaToReoriginate = NULL;
                <a class="code" href="class_o_s_p_f_1_1_summary_l_s_a.html">OSPF::SummaryLSA</a>* newLSA           = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;OriginateSummaryLSA(<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j], originatedLSAMap, lsaToReoriginate);

                <span class="keywordflow">if</span> (newLSA != NULL) {
                    <span class="keywordflow">if</span> (lsaToReoriginate != NULL) {
                        <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;InstallSummaryLSA(lsaToReoriginate);
<span class="comment">//                        FloodLSA(lsaToReoriginate, OSPF::BackboneAreaID);</span>
                        <a class="code" href="class_o_s_p_f_1_1_router.html#a2cfb1ebf041766dadf2fcd6e1fdebe27">FloodLSA</a>(lsaToReoriginate, <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;GetAreaID());

                        lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a>       = lsaToReoriginate-&gt;getHeader().getLinkStateID();
                        lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>;
                        originatedLSAMap[lsaKey] = <span class="keyword">true</span>;

                        <span class="keyword">delete</span> lsaToReoriginate;
                    }

                    <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;InstallSummaryLSA(newLSA);
<span class="comment">//                    FloodLSA(newLSA, OSPF::BackboneAreaID);</span>
                    <a class="code" href="class_o_s_p_f_1_1_router.html#a2cfb1ebf041766dadf2fcd6e1fdebe27">FloodLSA</a>(newLSA, <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;GetAreaID());

                    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a>       = newLSA-&gt;getHeader().getLinkStateID();
                    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>;
                    originatedLSAMap[lsaKey] = <span class="keyword">true</span>;

                    <span class="keyword">delete</span> newLSA;
                }
            } <span class="keywordflow">else</span> {
                <span class="keywordflow">if</span> (*(<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]) != *(destIt-&gt;second)) {  <span class="comment">// modified routing entry</span>
                    <a class="code" href="class_o_s_p_f_1_1_summary_l_s_a.html">OSPF::SummaryLSA</a>* lsaToReoriginate = NULL;
                    <a class="code" href="class_o_s_p_f_1_1_summary_l_s_a.html">OSPF::SummaryLSA</a>* newLSA           = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;OriginateSummaryLSA(<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j], originatedLSAMap, lsaToReoriginate);

                    <span class="keywordflow">if</span> (newLSA != NULL) {
                        <span class="keywordflow">if</span> (lsaToReoriginate != NULL) {
                            <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;InstallSummaryLSA(lsaToReoriginate);
<span class="comment">//                            FloodLSA(lsaToReoriginate, OSPF::BackboneAreaID);</span>
                            <a class="code" href="class_o_s_p_f_1_1_router.html#a2cfb1ebf041766dadf2fcd6e1fdebe27">FloodLSA</a>(lsaToReoriginate, <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;GetAreaID());

                            lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a>       = lsaToReoriginate-&gt;getHeader().getLinkStateID();
                            lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>;
                            originatedLSAMap[lsaKey] = <span class="keyword">true</span>;

                            <span class="keyword">delete</span> lsaToReoriginate;
                        }

                        <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;InstallSummaryLSA(newLSA);
<span class="comment">//                        FloodLSA(newLSA, OSPF::BackboneAreaID);</span>
                        <a class="code" href="class_o_s_p_f_1_1_router.html#a2cfb1ebf041766dadf2fcd6e1fdebe27">FloodLSA</a>(newLSA, <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;GetAreaID());

                        lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a>       = newLSA-&gt;getHeader().getLinkStateID();
                        lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>;
                        originatedLSAMap[lsaKey] = <span class="keyword">true</span>;

                        <span class="keyword">delete</span> newLSA;
                    } <span class="keywordflow">else</span> {
                        <a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">OSPF::IPv4AddressRange</a> destinationAddressRange;

                        destinationAddressRange.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a74993d6571119644535ac918c4240722">address</a> = <a class="code" href="_o_s_p_fcommon_8h.html#a5206656cf4131a17505ee9db0a60ddb6">IPv4AddressFromULong</a>(<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]-&gt;GetDestinationID().getInt());
                        destinationAddressRange.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a452878c3f507f27d1de9c5b7cda2ae70">mask</a> = <a class="code" href="_o_s_p_fcommon_8h.html#a5206656cf4131a17505ee9db0a60ddb6">IPv4AddressFromULong</a>(<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]-&gt;GetAddressMask().getInt());

                        <span class="keywordflow">if</span> ((<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]-&gt;GetDestinationType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aaf930613a21a30bef97cab3284d0648f">OSPF::RoutingTableEntry::NetworkDestination</a>) &amp;&amp;
                            ((<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]-&gt;GetPathType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254aada3ad1646360d0d106905c77733f600">OSPF::RoutingTableEntry::IntraArea</a>) ||
                             (<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]-&gt;GetPathType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a9e19536f5d4fede2389e66c6ff4969fa">OSPF::RoutingTableEntry::InterArea</a>)))
                        {
                            <a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">OSPF::IPv4AddressRange</a> containingAddressRange = <a class="code" href="class_o_s_p_f_1_1_router.html#a9a35624ca66179bda14774a1fbdc44bf">GetContainingAddressRange</a>(destinationAddressRange);
                            <span class="keywordflow">if</span> (containingAddressRange != <a class="code" href="namespace_o_s_p_f.html#ad8bce8fb1420d6747aba9a122e7300ea">OSPF::NullIPv4AddressRange</a>) {
                                destinationAddressRange = containingAddressRange;
                            }
                        }

                        <a class="code" href="namespace_o_s_p_f.html#a4a99812a2d079df0f7208f2740cdb0ad">Metric</a> maxRangeCost = 0;
                        <a class="code" href="namespace_o_s_p_f.html#a4a99812a2d079df0f7208f2740cdb0ad">Metric</a> oneLessCost  = 0;

                        <span class="keywordflow">for</span> (k = 0; k &lt; routeCount; k++) {
                            <span class="keywordflow">if</span> ((<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;GetDestinationType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aaf930613a21a30bef97cab3284d0648f">OSPF::RoutingTableEntry::NetworkDestination</a>) &amp;&amp;
                                (<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;GetPathType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254aada3ad1646360d0d106905c77733f600">OSPF::RoutingTableEntry::IntraArea</a>) &amp;&amp;
                                ((<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;GetDestinationID().getInt() &amp; <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;GetAddressMask().getInt() &amp; <a class="code" href="_o_s_p_fcommon_8h.html#a4da9e68bb3ffcba090d1b07a5f812ce3">ULongFromIPv4Address</a>(destinationAddressRange.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a452878c3f507f27d1de9c5b7cda2ae70">mask</a>)) ==
                                 <a class="code" href="_o_s_p_fcommon_8h.html#a4da9e68bb3ffcba090d1b07a5f812ce3">ULongFromIPv4Address</a>(destinationAddressRange.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a74993d6571119644535ac918c4240722">address</a> &amp; destinationAddressRange.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a452878c3f507f27d1de9c5b7cda2ae70">mask</a>)) &amp;&amp;
                                (<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;GetCost() &gt; maxRangeCost))
                            {
                                oneLessCost  = maxRangeCost;
                                maxRangeCost = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;GetCost();
                            }
                        }

                        <span class="keywordflow">if</span> (maxRangeCost == <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]-&gt;GetCost()) {  <span class="comment">// this entry gives the range&#39;s cost</span>
                            lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a>       = <a class="code" href="_o_s_p_fcommon_8h.html#a4da9e68bb3ffcba090d1b07a5f812ce3">ULongFromIPv4Address</a>(destinationAddressRange.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a74993d6571119644535ac918c4240722">address</a>);
                            lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>;

                            <a class="code" href="class_o_s_p_f_1_1_summary_l_s_a.html">OSPF::SummaryLSA</a>* summaryLSA = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;FindSummaryLSA(lsaKey);

                            <span class="keywordflow">if</span> (summaryLSA != NULL) {
                                <span class="keywordflow">if</span> (oneLessCost != 0) { <span class="comment">// there&#39;s an other entry in this range</span>
                                    summaryLSA-&gt;setRouteCost(oneLessCost);
<span class="comment">//                                    FloodLSA(summaryLSA, OSPF::BackboneAreaID);</span>
                                    <a class="code" href="class_o_s_p_f_1_1_router.html#a2cfb1ebf041766dadf2fcd6e1fdebe27">FloodLSA</a>(summaryLSA, <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;GetAreaID());

                                    originatedLSAMap[lsaKey] = <span class="keyword">true</span>;
                                } <span class="keywordflow">else</span> {    <span class="comment">// no more entries in this range -&gt; delete it</span>
                                    std::map&lt;OSPF::LSAKeyType, bool, OSPF::LSAKeyType_Less&gt;::const_iterator deletedIt = deletedLSAMap.find(lsaKey);
                                    <span class="keywordflow">if</span> (deletedIt == deletedLSAMap.end()) {
                                        summaryLSA-&gt;getHeader().setLsAge(<a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a>);
<span class="comment">//                                        FloodLSA(summaryLSA, OSPF::BackboneAreaID);</span>
                                        <a class="code" href="class_o_s_p_f_1_1_router.html#a2cfb1ebf041766dadf2fcd6e1fdebe27">FloodLSA</a>(summaryLSA, <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;GetAreaID());

                                        deletedLSAMap[lsaKey]    = <span class="keyword">true</span>;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        routeCount = oldRoutingTable.size();
        <span class="keywordflow">for</span> (j = 0; j &lt; routeCount; j++) {
            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>                                         destination = oldRoutingTable[j]-&gt;GetDestinationID().getInt() &amp; oldRoutingTable[j]-&gt;GetAddressMask().getInt();
            std::map&lt;unsigned long, RoutingTableEntry*&gt;::iterator destIt      = newTableMap.find(destination);
            <span class="keywordflow">if</span> (destIt == newTableMap.end()) { <span class="comment">// deleted routing entry</span>
                <a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">OSPF::IPv4AddressRange</a> destinationAddressRange;

                destinationAddressRange.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a74993d6571119644535ac918c4240722">address</a> = <a class="code" href="_o_s_p_fcommon_8h.html#a5206656cf4131a17505ee9db0a60ddb6">IPv4AddressFromULong</a>(oldRoutingTable[j]-&gt;GetDestinationID().getInt());
                destinationAddressRange.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a452878c3f507f27d1de9c5b7cda2ae70">mask</a> = <a class="code" href="_o_s_p_fcommon_8h.html#a5206656cf4131a17505ee9db0a60ddb6">IPv4AddressFromULong</a>(oldRoutingTable[j]-&gt;GetAddressMask().getInt());

                <span class="keywordflow">if</span> ((oldRoutingTable[j]-&gt;GetDestinationType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aaf930613a21a30bef97cab3284d0648f">OSPF::RoutingTableEntry::NetworkDestination</a>) &amp;&amp;
                    ((oldRoutingTable[j]-&gt;GetPathType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254aada3ad1646360d0d106905c77733f600">OSPF::RoutingTableEntry::IntraArea</a>) ||
                     (oldRoutingTable[j]-&gt;GetPathType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a9e19536f5d4fede2389e66c6ff4969fa">OSPF::RoutingTableEntry::InterArea</a>)))
                {
                    <a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">OSPF::IPv4AddressRange</a> containingAddressRange = <a class="code" href="class_o_s_p_f_1_1_router.html#a9a35624ca66179bda14774a1fbdc44bf">GetContainingAddressRange</a>(destinationAddressRange);
                    <span class="keywordflow">if</span> (containingAddressRange != <a class="code" href="namespace_o_s_p_f.html#ad8bce8fb1420d6747aba9a122e7300ea">OSPF::NullIPv4AddressRange</a>) {
                        destinationAddressRange = containingAddressRange;
                    }
                }

                <a class="code" href="namespace_o_s_p_f.html#a4a99812a2d079df0f7208f2740cdb0ad">Metric</a> maxRangeCost = 0;

                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> newRouteCount = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.size();
                <span class="keywordflow">for</span> (k = 0; k &lt; newRouteCount; k++) {
                    <span class="keywordflow">if</span> ((<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;GetDestinationType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aaf930613a21a30bef97cab3284d0648f">OSPF::RoutingTableEntry::NetworkDestination</a>) &amp;&amp;
                        (<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;GetPathType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254aada3ad1646360d0d106905c77733f600">OSPF::RoutingTableEntry::IntraArea</a>) &amp;&amp;
                        ((<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;GetDestinationID().getInt() &amp; <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;GetAddressMask().getInt() &amp; <a class="code" href="_o_s_p_fcommon_8h.html#a4da9e68bb3ffcba090d1b07a5f812ce3">ULongFromIPv4Address</a>(destinationAddressRange.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a452878c3f507f27d1de9c5b7cda2ae70">mask</a>)) ==
                         <a class="code" href="_o_s_p_fcommon_8h.html#a4da9e68bb3ffcba090d1b07a5f812ce3">ULongFromIPv4Address</a>(destinationAddressRange.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a74993d6571119644535ac918c4240722">address</a> &amp; destinationAddressRange.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a452878c3f507f27d1de9c5b7cda2ae70">mask</a>)) &amp;&amp;
                        (<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;GetCost() &gt; maxRangeCost))
                    {
                        maxRangeCost = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;GetCost();
                    }
                }

                <span class="keywordflow">if</span> (maxRangeCost &lt; oldRoutingTable[j]-&gt;GetCost()) {  <span class="comment">// the range&#39;s cost will change</span>
                    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a>       = <a class="code" href="_o_s_p_fcommon_8h.html#a4da9e68bb3ffcba090d1b07a5f812ce3">ULongFromIPv4Address</a>(destinationAddressRange.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a74993d6571119644535ac918c4240722">address</a>);
                    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>;

                    <a class="code" href="class_o_s_p_f_1_1_summary_l_s_a.html">OSPF::SummaryLSA</a>* summaryLSA = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;FindSummaryLSA(lsaKey);

                    <span class="keywordflow">if</span> (summaryLSA != NULL) {
                        <span class="keywordflow">if</span> (maxRangeCost &gt; 0) { <span class="comment">// there&#39;s an other entry in this range</span>
                            summaryLSA-&gt;setRouteCost(maxRangeCost);
                            <a class="code" href="class_o_s_p_f_1_1_router.html#a2cfb1ebf041766dadf2fcd6e1fdebe27">FloodLSA</a>(summaryLSA, <a class="code" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">OSPF::BackboneAreaID</a>);

                            originatedLSAMap[lsaKey] = <span class="keyword">true</span>;
                        } <span class="keywordflow">else</span> {    <span class="comment">// no more entries in this range -&gt; delete it</span>
                            std::map&lt;OSPF::LSAKeyType, bool, OSPF::LSAKeyType_Less&gt;::const_iterator deletedIt = deletedLSAMap.find(lsaKey);
                            <span class="keywordflow">if</span> (deletedIt == deletedLSAMap.end()) {
                                summaryLSA-&gt;getHeader().setLsAge(<a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a>);
                                <a class="code" href="class_o_s_p_f_1_1_router.html#a2cfb1ebf041766dadf2fcd6e1fdebe27">FloodLSA</a>(summaryLSA, <a class="code" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">OSPF::BackboneAreaID</a>);

                                deletedLSAMap[lsaKey]    = <span class="keyword">true</span>;
                            }
                        }
                    }
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="adf337b0a712b070d288f208ea5cd591a"></a><!-- doxytag: member="OSPF::Router::OriginateASExternalLSA" ref="adf337b0a712b070d288f208ea5cd591a" args="(ASExternalLSA *lsa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a> * OSPF::Router::OriginateASExternalLSA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a> *&#160;</td>
          <td class="paramname"><em>lsa</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Originates a new AS External LSA based on the input lsa. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsa</td><td>[in] The LSA whose contents should be copied into the newly originated LSA. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The newly originated LSA. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>* asExternalLSA = <span class="keyword">new</span> <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>(*lsa);
    OSPFLSAHeader&amp; lsaHeader = asExternalLSA-&gt;getHeader();
    OSPFOptions    lsaOptions;

    lsaHeader.setLsAge(0);
    memset(&amp;lsaOptions, 0, <span class="keyword">sizeof</span>(OSPFOptions));
    lsaOptions.E_ExternalRoutingCapability = <span class="keyword">true</span>;
    lsaHeader.setLsOptions(lsaOptions);
    lsaHeader.setLsSequenceNumber(<a class="code" href="_o_s_p_fcommon_8h.html#ad441394da087bc61e24a5b99455c5589">INITIAL_SEQUENCE_NUMBER</a>);
    asExternalLSA-&gt;<a class="code" href="class_o_s_p_f_1_1_l_s_a_tracking_info.html#ae129816a5603d664d66883b4bffb0e63">SetSource</a>(<a class="code" href="class_o_s_p_f_1_1_l_s_a_tracking_info.html#a25c15e523b3de9f3a023fbf0f6acbcfcac3c865818131fa4d69cdf5281934f10e">OSPF::LSATrackingInfo::Originated</a>);

    <span class="keywordflow">return</span> asExternalLSA;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa28b138458a39381a75d969e82dbfde0"></a><!-- doxytag: member="OSPF::Router::PruneASBoundaryRouterEntries" ref="aa28b138458a39381a75d969e82dbfde0" args="(std::vector&lt; RoutingTableEntry * &gt; &amp;asbrEntries) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OSPF::Router::PruneASBoundaryRouterEntries </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>asbrEntries</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prunes the input std::vector of RoutingTableEntries according to the RFC2328 Section 16.4.1. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">asbrEntries</td><td>[in/out] The list of RoutingTableEntries to prune. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>RFC2328 Section 16.4.1. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> hasNonBackboneIntraAreaPath = <span class="keyword">false</span>;
    <span class="keywordflow">for</span> (std::vector&lt;OSPF::RoutingTableEntry*&gt;::iterator it = asbrEntries.begin(); it != asbrEntries.end(); it++) {
        <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* routingEntry = *it;
        <span class="keywordflow">if</span> ((routingEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ae6952c69005f7d3d6421ea52439c776e">GetPathType</a>() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254aada3ad1646360d0d106905c77733f600">OSPF::RoutingTableEntry::IntraArea</a>) &amp;&amp;
            (routingEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aa1f39ae9bee53ff52d744012c9adefdf">GetArea</a>() != <a class="code" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">OSPF::BackboneAreaID</a>))
        {
            hasNonBackboneIntraAreaPath = <span class="keyword">true</span>;
            <span class="keywordflow">break</span>;
        }
    }

    <span class="keywordflow">if</span> (hasNonBackboneIntraAreaPath) {
        std::vector&lt;OSPF::RoutingTableEntry*&gt;::iterator it = asbrEntries.begin();
        <span class="keywordflow">while</span> (it != asbrEntries.end()) {
            <span class="keywordflow">if</span> (((*it)-&gt;GetPathType() != <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254aada3ad1646360d0d106905c77733f600">OSPF::RoutingTableEntry::IntraArea</a>) ||
                ((*it)-&gt;GetArea() == <a class="code" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">OSPF::BackboneAreaID</a>))
            {
                it = asbrEntries.erase(it);
            } <span class="keywordflow">else</span> {
                it++;
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a184025a0ac2c61dc9c580b2321a9c9a1"></a><!-- doxytag: member="OSPF::Router::RebuildRoutingTable" ref="a184025a0ac2c61dc9c580b2321a9c9a1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OSPF::Router::RebuildRoutingTable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rebuilds the routing table from scratch(based on the LSA database). </p>
<dl class="see"><dt><b>See also:</b></dt><dd>RFC2328 Section 16. </dd></dl>

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_neighbor_state.html#a2aaa9b77d04ee05f86463f5f468080d9">OSPF::NeighborState::ChangeState()</a>, and <a class="el" href="class_o_s_p_f_1_1_interface_state.html#a10805e77b3f9a99f2e678f8e29f3b7bc">OSPF::InterfaceState::ChangeState()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>                         areaCount       = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordtype">bool</span>                                  hasTransitAreas = <span class="keyword">false</span>;
    std::vector&lt;OSPF::RoutingTableEntry*&gt; newTable;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>                         i;

    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Rebuilding routing table:\n&quot;</span>;

    <span class="keywordflow">for</span> (i = 0; i &lt; areaCount; i++) {
        <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;CalculateShortestPathTree(newTable);
        <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;GetTransitCapability()) {
            hasTransitAreas = <span class="keyword">true</span>;
        }
    }
    <span class="keywordflow">if</span> (areaCount &gt; 1) {
        <a class="code" href="class_o_s_p_f_1_1_area.html">OSPF::Area</a>* backbone = <a class="code" href="class_o_s_p_f_1_1_router.html#af1593be786d4bdd63bb6805d5bdefb50">GetArea</a>(<a class="code" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">OSPF::BackboneAreaID</a>);
        <span class="keywordflow">if</span> (backbone != NULL) {
            backbone-&gt;<a class="code" href="class_o_s_p_f_1_1_area.html#a943ee3f25aa5db9b909d762fe4ad7434">CalculateInterAreaRoutes</a>(newTable);
        }
    } <span class="keywordflow">else</span> {
        <span class="keywordflow">if</span> (areaCount == 1) {
            <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[0]-&gt;CalculateInterAreaRoutes(newTable);
        }
    }
    <span class="keywordflow">if</span> (hasTransitAreas) {
        <span class="keywordflow">for</span> (i = 0; i &lt; areaCount; i++) {
            <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;GetTransitCapability()) {
                <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;ReCheckSummaryLSAs(newTable);
            }
        }
    }
    <a class="code" href="class_o_s_p_f_1_1_router.html#a3949265e72dab00a009aaa0758cd2623">CalculateASExternalRoutes</a>(newTable);

    <span class="comment">// backup the routing table</span>
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>                         routeCount = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.size();
    std::vector&lt;OSPF::RoutingTableEntry*&gt; oldTable;

    oldTable.assign(<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.begin(), <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.end());
    <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.clear();
    <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.assign(newTable.begin(), newTable.end());

    <a class="code" href="class_routing_table_access.html">RoutingTableAccess</a>         routingTableAccess;
    std::vector&lt;const IPRoute*&gt; eraseEntries;
    <a class="code" href="class_i_routing_table.html">IRoutingTable</a>*              simRoutingTable    = routingTableAccess.<a class="code" href="class_module_access.html#a44956ddb52973612afbba0eeecf8bb66">get</a>();
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>              routingEntryNumber = simRoutingTable-&gt;<a class="code" href="class_i_routing_table.html#ada2fac98d1d1c80c291be239b075c63b">getNumRoutes</a>();
    <span class="comment">// remove entries from the IP routing table inserted by the OSPF module</span>
    <span class="keywordflow">for</span> (i = 0; i &lt; routingEntryNumber; i++) {
        <span class="keyword">const</span> <a class="code" href="class_i_p_route.html">IPRoute</a> *entry = simRoutingTable-&gt;<a class="code" href="class_i_routing_table.html#a89f3eb433e309043cde517238eef5214">getRoute</a>(i);
        <span class="keyword">const</span> <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* ospfEntry = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span><a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>*<span class="keyword">&gt;</span>(entry);
        <span class="keywordflow">if</span> (ospfEntry != NULL) {
            eraseEntries.push_back(entry);
        }
    }

    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eraseCount = eraseEntries.size();
    <span class="keywordflow">for</span> (i = 0; i &lt; eraseCount; i++) {
        simRoutingTable-&gt;<a class="code" href="class_i_routing_table.html#adc051b6287f397968f83aff251794cc8">deleteRoute</a>(eraseEntries[i]);
    }

    <span class="comment">// add the new routing entries</span>
    routeCount = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.size();
    <span class="keywordflow">for</span> (i = 0; i &lt; routeCount; i++) {
        <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]-&gt;GetDestinationType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aaf930613a21a30bef97cab3284d0648f">OSPF::RoutingTableEntry::NetworkDestination</a>) {
            simRoutingTable-&gt;<a class="code" href="class_i_routing_table.html#af423d065165da4a55e86385efe1f69d1">addRoute</a>(<span class="keyword">new</span> <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>(*(<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i])));
        }
    }

    <a class="code" href="class_o_s_p_f_1_1_router.html#a57df70b2d8008b2ea1827e06ab750500">NotifyAboutRoutingTableChanges</a>(oldTable);

    routeCount = oldTable.size();
    <span class="keywordflow">for</span> (i = 0; i &lt; routeCount; i++) {
        <span class="keyword">delete</span>(oldTable[i]);
    }

    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Routing table was rebuilt.\n&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Results:\n&quot;</span>;

    routeCount = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.size();
    <span class="keywordflow">for</span> (i = 0; i &lt; routeCount; i++) {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; *<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]
           &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5ec34d1a9d49f94ddd6c2552c1f100a6"></a><!-- doxytag: member="OSPF::Router::RemoveExternalRoute" ref="a5ec34d1a9d49f94ddd6c2552c1f100a6" args="(IPv4Address networkAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OSPF::Router::RemoveExternalRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_p_f_1_1_i_pv4_address.html">OSPF::IPv4Address</a>&#160;</td>
          <td class="paramname"><em>networkAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes an AS External Route from the database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">networkAddress</td><td>[in] The network address of the external route which needs to be removed. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a>     lsaKey;

    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a> = <a class="code" href="_o_s_p_fcommon_8h.html#a4da9e68bb3ffcba090d1b07a5f812ce3">ULongFromIPv4Address</a>(networkAddress);
    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>;

    std::map&lt;OSPF::LSAKeyType, OSPF::ASExternalLSA*, OSPF::LSAKeyType_Less&gt;::iterator lsaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.find(lsaKey);
    <span class="keywordflow">if</span> (lsaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.end()) {
        lsaIt-&gt;second-&gt;getHeader().setLsAge(<a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a>);
        lsaIt-&gt;second-&gt;SetPurgeable();
        <a class="code" href="class_o_s_p_f_1_1_router.html#a2cfb1ebf041766dadf2fcd6e1fdebe27">FloodLSA</a>(lsaIt-&gt;second, <a class="code" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">OSPF::BackboneAreaID</a>);
    }

    std::map&lt;OSPF::IPv4Address, OSPFASExternalLSAContents, OSPF::IPv4Address_Less&gt;::iterator externalIt = <a class="code" href="class_o_s_p_f_1_1_router.html#a2fa24502500b746a3056832733228a65" title="A map of the external route advertised by this router.">externalRoutes</a>.find(networkAddress);
    <span class="keywordflow">if</span> (externalIt != <a class="code" href="class_o_s_p_f_1_1_router.html#a2fa24502500b746a3056832733228a65" title="A map of the external route advertised by this router.">externalRoutes</a>.end()) {
        <a class="code" href="class_o_s_p_f_1_1_router.html#a2fa24502500b746a3056832733228a65" title="A map of the external route advertised by this router.">externalRoutes</a>.erase(externalIt);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac754f8ed7d454fc7bfe53ac877eebe53"></a><!-- doxytag: member="OSPF::Router::RemoveFromAllRetransmissionLists" ref="ac754f8ed7d454fc7bfe53ac877eebe53" args="(LSAKeyType lsaKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OSPF::Router::RemoveFromAllRetransmissionLists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a>&#160;</td>
          <td class="paramname"><em>lsaKey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes all LSAs from all Neighbor's retransmission lists which are identified by the input lsaKey. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsaKey</td><td>[in] Identifies the LSAs to remove from the retransmission lists. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
        <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;RemoveFromAllRetransmissionLists(lsaKey);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a46ac75abdaab6c761720ce6bb6b43c37"></a><!-- doxytag: member="OSPF::Router::SelectLeastCostRoutingEntry" ref="a46ac75abdaab6c761720ce6bb6b43c37" args="(std::vector&lt; RoutingTableEntry * &gt; &amp;entries) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a> * OSPF::Router::SelectLeastCostRoutingEntry </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>entries</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Selects the least cost <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> from the input std::vector of RoutingTableEntries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">entries</td><td>[in] The RoutingTableEntries to choose the least cost one from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The least cost entry or NULL if entries is empty. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (entries.empty()) {
        <span class="keywordflow">return</span> NULL;
    }

    <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* leastCostEntry = entries[0];
    <a class="code" href="namespace_o_s_p_f.html#a4a99812a2d079df0f7208f2740cdb0ad">Metric</a>                   leastCost      = leastCostEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a098e2d41bad2cd9236ee0581e6bda190">GetCost</a>();
    <span class="keywordtype">long</span>                     routeCount     = entries.size();

    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 1; i &lt; routeCount; i++) {
        <a class="code" href="namespace_o_s_p_f.html#a4a99812a2d079df0f7208f2740cdb0ad">Metric</a> currentCost = entries[i]-&gt;GetCost();
        <span class="keywordflow">if</span> ((currentCost &lt; leastCost) ||
            ((currentCost == leastCost) &amp;&amp; (entries[i]-&gt;<a class="code" href="class_o_s_p_f_1_1_router.html#af1593be786d4bdd63bb6805d5bdefb50">GetArea</a>() &gt; leastCostEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aa1f39ae9bee53ff52d744012c9adefdf">GetArea</a>())))
        {
            leastCostEntry = entries[i];
            leastCost = currentCost;
        }
    }

    <span class="keywordflow">return</span> leastCostEntry;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae27ea511ced12487b158e87d4582ea21"></a><!-- doxytag: member="OSPF::Router::SetRFC1583Compatibility" ref="ae27ea511ced12487b158e87d4582ea21" args="(bool compatibility)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OSPF::Router::SetRFC1583Compatibility </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compatibility</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_o_s_p_f_routing.html#af1b821a07e9e6aa92b95d8b88c351675">OSPFRouting::LoadConfigFromXML()</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="class_o_s_p_f_1_1_router.html#a10f71a71f20baa02d35f94d602758357" title="Decides whether to handle the preferred routing table entry to an AS boundary router as defined in RF...">rfc1583Compatibility</a> = compatibility; }
</pre></div>
</div>
</div>
<a class="anchor" id="acc3ff0effb2c8b74440b479b201880df"></a><!-- doxytag: member="OSPF::Router::SetRouterID" ref="acc3ff0effb2c8b74440b479b201880df" args="(RouterID id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OSPF::Router::SetRouterID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_o_s_p_f.html#ad64f22839cca7ec05fee5b7596411197">RouterID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a> = id; }
</pre></div>
</div>
</div>
<a class="anchor" id="aed64d2915aba911a976c06f053ecf19f"></a><!-- doxytag: member="OSPF::Router::UpdateExternalRoute" ref="aed64d2915aba911a976c06f053ecf19f" args="(IPv4Address networkAddress, const OSPFASExternalLSAContents &amp;externalRouteContents, int ifIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OSPF::Router::UpdateExternalRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_p_f_1_1_i_pv4_address.html">OSPF::IPv4Address</a>&#160;</td>
          <td class="paramname"><em>networkAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OSPFASExternalLSAContents &amp;&#160;</td>
          <td class="paramname"><em>externalRouteContents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ifIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stores information on an AS External Route in externalRoutes and intalls(or updates) a new <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> into the database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">networkAddress</td><td>[in] The external route's network address. </td></tr>
    <tr><td class="paramname">externalRouteContents</td><td>[in] Route configuration data for the external route. </td></tr>
    <tr><td class="paramname">ifIndex</td><td>[in] </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="class_o_s_p_f_routing.html#a2f336ded44b9ee2443da70db19ff34f4">OSPFRouting::LoadExternalRoute()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>* asExternalLSA = <span class="keyword">new</span> <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>;
    OSPFLSAHeader&amp;       lsaHeader     = asExternalLSA-&gt;getHeader();
    OSPFOptions          lsaOptions;
    <span class="comment">//OSPF::LSAKeyType     lsaKey;</span>

    <a class="code" href="class_i_routing_table.html">IRoutingTable</a>*      simRoutingTable    = <a class="code" href="class_routing_table_access.html">RoutingTableAccess</a>().<a class="code" href="class_module_access.html#a44956ddb52973612afbba0eeecf8bb66">get</a>();
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>      routingEntryNumber = simRoutingTable-&gt;<a class="code" href="class_i_routing_table.html#ada2fac98d1d1c80c291be239b075c63b">getNumRoutes</a>();
    <span class="keywordtype">bool</span>               inRoutingTable     = <span class="keyword">false</span>;
    <span class="comment">// add the external route to the routing table if it was not added by another module</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i = 0; i &lt; routingEntryNumber; i++) {
        <span class="keyword">const</span> <a class="code" href="class_i_p_route.html">IPRoute</a> *entry = simRoutingTable-&gt;<a class="code" href="class_i_routing_table.html#a89f3eb433e309043cde517238eef5214">getRoute</a>(i);
        <span class="keywordflow">if</span> ((entry-&gt;<a class="code" href="class_i_p_route.html#a07adcdcc04cb4d50f12f060c7206b73e">getHost</a>().<a class="code" href="class_i_p_address.html#a807ca46964a8403cf0c70f0772179524">getInt</a>() &amp; entry-&gt;<a class="code" href="class_i_p_route.html#ad69bc8024a13bf6ec528e9afdf1aa7e1">getNetmask</a>().<a class="code" href="class_i_p_address.html#a807ca46964a8403cf0c70f0772179524">getInt</a>()) ==
            (<a class="code" href="_o_s_p_fcommon_8h.html#a4da9e68bb3ffcba090d1b07a5f812ce3">ULongFromIPv4Address</a>(networkAddress) &amp; externalRouteContents.getNetworkMask().getInt()))
        {
            inRoutingTable = <span class="keyword">true</span>;
        }
    }
    <span class="keywordflow">if</span> (!inRoutingTable) {
        <a class="code" href="class_i_p_route.html">IPRoute</a>* entry = <span class="keyword">new</span> <a class="code" href="class_i_p_route.html">IPRoute</a>;
        entry-&gt;<a class="code" href="class_i_p_route.html#af706d909f82600db0ff2191540131b91">setHost</a>(<a class="code" href="_o_s_p_fcommon_8h.html#a4da9e68bb3ffcba090d1b07a5f812ce3">ULongFromIPv4Address</a>(networkAddress));
        entry-&gt;<a class="code" href="class_i_p_route.html#a8fd0ecc3020120431bae84d2eae7cc6a">setNetmask</a>(externalRouteContents.getNetworkMask());
        entry-&gt;<a class="code" href="class_i_p_route.html#a5111618dad4786d4fda4f770aacc5e41">setInterface</a>(<a class="code" href="class_interface_table_access.html">InterfaceTableAccess</a>().<span class="keyword">get</span>()-&gt;getInterfaceById(ifIndex));
        entry-&gt;<a class="code" href="class_i_p_route.html#a545b92b4bd15e1dad59afba65344c6f1">setType</a>(<a class="code" href="class_i_p_route.html#affdd22b24049e9d8d991b955a973d32ea7e558ac291a7e5173702d655d80e627c" title="Reached through another router.">IPRoute::REMOTE</a>);
        entry-&gt;<a class="code" href="class_i_p_route.html#a9e1a72084dc1acc1b429bbd8c4e72a32">setSource</a>(<a class="code" href="class_i_p_route.html#a8b19adf2d204de05cc8fdee67a270bc6a504efea5aa79d898637d8be7a2c495ee" title="manually added static route">IPRoute::MANUAL</a>);
        entry-&gt;<a class="code" href="class_i_p_route.html#ae0d4294f3ad0d91b283f5da2b183335f">setMetric</a>(externalRouteContents.getRouteCost());
        simRoutingTable-&gt;<a class="code" href="class_i_routing_table.html#af423d065165da4a55e86385efe1f69d1">addRoute</a>(entry);   <span class="comment">// IRoutingTable deletes entry pointer</span>
    }

    lsaHeader.setLsAge(0);
    memset(&amp;lsaOptions, 0, <span class="keyword">sizeof</span>(OSPFOptions));
    lsaOptions.E_ExternalRoutingCapability = <span class="keyword">true</span>;
    lsaHeader.setLsOptions(lsaOptions);
    lsaHeader.setLsType(ASExternalLSAType);
    lsaHeader.setLinkStateID(<a class="code" href="_o_s_p_fcommon_8h.html#a4da9e68bb3ffcba090d1b07a5f812ce3">ULongFromIPv4Address</a>(networkAddress));   <span class="comment">// TODO: get unique LinkStateID</span>
    lsaHeader.setAdvertisingRouter(<a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>);
    lsaHeader.setLsSequenceNumber(<a class="code" href="_o_s_p_fcommon_8h.html#ad441394da087bc61e24a5b99455c5589">INITIAL_SEQUENCE_NUMBER</a>);

    asExternalLSA-&gt;setContents(externalRouteContents);

    lsaHeader.setLsChecksum(0);    <span class="comment">// TODO: calculate correct LS checksum</span>

    asExternalLSA-&gt;<a class="code" href="class_o_s_p_f_1_1_l_s_a_tracking_info.html#ae129816a5603d664d66883b4bffb0e63">SetSource</a>(<a class="code" href="class_o_s_p_f_1_1_l_s_a_tracking_info.html#a25c15e523b3de9f3a023fbf0f6acbcfcac3c865818131fa4d69cdf5281934f10e">OSPF::LSATrackingInfo::Originated</a>);

    <a class="code" href="class_o_s_p_f_1_1_router.html#a2fa24502500b746a3056832733228a65" title="A map of the external route advertised by this router.">externalRoutes</a>[networkAddress] = externalRouteContents;

    <span class="keywordtype">bool</span> rebuild = <a class="code" href="class_o_s_p_f_1_1_router.html#a8615120ec6c21bfd812b533e5532ddcb">InstallASExternalLSA</a>(asExternalLSA);
    <a class="code" href="class_o_s_p_f_1_1_router.html#a2cfb1ebf041766dadf2fcd6e1fdebe27">FloodLSA</a>(asExternalLSA, <a class="code" href="namespace_o_s_p_f.html#adb591659bd229b640cdc32ebaef95222">OSPF::BackboneAreaID</a>);
    <span class="keyword">delete</span> asExternalLSA;

    <span class="keywordflow">if</span> (rebuild) {
        <a class="code" href="class_o_s_p_f_1_1_router.html#a184025a0ac2c61dc9c580b2321a9c9a1">RebuildRoutingTable</a>();
    }
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="acafd411e92c5c3bc952daadbc0d53cf5"></a><!-- doxytag: member="OSPF::Router::ageTimer" ref="acafd411e92c5c3bc952daadbc0d53cf5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSPFTimer* <a class="el" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5">OSPF::Router::ageTimer</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Database age timer - fires every second. </p>

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_router.html#a35bbf6cd398015ef42d76223e745ba2e">Router()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ce9c0ecf94cbc5872c346750e4de6b8"></a><!-- doxytag: member="OSPF::Router::areas" ref="a5ce9c0ecf94cbc5872c346750e4de6b8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_o_s_p_f_1_1_area.html">Area</a>*&gt; <a class="el" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8">OSPF::Router::areas</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A list of the contained areas. </p>

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_router.html#a69d95bca021305439e63ebb712a9559c">GetAreaCount()</a>.</p>

</div>
</div>
<a class="anchor" id="ab2c936939863bd82c6628c794e6409e5"></a><!-- doxytag: member="OSPF::Router::areasByID" ref="ab2c936939863bd82c6628c794e6409e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="namespace_o_s_p_f.html#a8d10c460f2da4aae5dd61d2a082dfc56">AreaID</a>, <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a>*&gt; <a class="el" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5">OSPF::Router::areasByID</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A map of the contained areas with the AreaID as key. </p>

</div>
</div>
<a class="anchor" id="a20e18099b999ef4fd3eebca715173f36"></a><!-- doxytag: member="OSPF::Router::asExternalLSAs" ref="a20e18099b999ef4fd3eebca715173f36" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a>*&gt; <a class="el" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36">OSPF::Router::asExternalLSAs</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A list of the ASExternalLSAs advertised by this router. </p>

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_router.html#abfec528130746982c850c80084a9502b">GetASExternalLSA()</a>, and <a class="el" href="class_o_s_p_f_1_1_router.html#a18459104f498a4de761216210665220a">GetASExternalLSACount()</a>.</p>

</div>
</div>
<a class="anchor" id="abbdacd52ab234eb19f6eeb24a06222c2"></a><!-- doxytag: member="OSPF::Router::asExternalLSAsByID" ref="abbdacd52ab234eb19f6eeb24a06222c2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">LSAKeyType</a>, <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a>*, <a class="el" href="class_o_s_p_f_1_1_l_s_a_key_type___less.html">LSAKeyType_Less</a>&gt; <a class="el" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2">OSPF::Router::asExternalLSAsByID</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A map of the ASExternalLSAs advertised by this router. </p>

</div>
</div>
<a class="anchor" id="a2fa24502500b746a3056832733228a65"></a><!-- doxytag: member="OSPF::Router::externalRoutes" ref="a2fa24502500b746a3056832733228a65" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="struct_o_s_p_f_1_1_i_pv4_address.html">IPv4Address</a>, OSPFASExternalLSAContents, <a class="el" href="class_o_s_p_f_1_1_i_pv4_address___less.html">IPv4Address_Less</a>&gt; <a class="el" href="class_o_s_p_f_1_1_router.html#a2fa24502500b746a3056832733228a65">OSPF::Router::externalRoutes</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A map of the external route advertised by this router. </p>

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_router.html#ac380db94a6b8c16941d338a11b3b6b11">GetASBoundaryRouter()</a>.</p>

</div>
</div>
<a class="anchor" id="a532e99a63a766b3aabc007fd929fb48f"></a><!-- doxytag: member="OSPF::Router::messageHandler" ref="a532e99a63a766b3aabc007fd929fb48f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_message_handler.html">MessageHandler</a>* <a class="el" href="class_o_s_p_f_1_1_router.html#a532e99a63a766b3aabc007fd929fb48f">OSPF::Router::messageHandler</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The message dispatcher class. </p>

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_router.html#ab2b6452dadb00d2970e3432b0b29e17f">GetMessageHandler()</a>, and <a class="el" href="class_o_s_p_f_1_1_router.html#a35bbf6cd398015ef42d76223e745ba2e">Router()</a>.</p>

</div>
</div>
<a class="anchor" id="a10f71a71f20baa02d35f94d602758357"></a><!-- doxytag: member="OSPF::Router::rfc1583Compatibility" ref="a10f71a71f20baa02d35f94d602758357" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_s_p_f_1_1_router.html#a10f71a71f20baa02d35f94d602758357">OSPF::Router::rfc1583Compatibility</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decides whether to handle the preferred routing table entry to an AS boundary router as defined in RFC1583 or not. </p>

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_router.html#affd6a398ee914b26e5c06e72c9998e8d">GetRFC1583Compatibility()</a>, and <a class="el" href="class_o_s_p_f_1_1_router.html#ae27ea511ced12487b158e87d4582ea21">SetRFC1583Compatibility()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ebbdb2a44054edf297b21360de68cb9"></a><!-- doxytag: member="OSPF::Router::routerID" ref="a3ebbdb2a44054edf297b21360de68cb9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_o_s_p_f.html#ad64f22839cca7ec05fee5b7596411197">RouterID</a> <a class="el" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9">OSPF::Router::routerID</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The router ID assigned by the <a class="el" href="class_i_p.html">IP</a> layer. </p>

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_router.html#a12b09f4263d005f7b0cd808502c1de48">GetRouterID()</a>, and <a class="el" href="class_o_s_p_f_1_1_router.html#acc3ff0effb2c8b74440b479b201880df">SetRouterID()</a>.</p>

</div>
</div>
<a class="anchor" id="aff527f73b1c4068c21abb9fe9dd9f090"></a><!-- doxytag: member="OSPF::Router::routingTable" ref="aff527f73b1c4068c21abb9fe9dd9f090" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a>*&gt; <a class="el" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090">OSPF::Router::routingTable</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <a class="el" href="namespace_o_s_p_f.html">OSPF</a> routing table - contains more information than the one in the <a class="el" href="class_i_p.html">IP</a> layer. </p>

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_router.html#a429edf824d86c3200851393676608603">AddRoutingTableEntry()</a>, <a class="el" href="class_o_s_p_f_1_1_router.html#adc36bddb2349df8c7f013e0c1062909e">GetRoutingTableEntry()</a>, and <a class="el" href="class_o_s_p_f_1_1_router.html#a07874bd84b94970be2c08b01a50bff9e">GetRoutingTableEntryCount()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_o_s_p_f_router_8h.html">OSPFRouter.h</a></li>
<li><a class="el" href="_o_s_p_f_router_8cc.html">OSPFRouter.cc</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_o_s_p_f.html">OSPF</a>      </li>
      <li class="navelem"><a class="el" href="class_o_s_p_f_1_1_router.html">Router</a>      </li>
      <li class="footer">Generated on Fri Nov 18 2011 12:47:18 for INET Framework for OMNeT++/OMNEST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>

</body>
</html>
