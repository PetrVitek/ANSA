<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>INET Framework for OMNeT++/OMNEST: OSPF::Router Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">INET Framework for OMNeT++/OMNEST
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_o_s_p_f_1_1_router.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">OSPF::Router Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="OSPF::Router" -->
<p>Represents the full <a class="el" href="namespace_o_s_p_f.html" title="All OSPF classes are in this namespace.">OSPF</a> data structure as laid out in RFC2328.  
 <a href="class_o_s_p_f_1_1_router.html#details">More...</a></p>

<p><code>#include &lt;OSPFRouter.h&gt;</code></p>

<p><a href="class_o_s_p_f_1_1_router-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a35bbf6cd398015ef42d76223e745ba2e">Router</a> (<a class="el" href="namespace_o_s_p_f.html#adbcc14dbfc5290248d3f865bd3a56af4">RouterID</a> <a class="el" href="_t_c_p___n_s_c___connection_8cc.html#a4fc3a0c58dfbd1e68224521185cb9384">id</a>, cSimpleModule *containingModule)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a35bbf6cd398015ef42d76223e745ba2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a144111945c866cda3bcd1b3c9feed99b">~Router</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a144111945c866cda3bcd1b3c9feed99b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#ab997cc64af49534585ce56de7ba27349">setRouterID</a> (<a class="el" href="namespace_o_s_p_f.html#adbcc14dbfc5290248d3f865bd3a56af4">RouterID</a> <a class="el" href="_t_c_p___n_s_c___connection_8cc.html#a4fc3a0c58dfbd1e68224521185cb9384">id</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_o_s_p_f.html#adbcc14dbfc5290248d3f865bd3a56af4">RouterID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#abf4855bc5ad7dfb4a47d1aae3b003751">getRouterID</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a16b7ec42a0a4072d0299fddaa5ae57bc">setRFC1583Compatibility</a> (bool compatibility)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a3eeb651fd988d86f63d811bb88a9c121">getRFC1583Compatibility</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#aabec2db341f674865b3a9e6393889371">getAreaCount</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_message_handler.html">MessageHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a0142a9cc0f45692f0af116de386f9d6b">getMessageHandler</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a83627b1e7011409dd355dfd004a8a3a8">getASExternalLSACount</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a6647017c994ddead153bfda8cedc7c5f">getASExternalLSA</a> (unsigned long i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a2cf15dccf4ba9a099e7a754613951367">getASExternalLSA</a> (unsigned long i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a3f6f54e668fb6f2f7298949bbcab43bf">getASBoundaryRouter</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a77a1be6cab855fe8d2a9c269a500b313">getRoutingTableEntryCount</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a7f08a4ee470038b5e86af3491de83614">getRoutingTableEntry</a> (unsigned long i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a4281686fd86f50d9ce3698233f986066">getRoutingTableEntry</a> (unsigned long i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#ad98dc1515ff6fed37dfc3097a5e68e21">addRoutingTableEntry</a> (<a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> *entry)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#ac1b3c9efa50298911e7548c7cf2b9929">addWatches</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds OMNeT++ watches for the routerID, the list of Areas and the list of AS External LSAs.  <a href="#ac1b3c9efa50298911e7548c7cf2b9929"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#af76d3ec7f1fee3f8e499b28c6fea1fa3">addArea</a> (<a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> *area)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> to the <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> list.  <a href="#af76d3ec7f1fee3f8e499b28c6fea1fa3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#abd611ae0dce1b3006eab26dd5b02a5af">getAreaByID</a> (<a class="el" href="namespace_o_s_p_f.html#a48c8e4d3af2a46ddb912740d4e2e91b1">AreaID</a> areaID)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer to the <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> identified by the input areaID, if it's on the <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> list, NULL otherwise.  <a href="#abd611ae0dce1b3006eab26dd5b02a5af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#ad388964cdec01c401c7f18437d00cd31">getAreaByAddr</a> (<a class="el" href="class_i_pv4_address.html">IPv4Address</a> address)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> pointer from the <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> list which contains the input <a class="el" href="class_i_pv4.html" title="Implements the IPv4 protocol.">IPv4</a> address, NULL if there's no such area connected to the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>.  <a href="#ad388964cdec01c401c7f18437d00cd31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_interface.html">Interface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a9b4a204a6fbb8963e7f3be313a994166">getNonVirtualInterface</a> (unsigned char ifIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer of the physical <a class="el" href="class_o_s_p_f_1_1_interface.html">Interface</a> identified by the input interface index, NULL if the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a> doesn't have such an interface.  <a href="#a9b4a204a6fbb8963e7f3be313a994166"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#ada8546a2dfff49bb8010b7b11e8f634e">installLSA</a> (<a class="el" href="class_o_s_p_f_l_s_a.html">OSPFLSA</a> *lsa, <a class="el" href="namespace_o_s_p_f.html#a48c8e4d3af2a46ddb912740d4e2e91b1">AreaID</a> areaID=<a class="el" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">BACKBONE_AREAID</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a new LSA into the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a> database.  <a href="#ada8546a2dfff49bb8010b7b11e8f634e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_l_s_a.html">OSPFLSA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#aa2e591c3ef0241639b4e12b0cab7a8f9">findLSA</a> (<a class="el" href="_o_s_p_f_packet__m_8h.html#a13a450dbb578c4bd7714af8581c4f89b">LSAType</a> lsaType, <a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">LSAKeyType</a> lsaKey, <a class="el" href="namespace_o_s_p_f.html#a48c8e4d3af2a46ddb912740d4e2e91b1">AreaID</a> areaID)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the LSA identified by the input lsaKey in the database.  <a href="#aa2e591c3ef0241639b4e12b0cab7a8f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#af932cd6d5b44b4cd87599aa20e7dd588">ageDatabase</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ages the LSAs in the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>'s database.  <a href="#af932cd6d5b44b4cd87599aa20e7dd588"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#aa322d6ee424b77e7f22ef3e05681baea">hasAnyNeighborInStates</a> (int states) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any <a class="el" href="class_o_s_p_f_1_1_neighbor.html">Neighbor</a> on any <a class="el" href="class_o_s_p_f_1_1_interface.html">Interface</a> in any of the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>'s Areas is in any of the input states, false otherwise.  <a href="#aa322d6ee424b77e7f22ef3e05681baea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#aa8c94ba4d4bd22592af06b6cef21c501">removeFromAllRetransmissionLists</a> (<a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">LSAKeyType</a> lsaKey)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all LSAs from all <a class="el" href="class_o_s_p_f_1_1_neighbor.html">Neighbor</a>'s retransmission lists which are identified by the input lsaKey.  <a href="#aa8c94ba4d4bd22592af06b6cef21c501"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a7ea7fbacbe22d11dc419d6526e1d2dec">isOnAnyRetransmissionList</a> (<a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">LSAKeyType</a> lsaKey) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there's at least one LSA on any <a class="el" href="class_o_s_p_f_1_1_neighbor.html">Neighbor</a>'s retransmission list identified by the input lsaKey, false otherwise.  <a href="#a7ea7fbacbe22d11dc419d6526e1d2dec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4">floodLSA</a> (<a class="el" href="class_o_s_p_f_l_s_a.html">OSPFLSA</a> *lsa, <a class="el" href="namespace_o_s_p_f.html#a48c8e4d3af2a46ddb912740d4e2e91b1">AreaID</a> areaID=<a class="el" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">BACKBONE_AREAID</a>, <a class="el" href="class_o_s_p_f_1_1_interface.html">Interface</a> *intf=<a class="el" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor.html">Neighbor</a> *<a class="el" href="structneighbor.html">neighbor</a>=<a class="el" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Floods out the input lsa on a set of Interfaces.  <a href="#a053e23535ff2239aacd34782df554eb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#aac1b4fda6632cf425936203de702f21d">isLocalAddress</a> (<a class="el" href="class_i_pv4_address.html">IPv4Address</a> address) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the input <a class="el" href="class_i_pv4.html" title="Implements the IPv4 protocol.">IPv4</a> address falls into any of the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>'s Areas' configured <a class="el" href="class_i_pv4.html" title="Implements the IPv4 protocol.">IPv4</a> address ranges, false otherwise.  <a href="#aac1b4fda6632cf425936203de702f21d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a8189dfe577d24650fe61106221e282d2">hasAddressRange</a> (const <a class="el" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">IPv4AddressRange</a> &amp;addressRange) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if one of the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>'s Areas the same <a class="el" href="class_i_pv4.html" title="Implements the IPv4 protocol.">IPv4</a> address range configured as the input <a class="el" href="class_i_pv4.html" title="Implements the IPv4 protocol.">IPv4</a> address range, false otherwise.  <a href="#a8189dfe577d24650fe61106221e282d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a083894f1412443f07466e939a64fa29b">isDestinationUnreachable</a> (<a class="el" href="class_o_s_p_f_l_s_a.html">OSPFLSA</a> *lsa) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the destination described by the input lsa is in the routing table, false otherwise.  <a href="#a083894f1412443f07466e939a64fa29b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#af37b73461ea85b76af17738f3b21d39f">lookup</a> (<a class="el" href="class_i_pv4_address.html">IPv4Address</a> destination, std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; *table=<a class="el" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a lookup in either the input <a class="el" href="namespace_o_s_p_f.html" title="All OSPF classes are in this namespace.">OSPF</a> routing table, or if it's NULL then in the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>'s own routing table.  <a href="#af37b73461ea85b76af17738f3b21d39f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#af849f36506ebf49917f4a7f4ebdbcf53">rebuildRoutingTable</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebuilds the routing table from scratch(based on the LSA database).  <a href="#af849f36506ebf49917f4a7f4ebdbcf53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">IPv4AddressRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a10e4eb37ccddff29e494db42e3c8debe">getContainingAddressRange</a> (const <a class="el" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">IPv4AddressRange</a> &amp;addressRange, bool *advertise=<a class="el" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans through the router's areas' preconfigured address ranges and returns the one containing the input addressRange.  <a href="#a10e4eb37ccddff29e494db42e3c8debe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a542dd39f87a1f348d9f555b9823c9a07">updateExternalRoute</a> (<a class="el" href="class_i_pv4_address.html">IPv4Address</a> networkAddress, const <a class="el" href="class_o_s_p_f_a_s_external_l_s_a_contents.html">OSPFASExternalLSAContents</a> &amp;externalRouteContents, int ifIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores information on an AS External Route in externalRoutes and intalls(or updates) a new <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> into the database.  <a href="#a542dd39f87a1f348d9f555b9823c9a07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a0065bc8df3b748d831c4ee32131395c8">addExternalRouteInIPTable</a> (<a class="el" href="class_i_pv4_address.html">IPv4Address</a> networkAddress, const <a class="el" href="class_o_s_p_f_a_s_external_l_s_a_contents.html">OSPFASExternalLSAContents</a> &amp;externalRouteContents, int ifIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an AS External Route in IPRoutingTable.  <a href="#a0065bc8df3b748d831c4ee32131395c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#aa7e20ed6b4bdfb18375bb8e10e616e9b">removeExternalRoute</a> (<a class="el" href="class_i_pv4_address.html">IPv4Address</a> networkAddress)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an AS External Route from the database.  <a href="#aa7e20ed6b4bdfb18375bb8e10e616e9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a63a7808c1dc5f74983f800582a5992e4">getPreferredEntry</a> (const <a class="el" href="class_o_s_p_f_l_s_a.html">OSPFLSA</a> &amp;lsa, bool skipSelfOriginated, std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; *fromRoutingTable=<a class="el" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the preferred routing table entry for the input LSA(which is either an <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> or a <a class="el" href="class_o_s_p_f_1_1_summary_l_s_a.html">SummaryLSA</a>) according to the algorithm defined in RFC2328 Section 16.4.  <a href="#a63a7808c1dc5f74983f800582a5992e4"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a7d3ec4918c945ee00863f46bb07fe52f">installASExternalLSA</a> (<a class="el" href="class_o_s_p_f_a_s_external_l_s_a.html">OSPFASExternalLSA</a> *lsa)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a new AS External LSA into the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>'s database.  <a href="#a7d3ec4918c945ee00863f46bb07fe52f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#ab5305a0128639b180c5846ec009127f0">findASExternalLSA</a> (<a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">LSAKeyType</a> lsaKey)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the AS External LSA identified by the input lsaKey in the database.  <a href="#ab5305a0128639b180c5846ec009127f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a24bf6814ed4f6ace80cbcdf2c9e79f50">findASExternalLSA</a> (<a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">LSAKeyType</a> lsaKey) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the AS External LSA identified by the input lsaKey in the database.  <a href="#a24bf6814ed4f6ace80cbcdf2c9e79f50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a2aded30c394db977ffde8237065514e8">originateASExternalLSA</a> (<a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> *lsa)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Originates a new AS External LSA based on the input lsa.  <a href="#a2aded30c394db977ffde8237065514e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_o_s_p_f.html#ae0387e56ccb51d46ab82fabd74d53de2">LinkStateID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a16c48a9dca12af177cd70096b4a3a1cb">getUniqueLinkStateID</a> (const <a class="el" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">IPv4AddressRange</a> &amp;destination, <a class="el" href="namespace_o_s_p_f.html#a4a99812a2d079df0f7208f2740cdb0ad">Metric</a> destinationCost, <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a> *&amp;lsaToReoriginate, bool externalMetricIsType2=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a unique LinkStateID for a given destination.  <a href="#a16c48a9dca12af177cd70096b4a3a1cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a6aac8011e1bbf8166902e5ba4897684e">calculateASExternalRoutes</a> (std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;newRoutingTable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the AS External Routes from the ASExternalLSAs in the database.  <a href="#a6aac8011e1bbf8166902e5ba4897684e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#acae55a162eaf731e634d0b121a3f59dc">notifyAboutRoutingTableChanges</a> (std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;oldRoutingTable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">After a routing table rebuild the changes in the routing table are identified and new SummaryLSAs are originated or old ones are flooded out in each area as necessary.  <a href="#acae55a162eaf731e634d0b121a3f59dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a8ea3ed444f4cb7330e9be07daf522bef">hasRouteToASBoundaryRouter</a> (const std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;inRoutingTable, <a class="el" href="namespace_o_s_p_f.html#adbcc14dbfc5290248d3f865bd3a56af4">OSPF::RouterID</a> <a class="el" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9">routerID</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is a route to the AS Boundary <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a> identified by asbrRouterID in the input inRoutingTable, false otherwise.  <a href="#a8ea3ed444f4cb7330e9be07daf522bef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#af137b28d57bdc2e96f8c454113682e20">getRoutesToASBoundaryRouter</a> (const std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;fromRoutingTable, <a class="el" href="namespace_o_s_p_f.html#adbcc14dbfc5290248d3f865bd3a56af4">OSPF::RouterID</a> <a class="el" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9">routerID</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an std::vector of routes leading to the AS Boundary <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a> identified by asbrRouterID from the input fromRoutingTable.  <a href="#af137b28d57bdc2e96f8c454113682e20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#ad87f546ac823bb4f9cff0454a6fe1dc8">pruneASBoundaryRouterEntries</a> (std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;asbrEntries) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prunes the input std::vector of RoutingTableEntries according to the RFC2328 Section 16.4.1.  <a href="#ad87f546ac823bb4f9cff0454a6fe1dc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#ab3274a2e9aa8cd3b559401f68f8b44ec">selectLeastCostRoutingEntry</a> (std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;entries) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the least cost <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> from the input std::vector of RoutingTableEntries.  <a href="#ab3274a2e9aa8cd3b559401f68f8b44ec"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_o_s_p_f.html#adbcc14dbfc5290248d3f865bd3a56af4">RouterID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9">routerID</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The router ID assigned by the IP layer.  <a href="#a3ebbdb2a44054edf297b21360de68cb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="namespace_o_s_p_f.html#a48c8e4d3af2a46ddb912740d4e2e91b1">AreaID</a>, <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5">areasByID</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of the contained areas with the AreaID as key.  <a href="#ab2c936939863bd82c6628c794e6409e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8">areas</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of the contained areas.  <a href="#a5ce9c0ecf94cbc5872c346750e4de6b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">LSAKeyType</a>, <br class="typebreak"/>
<a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> <br class="typebreak"/>
*, <a class="el" href="class_o_s_p_f_1_1_l_s_a_key_type___less.html">LSAKeyType_Less</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2">asExternalLSAsByID</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of the ASExternalLSAs advertised by this router.  <a href="#abbdacd52ab234eb19f6eeb24a06222c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36">asExternalLSAs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of the ASExternalLSAs advertised by this router.  <a href="#a20e18099b999ef4fd3eebca715173f36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="class_i_pv4_address.html">IPv4Address</a>, <br class="typebreak"/>
<a class="el" href="class_o_s_p_f_a_s_external_l_s_a_contents.html">OSPFASExternalLSAContents</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a6b43eee6bada1dbffd4e7ceb01efb58e">externalRoutes</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of the external route advertised by this router.  <a href="#a6b43eee6bada1dbffd4e7ceb01efb58e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_timer.html">OSPFTimer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5">ageTimer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Database age timer - fires every second.  <a href="#acafd411e92c5c3bc952daadbc0d53cf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090">routingTable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespace_o_s_p_f.html" title="All OSPF classes are in this namespace.">OSPF</a> routing table - contains more information than the one in the IP layer.  <a href="#aff527f73b1c4068c21abb9fe9dd9f090"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_s_p_f_1_1_message_handler.html">MessageHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a532e99a63a766b3aabc007fd929fb48f">messageHandler</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The message dispatcher class.  <a href="#a532e99a63a766b3aabc007fd929fb48f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_p_f_1_1_router.html#a10f71a71f20baa02d35f94d602758357">rfc1583Compatibility</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides whether to handle the preferred routing table entry to an AS boundary router as defined in RFC1583 or not.  <a href="#a10f71a71f20baa02d35f94d602758357"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Represents the full <a class="el" href="namespace_o_s_p_f.html" title="All OSPF classes are in this namespace.">OSPF</a> data structure as laid out in RFC2328. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a35bbf6cd398015ef42d76223e745ba2e"></a><!-- doxytag: member="OSPF::Router::Router" ref="a35bbf6cd398015ef42d76223e745ba2e" args="(RouterID id, cSimpleModule *containingModule)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_router.html#a35bbf6cd398015ef42d76223e745ba2e">OSPF::Router::Router</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_o_s_p_f.html#adbcc14dbfc5290248d3f865bd3a56af4">OSPF::RouterID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cSimpleModule *&#160;</td>
          <td class="paramname"><em>containingModule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<p>Initializes internal variables, adds a <a class="el" href="class_o_s_p_f_1_1_message_handler.html">MessageHandler</a> and starts the Database Age timer. </p>
<div class="fragment"><pre class="fragment">                                                                   :
    <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>(<span class="keywordtype">id</span>),
    <a class="code" href="class_o_s_p_f_1_1_router.html#a10f71a71f20baa02d35f94d602758357" title="Decides whether to handle the preferred routing table entry to an AS boundary router as defined in RF...">rfc1583Compatibility</a>(<span class="keyword">false</span>)
{
    <a class="code" href="class_o_s_p_f_1_1_router.html#a532e99a63a766b3aabc007fd929fb48f" title="The message dispatcher class.">messageHandler</a> = <span class="keyword">new</span> <a class="code" href="class_o_s_p_f_1_1_message_handler.html">OSPF::MessageHandler</a>(<span class="keyword">this</span>, containingModule);
    <a class="code" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5" title="Database age timer - fires every second.">ageTimer</a> = <span class="keyword">new</span> <a class="code" href="class_o_s_p_f_timer.html" title="Class generated from networklayer/ospfv2/OSPFTimer.msg by opp_msgc.">OSPFTimer</a>();
    <a class="code" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5" title="Database age timer - fires every second.">ageTimer</a>-&gt;<a class="code" href="class_o_s_p_f_timer.html#ae58f4bfc17456426771da0bcd00e58f8">setTimerKind</a>(<a class="code" href="_o_s_p_f_timer__m_8h.html#a849e21fd541ff90a1e41cbe36d769f01a86afc7e57281131d342edf76e9c28c84">DATABASE_AGE_TIMER</a>);
    <a class="code" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5" title="Database age timer - fires every second.">ageTimer</a>-&gt;setContextPointer(<span class="keyword">this</span>);
    <a class="code" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5" title="Database age timer - fires every second.">ageTimer</a>-&gt;setName(<span class="stringliteral">&quot;OSPF::Router::DatabaseAgeTimer&quot;</span>);
    <a class="code" href="class_o_s_p_f_1_1_router.html#a532e99a63a766b3aabc007fd929fb48f" title="The message dispatcher class.">messageHandler</a>-&gt;<a class="code" href="class_o_s_p_f_1_1_message_handler.html#a255276f12e233566a769fe286335fd21">startTimer</a>(<a class="code" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5" title="Database age timer - fires every second.">ageTimer</a>, 1.0);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a144111945c866cda3bcd1b3c9feed99b"></a><!-- doxytag: member="OSPF::Router::~Router" ref="a144111945c866cda3bcd1b3c9feed99b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_router.html#a144111945c866cda3bcd1b3c9feed99b">OSPF::Router::~Router</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>Clears all LSA lists and kills the Database Age timer. </p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
        <span class="keyword">delete</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i];
    }
    <span class="keywordtype">long</span> lsaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> j = 0; j &lt; lsaCount; j++) {
        <span class="keyword">delete</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[j];
    }
    <span class="keywordtype">long</span> routeCount = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> k = 0; k &lt; routeCount; k++) {
        <span class="keyword">delete</span> <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k];
    }
    <a class="code" href="class_o_s_p_f_1_1_router.html#a532e99a63a766b3aabc007fd929fb48f" title="The message dispatcher class.">messageHandler</a>-&gt;<a class="code" href="class_o_s_p_f_1_1_message_handler.html#a6b2999ff530b75cb6e98473a5344f0cd">clearTimer</a>(<a class="code" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5" title="Database age timer - fires every second.">ageTimer</a>);
    <span class="keyword">delete</span> <a class="code" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5" title="Database age timer - fires every second.">ageTimer</a>;
    <span class="keyword">delete</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a532e99a63a766b3aabc007fd929fb48f" title="The message dispatcher class.">messageHandler</a>;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af76d3ec7f1fee3f8e499b28c6fea1fa3"></a><!-- doxytag: member="OSPF::Router::addArea" ref="af76d3ec7f1fee3f8e499b28c6fea1fa3" args="(Area *area)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_o_s_p_f_1_1_router.html#af76d3ec7f1fee3f8e499b28c6fea1fa3">OSPF::Router::addArea</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_s_p_f_1_1_area.html">OSPF::Area</a> *&#160;</td>
          <td class="paramname"><em>area</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a new <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> to the <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> list. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">area</td><td>[in] The <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="class_o_s_p_f_routing.html#a89163d4bb7adcd8c740903e151904f74">OSPFRouting::loadAreaFromXML()</a>.</p>
<div class="fragment"><pre class="fragment">{

    area-&gt;<a class="code" href="class_o_s_p_f_1_1_area.html#a1f1c5176055bb110943b0d508f0fbb57">setRouter</a>(<span class="keyword">this</span>);
    <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>[area-&gt;<a class="code" href="class_o_s_p_f_1_1_area.html#a7271107db6ddbec5feece06f2a503706">getAreaID</a>()] = area;
    <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.push_back(area);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0065bc8df3b748d831c4ee32131395c8"></a><!-- doxytag: member="OSPF::Router::addExternalRouteInIPTable" ref="a0065bc8df3b748d831c4ee32131395c8" args="(IPv4Address networkAddress, const OSPFASExternalLSAContents &amp;externalRouteContents, int ifIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_o_s_p_f_1_1_router.html#a0065bc8df3b748d831c4ee32131395c8">OSPF::Router::addExternalRouteInIPTable</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv4_address.html">IPv4Address</a>&#160;</td>
          <td class="paramname"><em>networkAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_s_p_f_a_s_external_l_s_a_contents.html">OSPFASExternalLSAContents</a> &amp;&#160;</td>
          <td class="paramname"><em>externalRouteContents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ifIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an AS External Route in IPRoutingTable. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">networkAddress</td><td>[in] The external route's network address. </td></tr>
    <tr><td class="paramname">externalRouteContents</td><td>[in] Route configuration data for the external route. </td></tr>
    <tr><td class="paramname">ifIndex</td><td>[in] </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_i_routing_table.html" title="A C++ interface to abstract the functionality of IRoutingTable.">IRoutingTable</a>* simRoutingTable = <a class="code" href="class_routing_table_access.html" title="Gives access to the IRoutingTable.">RoutingTableAccess</a>().<a class="code" href="class_module_access.html#a46a82b1fa0e957eb42d29c8637df1f4f">get</a>();
    <a class="code" href="class_i_interface_table.html" title="A C++ interface to abstract the functionality of InterfaceTable.">IInterfaceTable</a>* simInterfaceTable = <a class="code" href="class_interface_table_access.html" title="Gives access to IInterfaceTable.">InterfaceTableAccess</a>().<a class="code" href="class_module_access.html#a46a82b1fa0e957eb42d29c8637df1f4f">get</a>();
    <span class="keywordtype">int</span> routingEntryNumber = simRoutingTable-&gt;<a class="code" href="class_i_routing_table.html#ada2fac98d1d1c80c291be239b075c63b" title="Returns the total number of unicast routes.">getNumRoutes</a>();
    <span class="keywordtype">bool</span> inRoutingTable = <span class="keyword">false</span>;

    <span class="comment">// add the external route to the IPv4 routing table if it was not added by another module</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; routingEntryNumber; i++) {
        <span class="keyword">const</span> <a class="code" href="class_i_pv4_route.html" title="IPv4 unicast route in IRoutingTable.">IPv4Route</a> *entry = simRoutingTable-&gt;<a class="code" href="class_i_routing_table.html#a0f5f8297974432af7092a3ca19b0217e" title="Returns the kth route.">getRoute</a>(i);
        <span class="keywordflow">if</span> ((entry-&gt;<a class="code" href="class_i_pv4_route.html#a4982ef0132d4e1560371231b7c11cf8c" title="Destination address prefix to match.">getDestination</a>() == networkAddress)
                &amp;&amp; (entry-&gt;<a class="code" href="class_i_pv4_route.html#ac7d8f045f17b54b9d7e364cd525ba9ae" title="Represents length of prefix to match.">getNetmask</a>() == externalRouteContents.<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#a6a0d7bdb279abb7fa1a3d44622c0ff60">getNetworkMask</a>())) <span class="comment">//TODO is it enough?</span>
        {
            inRoutingTable = <span class="keyword">true</span>;
            <span class="keywordflow">break</span>;
        }
    }

    <span class="keywordflow">if</span> (!inRoutingTable)
    {
        <a class="code" href="class_i_pv4_route.html" title="IPv4 unicast route in IRoutingTable.">IPv4Route</a>* entry = <span class="keyword">new</span> <a class="code" href="class_i_pv4_route.html" title="IPv4 unicast route in IRoutingTable.">IPv4Route</a>();
        entry-&gt;<a class="code" href="class_i_pv4_route.html#a75d1011d4002c8a9503f3a42aff66c70">setDestination</a>(networkAddress);
        entry-&gt;<a class="code" href="class_i_pv4_route.html#a625acf9119fbc2bd5255c56096a36d38">setNetmask</a>(externalRouteContents.<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#a6a0d7bdb279abb7fa1a3d44622c0ff60">getNetworkMask</a>());
        entry-&gt;<a class="code" href="class_i_pv4_route.html#af7fc0b9d45d7fcbe603b679993e38ee5">setInterface</a>(simInterfaceTable-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7" title="Returns an interface by its Id.">getInterfaceById</a>(ifIndex));
        entry-&gt;<a class="code" href="class_i_pv4_route.html#a2213017b93a2ee8b31dc5f38502f6166">setSource</a>(<a class="code" href="class_i_pv4_route.html#a01abe3b809ba83ebbb0a3f01f6919683aabff650af84b9bbf5288d2193aea03e4" title="managed by the given routing protocol">IPv4Route::OSPF</a>);
        entry-&gt;<a class="code" href="class_i_pv4_route.html#a835720d0f2b89896063b1296d85c57cc">setMetric</a>(<a class="code" href="_o_s_p_fcommon_8h.html#a284b2eb3a644cfe22d046c1abab9f5ee">OSPF_BGP_DEFAULT_COST</a>);
        simRoutingTable-&gt;<a class="code" href="class_i_routing_table.html#ad7be1ebe567f40bca667ba0f33a2ca8d" title="Adds a route to the routing table.">addRoute</a>(entry);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad98dc1515ff6fed37dfc3097a5e68e21"></a><!-- doxytag: member="OSPF::Router::addRoutingTableEntry" ref="ad98dc1515ff6fed37dfc3097a5e68e21" args="(RoutingTableEntry *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_o_s_p_f_1_1_router.html#ad98dc1515ff6fed37dfc3097a5e68e21">OSPF::Router::addRoutingTableEntry</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.push_back(entry); }
</pre></div>
</div>
</div>
<a class="anchor" id="ac1b3c9efa50298911e7548c7cf2b9929"></a><!-- doxytag: member="OSPF::Router::addWatches" ref="ac1b3c9efa50298911e7548c7cf2b9929" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_o_s_p_f_1_1_router.html#ac1b3c9efa50298911e7548c7cf2b9929">OSPF::Router::addWatches</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds OMNeT++ watches for the routerID, the list of Areas and the list of AS External LSAs. </p>

<p>Referenced by <a class="el" href="class_o_s_p_f_routing.html#a757ca2b86873671c421c65e092630f42">OSPFRouting::initialize()</a>.</p>
<div class="fragment"><pre class="fragment">{
    WATCH(<a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>);
    WATCH_PTRVECTOR(<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>);
    WATCH_PTRVECTOR(<a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>);
    WATCH_PTRVECTOR(<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="af932cd6d5b44b4cd87599aa20e7dd588"></a><!-- doxytag: member="OSPF::Router::ageDatabase" ref="af932cd6d5b44b4cd87599aa20e7dd588" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_o_s_p_f_1_1_router.html#af932cd6d5b44b4cd87599aa20e7dd588">OSPF::Router::ageDatabase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ages the LSAs in the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>'s database. </p>
<p>This method is called on every firing of the DATABASE_AGE_TIMER(every second). </p>
<dl class="see"><dt><b>See also:</b></dt><dd>RFC2328 Section 14. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> lsaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>.size();
    <span class="keywordtype">bool</span> shouldRebuildRoutingTable = <span class="keyword">false</span>;

    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; lsaCount; i++) {
        <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> lsAge = <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[i]-&gt;getHeader().getLsAge();
        <span class="keywordtype">bool</span> selfOriginated = (<a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[i]-&gt;getHeader().getAdvertisingRouter() == <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>);
        <span class="keywordtype">bool</span> unreachable = <a class="code" href="class_o_s_p_f_1_1_router.html#a083894f1412443f07466e939a64fa29b" title="Returns true if the destination described by the input lsa is in the routing table, false otherwise.">isDestinationUnreachable</a>(<a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[i]);
        <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>* lsa = <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[i];

        <span class="keywordflow">if</span> ((selfOriginated &amp;&amp; (lsAge &lt; (<a class="code" href="_o_s_p_fcommon_8h.html#ab08ddbd72ec04be1ff6959a492fc3795">LS_REFRESH_TIME</a> - 1))) || (!selfOriginated &amp;&amp; (lsAge &lt; (<a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a> - 1)))) {
            lsa-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a9851dc72d585835bfcffa08412c33f99">setLsAge</a>(lsAge + 1);
            <span class="keywordflow">if</span> ((lsAge + 1) % <a class="code" href="_o_s_p_fcommon_8h.html#a1dae649919191832d818cf9bba6be0e4">CHECK_AGE</a> == 0) {
                <span class="keywordflow">if</span> (!lsa-&gt;<a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html#a98bdec0513c105c9c30d45a6b38185f8">validateLSChecksum</a>()) {
                    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Invalid LS checksum. Memory error detected!\n&quot;</span>;
                }
            }
            lsa-&gt;<a class="code" href="class_o_s_p_f_1_1_l_s_a_tracking_info.html#a2a9bb2304005f0e95c44dfa3472efe48">incrementInstallTime</a>();
        }
        <span class="keywordflow">if</span> (selfOriginated &amp;&amp; (lsAge == (<a class="code" href="_o_s_p_fcommon_8h.html#ab08ddbd72ec04be1ff6959a492fc3795">LS_REFRESH_TIME</a> - 1))) {
            <span class="keywordflow">if</span> (unreachable) {
                lsa-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a9851dc72d585835bfcffa08412c33f99">setLsAge</a>(<a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a>);
                <a class="code" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4" title="Floods out the input lsa on a set of Interfaces.">floodLSA</a>(lsa, <a class="code" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">OSPF::BACKBONE_AREAID</a>);
                lsa-&gt;<a class="code" href="class_o_s_p_f_1_1_l_s_a_tracking_info.html#a2a9bb2304005f0e95c44dfa3472efe48">incrementInstallTime</a>();
            } <span class="keywordflow">else</span> {
                <span class="keywordtype">long</span> sequenceNumber = lsa-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#aa1fa1df57d84e20fef93e765a587ff1c">getLsSequenceNumber</a>();
                <span class="keywordflow">if</span> (sequenceNumber == <a class="code" href="_o_s_p_fcommon_8h.html#a35f49b34e56993fe20d3a21d144c16d3">MAX_SEQUENCE_NUMBER</a>) {
                    lsa-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a9851dc72d585835bfcffa08412c33f99">setLsAge</a>(<a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a>);
                    <a class="code" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4" title="Floods out the input lsa on a set of Interfaces.">floodLSA</a>(lsa, <a class="code" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">OSPF::BACKBONE_AREAID</a>);
                    lsa-&gt;<a class="code" href="class_o_s_p_f_1_1_l_s_a_tracking_info.html#a2a9bb2304005f0e95c44dfa3472efe48">incrementInstallTime</a>();
                } <span class="keywordflow">else</span> {
                    <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>* newLSA = <a class="code" href="class_o_s_p_f_1_1_router.html#a2aded30c394db977ffde8237065514e8" title="Originates a new AS External LSA based on the input lsa.">originateASExternalLSA</a>(lsa);

                    newLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#ad1dd1ce9ff9b1c59f8638cdbb26b2d57">setLsSequenceNumber</a>(sequenceNumber + 1);
                    shouldRebuildRoutingTable |= lsa-&gt;<a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html#ae7a45e7b0cd3143946a5a2a534c851e2">update</a>(newLSA);
                    <span class="keyword">delete</span> newLSA;

                    <a class="code" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4" title="Floods out the input lsa on a set of Interfaces.">floodLSA</a>(lsa, <a class="code" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">OSPF::BACKBONE_AREAID</a>);
                }
            }
        }
        <span class="keywordflow">if</span> (!selfOriginated &amp;&amp; (lsAge == <a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a> - 1)) {
            lsa-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a9851dc72d585835bfcffa08412c33f99">setLsAge</a>(<a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a>);
            <a class="code" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4" title="Floods out the input lsa on a set of Interfaces.">floodLSA</a>(lsa, <a class="code" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">OSPF::BACKBONE_AREAID</a>);
            lsa-&gt;<a class="code" href="class_o_s_p_f_1_1_l_s_a_tracking_info.html#a2a9bb2304005f0e95c44dfa3472efe48">incrementInstallTime</a>();
        }
        <span class="keywordflow">if</span> (lsAge == <a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a>) {
            <a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a> lsaKey;

            lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a> = lsa-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a5ca4d451e700f5633b917bd547433260">getLinkStateID</a>();
            lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = lsa-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#afdeb8080774e4879f5c761fdbb1757fc">getAdvertisingRouter</a>();

            <span class="keywordflow">if</span> (!<a class="code" href="class_o_s_p_f_1_1_router.html#a7ea7fbacbe22d11dc419d6526e1d2dec" title="Returns true if there&#39;s at least one LSA on any Neighbor&#39;s retransmission list identified by the inpu...">isOnAnyRetransmissionList</a>(lsaKey) &amp;&amp;
                !<a class="code" href="class_o_s_p_f_1_1_router.html#aa322d6ee424b77e7f22ef3e05681baea" title="Returns true if any Neighbor on any Interface in any of the Router&#39;s Areas is in any of the input sta...">hasAnyNeighborInStates</a>(<a class="code" href="class_o_s_p_f_1_1_neighbor.html#abe30518a64009a9ae44944c1036a4c0aad5cc030cacf3612d64c1d30c2b27a63f">OSPF::Neighbor::EXCHANGE_STATE</a> | <a class="code" href="class_o_s_p_f_1_1_neighbor.html#abe30518a64009a9ae44944c1036a4c0aa446b2e6cb8487496c6a2ed568fb74f08">OSPF::Neighbor::LOADING_STATE</a>))
            {
                <span class="keywordflow">if</span> (!selfOriginated || unreachable) {
                    <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.erase(lsaKey);
                    <span class="keyword">delete</span> lsa;
                    <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[i] = <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
                    shouldRebuildRoutingTable = <span class="keyword">true</span>;
                } <span class="keywordflow">else</span> {
                    <span class="keywordflow">if</span> (lsa-&gt;<a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html#a9a3b17de403910bb57d802f106a94bbc">getPurgeable</a>()) {
                        <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.erase(lsaKey);
                        <span class="keyword">delete</span> lsa;
                        <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[i] = <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
                        shouldRebuildRoutingTable = <span class="keyword">true</span>;
                    } <span class="keywordflow">else</span> {
                        <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>* newLSA = <a class="code" href="class_o_s_p_f_1_1_router.html#a2aded30c394db977ffde8237065514e8" title="Originates a new AS External LSA based on the input lsa.">originateASExternalLSA</a>(lsa);
                        <span class="keywordtype">long</span> sequenceNumber = lsa-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#aa1fa1df57d84e20fef93e765a587ff1c">getLsSequenceNumber</a>();

                        newLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#ad1dd1ce9ff9b1c59f8638cdbb26b2d57">setLsSequenceNumber</a>((sequenceNumber == <a class="code" href="_o_s_p_fcommon_8h.html#a35f49b34e56993fe20d3a21d144c16d3">MAX_SEQUENCE_NUMBER</a>) ? <a class="code" href="_o_s_p_fcommon_8h.html#ad441394da087bc61e24a5b99455c5589">INITIAL_SEQUENCE_NUMBER</a> : sequenceNumber + 1);
                        shouldRebuildRoutingTable |= lsa-&gt;<a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html#ae7a45e7b0cd3143946a5a2a534c851e2">update</a>(newLSA);
                        <span class="keyword">delete</span> newLSA;

                        <a class="code" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4" title="Floods out the input lsa on a set of Interfaces.">floodLSA</a>(lsa, <a class="code" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">OSPF::BACKBONE_AREAID</a>);
                    }
                }
            }
        }
    }

    std::vector&lt;ASExternalLSA*&gt;::iterator it = <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>.begin();
    <span class="keywordflow">while</span> (it != <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>.end()) {
        <span class="keywordflow">if</span> ((*it) == <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
            it = <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>.erase(it);
        } <span class="keywordflow">else</span> {
            it++;
        }
    }

    <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> j = 0; j &lt; areaCount; j++) {
        <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[j]-&gt;ageDatabase();
    }
    <a class="code" href="class_o_s_p_f_1_1_router.html#a532e99a63a766b3aabc007fd929fb48f" title="The message dispatcher class.">messageHandler</a>-&gt;<a class="code" href="class_o_s_p_f_1_1_message_handler.html#a255276f12e233566a769fe286335fd21">startTimer</a>(<a class="code" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5" title="Database age timer - fires every second.">ageTimer</a>, 1.0);

    <span class="keywordflow">if</span> (shouldRebuildRoutingTable) {
        <a class="code" href="class_o_s_p_f_1_1_router.html#af849f36506ebf49917f4a7f4ebdbcf53" title="Rebuilds the routing table from scratch(based on the LSA database).">rebuildRoutingTable</a>();
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6aac8011e1bbf8166902e5ba4897684e"></a><!-- doxytag: member="OSPF::Router::calculateASExternalRoutes" ref="a6aac8011e1bbf8166902e5ba4897684e" args="(std::vector&lt; RoutingTableEntry * &gt; &amp;newRoutingTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_o_s_p_f_1_1_router.html#a6aac8011e1bbf8166902e5ba4897684e">OSPF::Router::calculateASExternalRoutes</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>newRoutingTable</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the AS External Routes from the ASExternalLSAs in the database. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newRoutingTable</td><td>[in/out] Push the new RoutingTableEntries into this routing table, and also use this for path calculations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>RFC2328 Section 16.4. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// see RFC 2328 16.4.</span>
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lsaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>.size();
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i;

    <span class="keywordflow">for</span> (i = 0; i &lt; lsaCount; i++) {
        <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>* currentLSA = <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[i];
        <a class="code" href="class_o_s_p_f_l_s_a_header.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFLSAHeader</a>&amp; currentHeader = currentLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>();
        <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> externalCost = currentLSA-&gt;<a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html#a34f5913c38930cb4098b1b5b2ceca1bb">getContents</a>().<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#a9158b3adccf5864d8806813976f44b38">getRouteCost</a>();
        <a class="code" href="class_i_pv4_address.html" title="IPv4 address.">OSPF::RouterID</a> originatingRouter = currentHeader.<a class="code" href="class_o_s_p_f_l_s_a_header.html#afdeb8080774e4879f5c761fdbb1757fc">getAdvertisingRouter</a>();

        <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* preferredEntry = <a class="code" href="class_o_s_p_f_1_1_router.html#a63a7808c1dc5f74983f800582a5992e4" title="Selects the preferred routing table entry for the input LSA(which is either an ASExternalLSA or a Sum...">getPreferredEntry</a>(*currentLSA, <span class="keyword">true</span>, &amp;newRoutingTable);
        <span class="keywordflow">if</span> (preferredEntry == <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
            <span class="keywordflow">continue</span>;
        }

        <a class="code" href="class_i_pv4_address.html" title="IPv4 address.">IPv4Address</a> destination = currentHeader.<a class="code" href="class_o_s_p_f_l_s_a_header.html#a5ca4d451e700f5633b917bd547433260">getLinkStateID</a>() &amp; currentLSA-&gt;<a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html#a34f5913c38930cb4098b1b5b2ceca1bb">getContents</a>().<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#a6a0d7bdb279abb7fa1a3d44622c0ff60">getNetworkMask</a>();

        <a class="code" href="namespace_o_s_p_f.html#a4a99812a2d079df0f7208f2740cdb0ad">Metric</a> preferredCost = preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ae88c6036122cdd9000332145c1b96859">getCost</a>();
        <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* destinationEntry = <a class="code" href="class_o_s_p_f_1_1_router.html#af37b73461ea85b76af17738f3b21d39f" title="Do a lookup in either the input OSPF routing table, or if it&#39;s NULL then in the Router&#39;s own routing ...">lookup</a>(destination, &amp;newRoutingTable);   <span class="comment">// (5)</span>
        <span class="keywordflow">if</span> (destinationEntry == <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
            <span class="keywordtype">bool</span> type2ExternalMetric = currentLSA-&gt;<a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html#a34f5913c38930cb4098b1b5b2ceca1bb">getContents</a>().<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#a516562d1adb3fa4b65131d826a93de4c">getE_ExternalMetricType</a>();
            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextHopCount = preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a3440f27cd5cd58f1815d7f0f79122924">getNextHopCount</a>();
            <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* newEntry = <span class="keyword">new</span> <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>;

            newEntry-&gt;<a class="code" href="class_i_pv4_route.html#a75d1011d4002c8a9503f3a42aff66c70">setDestination</a>(destination);
            newEntry-&gt;<a class="code" href="class_i_pv4_route.html#a625acf9119fbc2bd5255c56096a36d38">setNetmask</a>(currentLSA-&gt;<a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html#a34f5913c38930cb4098b1b5b2ceca1bb">getContents</a>().<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#a6a0d7bdb279abb7fa1a3d44622c0ff60">getNetworkMask</a>());
            newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ae78f14a2e3bd0ec9ae05acb741046e1f">setArea</a>(preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a5941dbf354e048d57e44692cfa27fb66">getArea</a>());
            newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a56347be9b6f6283980d3ab0e78bc7cfe">setPathType</a>(type2ExternalMetric ? <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254ab4a383f4abb1e72764d48d0a2c2bce8f">OSPF::RoutingTableEntry::TYPE2_EXTERNAL</a> : <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a68a12b5f95e47208b17658ba176402fa">OSPF::RoutingTableEntry::TYPE1_EXTERNAL</a>);
            <span class="keywordflow">if</span> (type2ExternalMetric) {
                newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a21508655875b4163673c01d801ed2d36">setCost</a>(preferredCost);
                newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a85ff4d8d73e389b820d8fe19fcaef75c">setType2Cost</a>(externalCost);
            } <span class="keywordflow">else</span> {
                newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a21508655875b4163673c01d801ed2d36">setCost</a>(preferredCost + externalCost);
            }
            newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ad6f0c1c2c3eebf202e43ba43bf5dbc1e">setDestinationType</a>(<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a8b5b8d21ccec069a781e4f4f4eca9dca">OSPF::RoutingTableEntry::NETWORK_DESTINATION</a>);
            newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a1343927aac37de7d553102ebf461d642">setOptionalCapabilities</a>(currentHeader.<a class="code" href="class_o_s_p_f_l_s_a_header.html#a49c67b283f8c7564d2a18500729c604f">getLsOptions</a>());
            newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ac5638ac4934f8d73bb037d5b07fe4f97">setLinkStateOrigin</a>(currentLSA);

            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; nextHopCount; j++) {
                <a class="code" href="namespace_b_g_p.html#af008460b49e37bb4d322bd4614d7ce70">NextHop</a> nextHop = preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a55dbf3f6153e23118769aace38f2d4c4">getNextHop</a>(j);

                nextHop.<a class="code" href="struct_o_s_p_f_1_1_next_hop.html#a8129ab4ea58affbb888039901cd7b311">advertisingRouter</a> = originatingRouter;
                newEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#acd72df6324bc2a48122f035f01a19b3e">addNextHop</a>(nextHop);
            }

            newRoutingTable.push_back(newEntry);
        } <span class="keywordflow">else</span> {
            <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254">OSPF::RoutingTableEntry::RoutingPathType</a> destinationPathType = destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aa2863a46a8edb4a9441df81fc4c37c92">getPathType</a>();
            <span class="keywordtype">bool</span> type2ExternalMetric = currentLSA-&gt;<a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html#a34f5913c38930cb4098b1b5b2ceca1bb">getContents</a>().<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#a516562d1adb3fa4b65131d826a93de4c">getE_ExternalMetricType</a>();
            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextHopCount = preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a3440f27cd5cd58f1815d7f0f79122924">getNextHopCount</a>();

            <span class="keywordflow">if</span> ((destinationPathType == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a3c76f6904ab261d6c8b709c7078a957f">OSPF::RoutingTableEntry::INTRAAREA</a>) ||
                (destinationPathType == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a3877847d7f354cfef92ff2352121aae4">OSPF::RoutingTableEntry::INTERAREA</a>))   <span class="comment">// (6) (a)</span>
            {
                <span class="keywordflow">continue</span>;
            }

            <span class="keywordflow">if</span> (((destinationPathType == OSPF::RoutingTableEntry::TYPE1_EXTERNAL) &amp;&amp;
                 (type2ExternalMetric)) ||
                ((destinationPathType == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254ab4a383f4abb1e72764d48d0a2c2bce8f">OSPF::RoutingTableEntry::TYPE2_EXTERNAL</a>) &amp;&amp;
                 (type2ExternalMetric) &amp;&amp;
                 (destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a2ef7b5c682f16baadbee9ce1aaa13083">getType2Cost</a>() &lt; externalCost))) <span class="comment">// (6) (b)</span>
            {
                <span class="keywordflow">continue</span>;
            }

            <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* destinationPreferredEntry = <a class="code" href="class_o_s_p_f_1_1_router.html#a63a7808c1dc5f74983f800582a5992e4" title="Selects the preferred routing table entry for the input LSA(which is either an ASExternalLSA or a Sum...">getPreferredEntry</a>(*(destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a0cd6c6488e41a4e3601a5ce582e28a65">getLinkStateOrigin</a>()), <span class="keyword">false</span>, &amp;newRoutingTable);
            <span class="keywordflow">if</span> ((!<a class="code" href="class_o_s_p_f_1_1_router.html#a10f71a71f20baa02d35f94d602758357" title="Decides whether to handle the preferred routing table entry to an AS boundary router as defined in RF...">rfc1583Compatibility</a>) &amp;&amp;
                (destinationPreferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aa2863a46a8edb4a9441df81fc4c37c92">getPathType</a>() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a3c76f6904ab261d6c8b709c7078a957f">OSPF::RoutingTableEntry::INTRAAREA</a>) &amp;&amp;
                (destinationPreferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a5941dbf354e048d57e44692cfa27fb66">getArea</a>() != <a class="code" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">OSPF::BACKBONE_AREAID</a>) &amp;&amp;
                ((preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aa2863a46a8edb4a9441df81fc4c37c92">getPathType</a>() != <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a3c76f6904ab261d6c8b709c7078a957f">OSPF::RoutingTableEntry::INTRAAREA</a>) ||
                 (preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a5941dbf354e048d57e44692cfa27fb66">getArea</a>() == <a class="code" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">OSPF::BACKBONE_AREAID</a>)))
            {
                <span class="keywordflow">continue</span>;
            }

            <span class="keywordflow">if</span> ((((destinationPathType == OSPF::RoutingTableEntry::TYPE1_EXTERNAL) &amp;&amp;
                  (!type2ExternalMetric) &amp;&amp;
                  (destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ae88c6036122cdd9000332145c1b96859">getCost</a>() &lt; preferredCost + externalCost))) ||
                ((destinationPathType == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254ab4a383f4abb1e72764d48d0a2c2bce8f">OSPF::RoutingTableEntry::TYPE2_EXTERNAL</a>) &amp;&amp;
                 (type2ExternalMetric) &amp;&amp;
                 (destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a2ef7b5c682f16baadbee9ce1aaa13083">getType2Cost</a>() == externalCost) &amp;&amp;
                 (destinationPreferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ae88c6036122cdd9000332145c1b96859">getCost</a>() &lt; preferredCost)))
            {
                <span class="keywordflow">continue</span>;
            }

            <span class="keywordflow">if</span> (((destinationPathType == OSPF::RoutingTableEntry::TYPE1_EXTERNAL) &amp;&amp;
                 (!type2ExternalMetric) &amp;&amp;
                 (destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ae88c6036122cdd9000332145c1b96859">getCost</a>() == (preferredCost + externalCost))) ||
                ((destinationPathType == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254ab4a383f4abb1e72764d48d0a2c2bce8f">OSPF::RoutingTableEntry::TYPE2_EXTERNAL</a>) &amp;&amp;
                 (type2ExternalMetric) &amp;&amp;
                 (destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a2ef7b5c682f16baadbee9ce1aaa13083">getType2Cost</a>() == externalCost) &amp;&amp;
                 (destinationPreferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ae88c6036122cdd9000332145c1b96859">getCost</a>() == preferredCost)))   <span class="comment">// equal cost</span>
            {
                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; nextHopCount; j++) {
                    <span class="comment">// TODO: merge next hops, not add</span>
                    <a class="code" href="namespace_b_g_p.html#af008460b49e37bb4d322bd4614d7ce70">NextHop</a> nextHop = preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a55dbf3f6153e23118769aace38f2d4c4">getNextHop</a>(j);

                    nextHop.<a class="code" href="struct_o_s_p_f_1_1_next_hop.html#a8129ab4ea58affbb888039901cd7b311">advertisingRouter</a> = originatingRouter;
                    destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#acd72df6324bc2a48122f035f01a19b3e">addNextHop</a>(nextHop);
                }
                <span class="keywordflow">continue</span>;
            }

            <span class="comment">// LSA is better</span>
            destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ae78f14a2e3bd0ec9ae05acb741046e1f">setArea</a>(preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a5941dbf354e048d57e44692cfa27fb66">getArea</a>());
            destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a56347be9b6f6283980d3ab0e78bc7cfe">setPathType</a>(type2ExternalMetric ? <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254ab4a383f4abb1e72764d48d0a2c2bce8f">OSPF::RoutingTableEntry::TYPE2_EXTERNAL</a> : OSPF::RoutingTableEntry::TYPE1_EXTERNAL);
            <span class="keywordflow">if</span> (type2ExternalMetric) {
                destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a21508655875b4163673c01d801ed2d36">setCost</a>(preferredCost);
                destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a85ff4d8d73e389b820d8fe19fcaef75c">setType2Cost</a>(externalCost);
            } <span class="keywordflow">else</span> {
                destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a21508655875b4163673c01d801ed2d36">setCost</a>(preferredCost + externalCost);
            }
            destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ad6f0c1c2c3eebf202e43ba43bf5dbc1e">setDestinationType</a>(<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a8b5b8d21ccec069a781e4f4f4eca9dca">OSPF::RoutingTableEntry::NETWORK_DESTINATION</a>);
            destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a1343927aac37de7d553102ebf461d642">setOptionalCapabilities</a>(currentHeader.<a class="code" href="class_o_s_p_f_l_s_a_header.html#a49c67b283f8c7564d2a18500729c604f">getLsOptions</a>());
            destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a52141aee9574332c7fa4094cd06e22f7">clearNextHops</a>();

            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; nextHopCount; j++) {
                <a class="code" href="namespace_b_g_p.html#af008460b49e37bb4d322bd4614d7ce70">NextHop</a> nextHop = preferredEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a55dbf3f6153e23118769aace38f2d4c4">getNextHop</a>(j);

                nextHop.<a class="code" href="struct_o_s_p_f_1_1_next_hop.html#a8129ab4ea58affbb888039901cd7b311">advertisingRouter</a> = originatingRouter;
                destinationEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#acd72df6324bc2a48122f035f01a19b3e">addNextHop</a>(nextHop);
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab5305a0128639b180c5846ec009127f0"></a><!-- doxytag: member="OSPF::Router::findASExternalLSA" ref="ab5305a0128639b180c5846ec009127f0" args="(LSAKeyType lsaKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a> * <a class="el" href="class_o_s_p_f_1_1_router.html#ab5305a0128639b180c5846ec009127f0">OSPF::Router::findASExternalLSA</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a>&#160;</td>
          <td class="paramname"><em>lsaKey</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the AS External LSA identified by the input lsaKey in the database. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsaKey</td><td>[in] Look for the AS External LSA which is identified by this key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The pointer to the AS External LSA if it was found, NULL otherwise. </dd></dl>
<div class="fragment"><pre class="fragment">{
    std::map&lt;OSPF::LSAKeyType, OSPF::ASExternalLSA*, OSPF::LSAKeyType_Less&gt;::iterator lsaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.find(lsaKey);
    <span class="keywordflow">if</span> (lsaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.end()) {
        <span class="keywordflow">return</span> lsaIt-&gt;second;
    } <span class="keywordflow">else</span> {
        <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a24bf6814ed4f6ace80cbcdf2c9e79f50"></a><!-- doxytag: member="OSPF::Router::findASExternalLSA" ref="a24bf6814ed4f6ace80cbcdf2c9e79f50" args="(LSAKeyType lsaKey) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a> * <a class="el" href="class_o_s_p_f_1_1_router.html#ab5305a0128639b180c5846ec009127f0">OSPF::Router::findASExternalLSA</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a>&#160;</td>
          <td class="paramname"><em>lsaKey</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the AS External LSA identified by the input lsaKey in the database. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsaKey</td><td>[in] Look for the AS External LSA which is identified by this key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The const pointer to the AS External LSA if it was found, NULL otherwise. </dd></dl>
<div class="fragment"><pre class="fragment">{
    std::map&lt;OSPF::LSAKeyType, OSPF::ASExternalLSA*, OSPF::LSAKeyType_Less&gt;::const_iterator lsaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.find(lsaKey);
    <span class="keywordflow">if</span> (lsaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.end()) {
        <span class="keywordflow">return</span> lsaIt-&gt;second;
    } <span class="keywordflow">else</span> {
        <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa2e591c3ef0241639b4e12b0cab7a8f9"></a><!-- doxytag: member="OSPF::Router::findLSA" ref="aa2e591c3ef0241639b4e12b0cab7a8f9" args="(LSAType lsaType, LSAKeyType lsaKey, AreaID areaID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_l_s_a.html">OSPFLSA</a> * <a class="el" href="class_o_s_p_f_1_1_router.html#aa2e591c3ef0241639b4e12b0cab7a8f9">OSPF::Router::findLSA</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_o_s_p_f_packet__m_8h.html#a13a450dbb578c4bd7714af8581c4f89b">LSAType</a>&#160;</td>
          <td class="paramname"><em>lsaType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a>&#160;</td>
          <td class="paramname"><em>lsaKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_p_f.html#a48c8e4d3af2a46ddb912740d4e2e91b1">OSPF::AreaID</a>&#160;</td>
          <td class="paramname"><em>areaID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the LSA identified by the input lsaKey in the database. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsaType</td><td>[in] Look for an LSA of this type. </td></tr>
    <tr><td class="paramname">lsaKey</td><td>[in] Look for the LSA which is identified by this key. </td></tr>
    <tr><td class="paramname">areaID</td><td>[in] In case of <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>, Network and Summary LSAs, look in the <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a>'s database identified by this parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The pointer to the LSA if it was found, NULL otherwise. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">switch</span> (lsaType) {
        <span class="keywordflow">case</span> <a class="code" href="_o_s_p_f_packet__m_8h.html#a13a450dbb578c4bd7714af8581c4f89ba364c69f32e2869591f3c446a7bd206c7">ROUTERLSA_TYPE</a>:
            {
                std::map&lt;OSPF::AreaID, OSPF::Area*&gt;::iterator areaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.find(areaID);
                <span class="keywordflow">if</span> (areaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.end()) {
                    <span class="keywordflow">return</span> areaIt-&gt;second-&gt;findRouterLSA(lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a>);
                }
            }
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="_o_s_p_f_packet__m_8h.html#a13a450dbb578c4bd7714af8581c4f89ba2fedfd48d61b390a26c947aebdc25b8d">NETWORKLSA_TYPE</a>:
            {
                std::map&lt;OSPF::AreaID, OSPF::Area*&gt;::iterator areaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.find(areaID);
                <span class="keywordflow">if</span> (areaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.end()) {
                    <span class="keywordflow">return</span> areaIt-&gt;second-&gt;findNetworkLSA(lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a>);
                }
            }
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="_o_s_p_f_packet__m_8h.html#a13a450dbb578c4bd7714af8581c4f89baa03619205be9ea7ba0299296dbe8fa38">SUMMARYLSA_NETWORKS_TYPE</a>:
        <span class="keywordflow">case</span> <a class="code" href="_o_s_p_f_packet__m_8h.html#a13a450dbb578c4bd7714af8581c4f89bad7e81ed4e05f467b7ca88c98f487662a">SUMMARYLSA_ASBOUNDARYROUTERS_TYPE</a>:
            {
                std::map&lt;OSPF::AreaID, OSPF::Area*&gt;::iterator areaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.find(areaID);
                <span class="keywordflow">if</span> (areaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.end()) {
                    <span class="keywordflow">return</span> areaIt-&gt;second-&gt;findSummaryLSA(lsaKey);
                }
            }
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="_o_s_p_f_packet__m_8h.html#a13a450dbb578c4bd7714af8581c4f89ba5a085d8393eb69080f4819ea84627021">AS_EXTERNAL_LSA_TYPE</a>:
            {
                <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#ab5305a0128639b180c5846ec009127f0" title="Find the AS External LSA identified by the input lsaKey in the database.">findASExternalLSA</a>(lsaKey);
            }
            <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>:
            ASSERT(<span class="keyword">false</span>);
            <span class="keywordflow">break</span>;
    }
    <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a053e23535ff2239aacd34782df554eb4"></a><!-- doxytag: member="OSPF::Router::floodLSA" ref="a053e23535ff2239aacd34782df554eb4" args="(OSPFLSA *lsa, AreaID areaID=BACKBONE_AREAID, Interface *intf=NULL, Neighbor *neighbor=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4">OSPF::Router::floodLSA</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_s_p_f_l_s_a.html">OSPFLSA</a> *&#160;</td>
          <td class="paramname"><em>lsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_p_f.html#a48c8e4d3af2a46ddb912740d4e2e91b1">OSPF::AreaID</a>&#160;</td>
          <td class="paramname"><em>areaID</em> = <code><a class="el" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">BACKBONE_AREAID</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_s_p_f_1_1_interface.html">OSPF::Interface</a> *&#160;</td>
          <td class="paramname"><em>intf</em> = <code><a class="el" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_s_p_f_1_1_neighbor.html">OSPF::Neighbor</a> *&#160;</td>
          <td class="paramname"><em>neighbor</em> = <code><a class="el" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Floods out the input lsa on a set of Interfaces. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>RFC2328 Section 13.3. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsa</td><td>[in] The LSA to be flooded out. </td></tr>
    <tr><td class="paramname">areaID</td><td>[in] If the lsa is a <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>, Network or Summary LSA, then flood it only in this <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a>. </td></tr>
    <tr><td class="paramname">intf</td><td>[in] The <a class="el" href="class_o_s_p_f_1_1_interface.html">Interface</a> this LSA arrived on. </td></tr>
    <tr><td class="paramname">neighbor</td><td>[in] The Nieghbor this LSA arrived from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the LSA was floooded back out on the receiving <a class="el" href="class_o_s_p_f_1_1_interface.html">Interface</a>, false otherwise. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> floodedBackOut = <span class="keyword">false</span>;

    <span class="keywordflow">if</span> (lsa != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
        <span class="keywordflow">if</span> (lsa-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a5ec5eaa7d91ea4e1447766fe076d7207">getLsType</a>() == <a class="code" href="_o_s_p_f_packet__m_8h.html#a13a450dbb578c4bd7714af8581c4f89ba5a085d8393eb69080f4819ea84627021">AS_EXTERNAL_LSA_TYPE</a>) {
            <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
            <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
                <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;getExternalRoutingCapability()) {
                    <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;<a class="code" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4" title="Floods out the input lsa on a set of Interfaces.">floodLSA</a>(lsa, intf, neighbor)) {
                        floodedBackOut = <span class="keyword">true</span>;
                    }
                }
            }
        } <span class="keywordflow">else</span> {
            std::map&lt;OSPF::AreaID, OSPF::Area*&gt;::iterator areaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.find(areaID);
            <span class="keywordflow">if</span> (areaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.end()) {
                floodedBackOut = areaIt-&gt;second-&gt;floodLSA(lsa, intf, neighbor);
            }
        }
    }

    <span class="keywordflow">return</span> floodedBackOut;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad388964cdec01c401c7f18437d00cd31"></a><!-- doxytag: member="OSPF::Router::getAreaByAddr" ref="ad388964cdec01c401c7f18437d00cd31" args="(IPv4Address address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_area.html">OSPF::Area</a> * <a class="el" href="class_o_s_p_f_1_1_router.html#ad388964cdec01c401c7f18437d00cd31">OSPF::Router::getAreaByAddr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv4_address.html">IPv4Address</a>&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> pointer from the <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> list which contains the input <a class="el" href="class_i_pv4.html" title="Implements the IPv4 protocol.">IPv4</a> address, NULL if there's no such area connected to the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>[in] The <a class="el" href="class_i_pv4.html" title="Implements the IPv4 protocol.">IPv4</a> address whose containing <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> we're looking for. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();

    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++)
    {
        <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;containsAddress(address))
            <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i];
    }

    <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abd611ae0dce1b3006eab26dd5b02a5af"></a><!-- doxytag: member="OSPF::Router::getAreaByID" ref="abd611ae0dce1b3006eab26dd5b02a5af" args="(AreaID areaID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_area.html">OSPF::Area</a> * <a class="el" href="class_o_s_p_f_1_1_router.html#abd611ae0dce1b3006eab26dd5b02a5af">OSPF::Router::getAreaByID</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_o_s_p_f.html#a48c8e4d3af2a46ddb912740d4e2e91b1">OSPF::AreaID</a>&#160;</td>
          <td class="paramname"><em>areaID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the pointer to the <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> identified by the input areaID, if it's on the <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> list, NULL otherwise. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">areaID</td><td>[in] The <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a> identifier. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="class_o_s_p_f_routing.html#abc7bbdfb6fe2ab158c64ec7c3579ccdd">OSPFRouting::loadHostRoute()</a>, <a class="el" href="class_o_s_p_f_routing.html#a65f22d4d3ea87506c07667d47f7b2d3b">OSPFRouting::loadInterfaceParameters()</a>, and <a class="el" href="class_o_s_p_f_routing.html#a10bcd85d5d26ce4e06c6f2b01bc6f420">OSPFRouting::loadVirtualLink()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::map&lt;OSPF::AreaID, OSPF::Area*&gt;::iterator areaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.find(areaID);
    <span class="keywordflow">if</span> (areaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.end()) {
        <span class="keywordflow">return</span> (areaIt-&gt;second);
    }
    <span class="keywordflow">else</span> {
        <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aabec2db341f674865b3a9e6393889371"></a><!-- doxytag: member="OSPF::Router::getAreaCount" ref="aabec2db341f674865b3a9e6393889371" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="class_o_s_p_f_1_1_router.html#aabec2db341f674865b3a9e6393889371">OSPF::Router::getAreaCount</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size(); }
</pre></div>
</div>
</div>
<a class="anchor" id="a3f6f54e668fb6f2f7298949bbcab43bf"></a><!-- doxytag: member="OSPF::Router::getASBoundaryRouter" ref="a3f6f54e668fb6f2f7298949bbcab43bf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_s_p_f_1_1_router.html#a3f6f54e668fb6f2f7298949bbcab43bf">OSPF::Router::getASBoundaryRouter</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a6b43eee6bada1dbffd4e7ceb01efb58e" title="A map of the external route advertised by this router.">externalRoutes</a>.size() &gt; 0); }
</pre></div>
</div>
</div>
<a class="anchor" id="a6647017c994ddead153bfda8cedc7c5f"></a><!-- doxytag: member="OSPF::Router::getASExternalLSA" ref="a6647017c994ddead153bfda8cedc7c5f" args="(unsigned long i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a>* <a class="el" href="class_o_s_p_f_1_1_router.html#a6647017c994ddead153bfda8cedc7c5f">OSPF::Router::getASExternalLSA</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_o_s_p_f_routing.html#a68ab10ea5288b5f659410267bc1fc261">OSPFRouting::checkExternalRoute()</a>, and <a class="el" href="class_o_s_p_f_1_1_neighbor.html#aee5542519eed20699c885345250999e0">OSPF::Neighbor::createDatabaseSummary()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[i]; }
</pre></div>
</div>
</div>
<a class="anchor" id="a2cf15dccf4ba9a099e7a754613951367"></a><!-- doxytag: member="OSPF::Router::getASExternalLSA" ref="a2cf15dccf4ba9a099e7a754613951367" args="(unsigned long i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a>* <a class="el" href="class_o_s_p_f_1_1_router.html#a6647017c994ddead153bfda8cedc7c5f">OSPF::Router::getASExternalLSA</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>[i]; }
</pre></div>
</div>
</div>
<a class="anchor" id="a83627b1e7011409dd355dfd004a8a3a8"></a><!-- doxytag: member="OSPF::Router::getASExternalLSACount" ref="a83627b1e7011409dd355dfd004a8a3a8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="class_o_s_p_f_1_1_router.html#a83627b1e7011409dd355dfd004a8a3a8">OSPF::Router::getASExternalLSACount</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_o_s_p_f_routing.html#a68ab10ea5288b5f659410267bc1fc261">OSPFRouting::checkExternalRoute()</a>, and <a class="el" href="class_o_s_p_f_1_1_neighbor.html#aee5542519eed20699c885345250999e0">OSPF::Neighbor::createDatabaseSummary()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>.size(); }
</pre></div>
</div>
</div>
<a class="anchor" id="a10e4eb37ccddff29e494db42e3c8debe"></a><!-- doxytag: member="OSPF::Router::getContainingAddressRange" ref="a10e4eb37ccddff29e494db42e3c8debe" args="(const IPv4AddressRange &amp;addressRange, bool *advertise=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">OSPF::IPv4AddressRange</a> <a class="el" href="class_o_s_p_f_1_1_router.html#a10e4eb37ccddff29e494db42e3c8debe">OSPF::Router::getContainingAddressRange</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">IPv4AddressRange</a> &amp;&#160;</td>
          <td class="paramname"><em>addressRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>advertise</em> = <code><a class="el" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scans through the router's areas' preconfigured address ranges and returns the one containing the input addressRange. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">addressRange</td><td>[in] The address range to look for. </td></tr>
    <tr><td class="paramname">advertise</td><td>[out] Whether the advertise flag is set in the returned preconfigured address range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The containing preconfigured address range if found, <a class="el" href="namespace_o_s_p_f.html#ab52eff5511df2676c0a8f83ae90e5898">OSPF::NULL_IPV4ADDRESSRANGE</a> otherwise. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
        <a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">OSPF::IPv4AddressRange</a> containingAddressRange = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;getContainingAddressRange(addressRange, advertise);
        <span class="keywordflow">if</span> (containingAddressRange != <a class="code" href="namespace_o_s_p_f.html#ab52eff5511df2676c0a8f83ae90e5898">OSPF::NULL_IPV4ADDRESSRANGE</a>) {
            <span class="keywordflow">return</span> containingAddressRange;
        }
    }
    <span class="keywordflow">if</span> (advertise != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
        *advertise = <span class="keyword">false</span>;
    }
    <span class="keywordflow">return</span> <a class="code" href="namespace_o_s_p_f.html#ab52eff5511df2676c0a8f83ae90e5898">OSPF::NULL_IPV4ADDRESSRANGE</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0142a9cc0f45692f0af116de386f9d6b"></a><!-- doxytag: member="OSPF::Router::getMessageHandler" ref="a0142a9cc0f45692f0af116de386f9d6b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_message_handler.html">MessageHandler</a>* <a class="el" href="class_o_s_p_f_1_1_router.html#a0142a9cc0f45692f0af116de386f9d6b">OSPF::Router::getMessageHandler</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_o_s_p_f_routing.html#acdf1e955f64a259cad0ac496e2c846a2">OSPFRouting::handleMessage()</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor_state_attempt.html#a7fdf9398c7aa4c3c9e62a07b5ec6d813">OSPF::NeighborStateAttempt::processEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor_state_two_way.html#a8a85fa068ab56b77f9e3dc8b992471c1">OSPF::NeighborStateTwoWay::processEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor_state_loading.html#a185dc004e5606b64e54b42d4c6d2b298">OSPF::NeighborStateLoading::processEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor_state_init.html#a743dc982745295e45c1cbeae415589a2">OSPF::NeighborStateInit::processEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor_state_full.html#a199b180197f62552c5183f856351b9be">OSPF::NeighborStateFull::processEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor_state_exchange_start.html#a00866a3515e614b6163541ebab346abe">OSPF::NeighborStateExchangeStart::processEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor_state_exchange.html#a84c85ba179d1549b335fdcc4326efa84">OSPF::NeighborStateExchange::processEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor_state_down.html#adbe22f81a055c5b3cb08105e71725e0e">OSPF::NeighborStateDown::processEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_interface_state_down.html#a80191cf50c52d0f032e20b556410e09c">OSPF::InterfaceStateDown::processEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_interface_state_waiting.html#a70f72d26276984f9fc7b039364b9e8e1">OSPF::InterfaceStateWaiting::processEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_interface_state_point_to_point.html#aa284d9d617fc3e6c1b6d582137c0ba3a">OSPF::InterfaceStatePointToPoint::processEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_interface_state_not_designated_router.html#a83973c35e252746c3b730e8dddf4bd45">OSPF::InterfaceStateNotDesignatedRouter::processEvent()</a>, <a class="el" href="class_o_s_p_f_1_1_interface_state_backup.html#a59ab622efe7e53d1679397906685e632">OSPF::InterfaceStateBackup::processEvent()</a>, and <a class="el" href="class_o_s_p_f_1_1_interface_state_designated_router.html#a438e79d72ff2fcde354fdfe8283aa71f">OSPF::InterfaceStateDesignatedRouter::processEvent()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a532e99a63a766b3aabc007fd929fb48f" title="The message dispatcher class.">messageHandler</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a9b4a204a6fbb8963e7f3be313a994166"></a><!-- doxytag: member="OSPF::Router::getNonVirtualInterface" ref="a9b4a204a6fbb8963e7f3be313a994166" args="(unsigned char ifIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_interface.html">OSPF::Interface</a> * <a class="el" href="class_o_s_p_f_1_1_router.html#a9b4a204a6fbb8963e7f3be313a994166">OSPF::Router::getNonVirtualInterface</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>ifIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the pointer of the physical <a class="el" href="class_o_s_p_f_1_1_interface.html">Interface</a> identified by the input interface index, NULL if the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a> doesn't have such an interface. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ifIndex</td><td>[in] The interface index to look for. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();

    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++)
    {
        <a class="code" href="class_o_s_p_f_1_1_interface.html">OSPF::Interface</a>* intf = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;getInterface(ifIndex);
        <span class="keywordflow">if</span> (intf != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
            <span class="keywordflow">return</span> intf;
        }
    }
    <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a63a7808c1dc5f74983f800582a5992e4"></a><!-- doxytag: member="OSPF::Router::getPreferredEntry" ref="a63a7808c1dc5f74983f800582a5992e4" args="(const OSPFLSA &amp;lsa, bool skipSelfOriginated, std::vector&lt; RoutingTableEntry * &gt; *fromRoutingTable=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a> * <a class="el" href="class_o_s_p_f_1_1_router.html#a63a7808c1dc5f74983f800582a5992e4">OSPF::Router::getPreferredEntry</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_s_p_f_l_s_a.html">OSPFLSA</a> &amp;&#160;</td>
          <td class="paramname"><em>lsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipSelfOriginated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; *&#160;</td>
          <td class="paramname"><em>fromRoutingTable</em> = <code><a class="el" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Selects the preferred routing table entry for the input LSA(which is either an <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> or a <a class="el" href="class_o_s_p_f_1_1_summary_l_s_a.html">SummaryLSA</a>) according to the algorithm defined in RFC2328 Section 16.4. </p>
<p>points(1) through(3). This method is used when calculating the AS external routes and also when originating an <a class="el" href="class_o_s_p_f_1_1_summary_l_s_a.html">SummaryLSA</a> for an AS Boundary <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsa</td><td>[in] The LSA describing the destination for which the preferred Routing Entry is sought for. </td></tr>
    <tr><td class="paramname">skipSelfOriginated</td><td>[in] Whether to disregard this LSA if it was self-originated. </td></tr>
    <tr><td class="paramname">fromRoutingTable</td><td>[in] The Routing Table from which to select the preferred <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a>. If it is NULL then the router's current routing table is used instead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The preferred <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a>, or NULL if no such entry exists. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>RFC2328 Section 16.4. points(1) through(3) </dd>
<dd>
<a class="el" href="class_o_s_p_f_1_1_area.html#a8cb54490f03e9a4a6b9743789b2212d0">OSPF::Area::originateSummaryLSA</a> </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// see RFC 2328 16.3. and 16.4.</span>
    <span class="keywordflow">if</span> (fromRoutingTable == <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
        fromRoutingTable = &amp;<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>;
    }

    <span class="keyword">const</span> <a class="code" href="class_o_s_p_f_l_s_a_header.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFLSAHeader</a>&amp; lsaHeader = lsa.<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>();
    <span class="keyword">const</span> <a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFASExternalLSA</a>* asExternalLSA = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span><a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFASExternalLSA</a>*<span class="keyword">&gt;</span> (&amp;lsa);
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> externalCost = (asExternalLSA != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) ? asExternalLSA-&gt;<a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html#a34f5913c38930cb4098b1b5b2ceca1bb">getContents</a>().<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#a9158b3adccf5864d8806813976f44b38">getRouteCost</a>() : 0;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> lsAge = lsaHeader.<a class="code" href="class_o_s_p_f_l_s_a_header.html#abfa986a01e651197c287f6ee1898e1a5">getLsAge</a>();
    <a class="code" href="class_i_pv4_address.html" title="IPv4 address.">OSPF::RouterID</a> originatingRouter = lsaHeader.<a class="code" href="class_o_s_p_f_l_s_a_header.html#afdeb8080774e4879f5c761fdbb1757fc">getAdvertisingRouter</a>();
    <span class="keywordtype">bool</span> selfOriginated = (originatingRouter == <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>);
    <a class="code" href="class_i_pv4_address.html" title="IPv4 address.">IPv4Address</a> forwardingAddress; <span class="comment">// 0.0.0.0</span>

    <span class="keywordflow">if</span> (asExternalLSA != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
        forwardingAddress = asExternalLSA-&gt;<a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html#a34f5913c38930cb4098b1b5b2ceca1bb">getContents</a>().<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#abaad1cfc2a0d75cd20c7bb449c999b87">getForwardingAddress</a>();
    }

    <span class="keywordflow">if</span> ((externalCost == <a class="code" href="_o_s_p_fcommon_8h.html#adae502e9fc4510696255aa68d1413fb1">LS_INFINITY</a>) || (lsAge == <a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a>) || (skipSelfOriginated &amp;&amp; selfOriginated)) { <span class="comment">// (1) and(2)</span>
        <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
    }

    <span class="keywordflow">if</span> (!<a class="code" href="class_o_s_p_f_1_1_router.html#a8ea3ed444f4cb7330e9be07daf522bef" title="Returns true if there is a route to the AS Boundary Router identified by asbrRouterID in the input in...">hasRouteToASBoundaryRouter</a>(*fromRoutingTable, originatingRouter)) { <span class="comment">// (3)</span>
        <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
    }

    <span class="keywordflow">if</span> (forwardingAddress.<a class="code" href="class_i_pv4_address.html#a76dbddd2575a9e91412b998512b45a2d" title="True if all four address bytes are zero.">isUnspecified</a>()) {   <span class="comment">// (3)</span>
        std::vector&lt;OSPF::RoutingTableEntry*&gt; asbrEntries = <a class="code" href="class_o_s_p_f_1_1_router.html#af137b28d57bdc2e96f8c454113682e20" title="Returns an std::vector of routes leading to the AS Boundary Router identified by asbrRouterID from th...">getRoutesToASBoundaryRouter</a>(*fromRoutingTable, originatingRouter);
        <span class="keywordflow">if</span> (!<a class="code" href="class_o_s_p_f_1_1_router.html#a10f71a71f20baa02d35f94d602758357" title="Decides whether to handle the preferred routing table entry to an AS boundary router as defined in RF...">rfc1583Compatibility</a>) {
            <a class="code" href="class_o_s_p_f_1_1_router.html#ad87f546ac823bb4f9cff0454a6fe1dc8" title="Prunes the input std::vector of RoutingTableEntries according to the RFC2328 Section 16...">pruneASBoundaryRouterEntries</a>(asbrEntries);
        }
        <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#ab3274a2e9aa8cd3b559401f68f8b44ec" title="Selects the least cost RoutingTableEntry from the input std::vector of RoutingTableEntries.">selectLeastCostRoutingEntry</a>(asbrEntries);
    } <span class="keywordflow">else</span> {
        <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* forwardEntry = <a class="code" href="class_o_s_p_f_1_1_router.html#af37b73461ea85b76af17738f3b21d39f" title="Do a lookup in either the input OSPF routing table, or if it&#39;s NULL then in the Router&#39;s own routing ...">lookup</a>(forwardingAddress, fromRoutingTable);

        <span class="keywordflow">if</span> (forwardEntry == <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
            <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
        }

        <span class="keywordflow">if</span> ((forwardEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aa2863a46a8edb4a9441df81fc4c37c92">getPathType</a>() != <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a3c76f6904ab261d6c8b709c7078a957f">OSPF::RoutingTableEntry::INTRAAREA</a>) &amp;&amp;
            (forwardEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aa2863a46a8edb4a9441df81fc4c37c92">getPathType</a>() != <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a3877847d7f354cfef92ff2352121aae4">OSPF::RoutingTableEntry::INTERAREA</a>))
        {
            <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
        }

        <span class="keywordflow">return</span> forwardEntry;
    }

    <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3eeb651fd988d86f63d811bb88a9c121"></a><!-- doxytag: member="OSPF::Router::getRFC1583Compatibility" ref="a3eeb651fd988d86f63d811bb88a9c121" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_s_p_f_1_1_router.html#a3eeb651fd988d86f63d811bb88a9c121">OSPF::Router::getRFC1583Compatibility</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a10f71a71f20baa02d35f94d602758357" title="Decides whether to handle the preferred routing table entry to an AS boundary router as defined in RF...">rfc1583Compatibility</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="abf4855bc5ad7dfb4a47d1aae3b003751"></a><!-- doxytag: member="OSPF::Router::getRouterID" ref="abf4855bc5ad7dfb4a47d1aae3b003751" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_o_s_p_f.html#adbcc14dbfc5290248d3f865bd3a56af4">RouterID</a> <a class="el" href="class_o_s_p_f_1_1_router.html#abf4855bc5ad7dfb4a47d1aae3b003751">OSPF::Router::getRouterID</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_interface_state.html#a6a9592a636f20c163e3af0f27bfedcb2">OSPF::InterfaceState::calculateDesignatedRouter()</a>, <a class="el" href="class_o_s_p_f_1_1_neighbor_state.html#a04b28a8b954660937a38409ecb7127e1">OSPF::NeighborState::changeState()</a>, and <a class="el" href="class_o_s_p_f_1_1_interface_state.html#a9f94bc7735d2a404e05eb7e26a38d033">OSPF::InterfaceState::changeState()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="af137b28d57bdc2e96f8c454113682e20"></a><!-- doxytag: member="OSPF::Router::getRoutesToASBoundaryRouter" ref="af137b28d57bdc2e96f8c454113682e20" args="(const std::vector&lt; RoutingTableEntry * &gt; &amp;fromRoutingTable, OSPF::RouterID routerID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a> * &gt; <a class="el" href="class_o_s_p_f_1_1_router.html#af137b28d57bdc2e96f8c454113682e20">OSPF::Router::getRoutesToASBoundaryRouter</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>fromRoutingTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_p_f.html#adbcc14dbfc5290248d3f865bd3a56af4">OSPF::RouterID</a>&#160;</td>
          <td class="paramname"><em>routerID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an std::vector of routes leading to the AS Boundary <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a> identified by asbrRouterID from the input fromRoutingTable. </p>
<p>If there are no routes leading to the AS Boundary <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>, the returned std::vector is empty. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fromRoutingTable</td><td>[in] The routing table to look in. </td></tr>
    <tr><td class="paramname">asbrRouterID</td><td>[in] The ID of the AS Boundary <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a> to look for. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    std::vector&lt;OSPF::RoutingTableEntry*&gt; results;
    <span class="keywordtype">long</span> routeCount = fromRoutingTable.size();

    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; routeCount; i++) {
        <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* routingEntry = fromRoutingTable[i];
        <span class="keywordflow">if</span> (((routingEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a04edb0b1d732271482e6bc0f38ed158d">getDestinationType</a>() &amp; <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a1d45a5d14016d202248c9cf8c4085209">OSPF::RoutingTableEntry::AS_BOUNDARY_ROUTER_DESTINATION</a>) != 0) &amp;&amp;
            (routingEntry-&gt;<a class="code" href="class_i_pv4_route.html#a4982ef0132d4e1560371231b7c11cf8c" title="Destination address prefix to match.">getDestination</a>() == asbrRouterID))
        {
            results.push_back(routingEntry);
        }
    }
    <span class="keywordflow">return</span> results;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7f08a4ee470038b5e86af3491de83614"></a><!-- doxytag: member="OSPF::Router::getRoutingTableEntry" ref="a7f08a4ee470038b5e86af3491de83614" args="(unsigned long i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a>* <a class="el" href="class_o_s_p_f_1_1_router.html#a7f08a4ee470038b5e86af3491de83614">OSPF::Router::getRoutingTableEntry</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]; }
</pre></div>
</div>
</div>
<a class="anchor" id="a4281686fd86f50d9ce3698233f986066"></a><!-- doxytag: member="OSPF::Router::getRoutingTableEntry" ref="a4281686fd86f50d9ce3698233f986066" args="(unsigned long i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a>* <a class="el" href="class_o_s_p_f_1_1_router.html#a7f08a4ee470038b5e86af3491de83614">OSPF::Router::getRoutingTableEntry</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]; }
</pre></div>
</div>
</div>
<a class="anchor" id="a77a1be6cab855fe8d2a9c269a500b313"></a><!-- doxytag: member="OSPF::Router::getRoutingTableEntryCount" ref="a77a1be6cab855fe8d2a9c269a500b313" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="class_o_s_p_f_1_1_router.html#a77a1be6cab855fe8d2a9c269a500b313">OSPF::Router::getRoutingTableEntryCount</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.size(); }
</pre></div>
</div>
</div>
<a class="anchor" id="a16c48a9dca12af177cd70096b4a3a1cb"></a><!-- doxytag: member="OSPF::Router::getUniqueLinkStateID" ref="a16c48a9dca12af177cd70096b4a3a1cb" args="(const IPv4AddressRange &amp;destination, Metric destinationCost, OSPF::ASExternalLSA *&amp;lsaToReoriginate, bool externalMetricIsType2=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_o_s_p_f.html#ae0387e56ccb51d46ab82fabd74d53de2">OSPF::LinkStateID</a> <a class="el" href="class_o_s_p_f_1_1_router.html#a16c48a9dca12af177cd70096b4a3a1cb">OSPF::Router::getUniqueLinkStateID</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">IPv4AddressRange</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_p_f.html#a4a99812a2d079df0f7208f2740cdb0ad">OSPF::Metric</a>&#160;</td>
          <td class="paramname"><em>destinationCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a> *&amp;&#160;</td>
          <td class="paramname"><em>lsaToReoriginate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>externalMetricIsType2</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates a unique LinkStateID for a given destination. </p>
<p>This may require the reorigination of an LSA already in the database(with a different LinkStateID). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>[in] The destination for which a unique LinkStateID is required. </td></tr>
    <tr><td class="paramname">destinationCost</td><td>[in] The path cost to the destination. </td></tr>
    <tr><td class="paramname">lsaToReoriginate</td><td>[out] The LSA to reoriginate(which was already in the database, and had to be changed). </td></tr>
    <tr><td class="paramname">externalMetricIsType2</td><td>[in] True if the destinationCost is given as a Type2 external metric. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the LinkStateID for the destination. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>RFC2328 Appendix E. </dd>
<dd>
<a class="el" href="class_o_s_p_f_1_1_area.html#a969e1ab74cb3e5014fffd6395ff08c67" title="Returns a link state ID for the input destination.">OSPF::Area::getUniqueLinkStateID</a> </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (lsaToReoriginate != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
        <span class="keyword">delete</span> lsaToReoriginate;
        lsaToReoriginate = <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
    }

    <a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a> lsaKey;

    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a> = destination.address;
    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>;

    <span class="keyword">const</span> <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>* foundLSA = <a class="code" href="class_o_s_p_f_1_1_router.html#ab5305a0128639b180c5846ec009127f0" title="Find the AS External LSA identified by the input lsaKey in the database.">findASExternalLSA</a>(lsaKey);

    <span class="keywordflow">if</span> (foundLSA == <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
        <span class="keywordflow">return</span> lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a>;
    } <span class="keywordflow">else</span> {
        <a class="code" href="class_i_pv4_address.html" title="IPv4 address.">IPv4Address</a> existingMask = foundLSA-&gt;<a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html#a34f5913c38930cb4098b1b5b2ceca1bb">getContents</a>().<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#a6a0d7bdb279abb7fa1a3d44622c0ff60">getNetworkMask</a>();

        <span class="keywordflow">if</span> (destination.mask &gt;= existingMask) {
            <span class="keywordflow">return</span> lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a>.<a class="code" href="class_i_pv4_address.html#abaed6078220ce34ed5407d5c0b73015f" title="Returns the broadcast address for the given netmask.">getBroadcastAddress</a>(destination.mask);
        } <span class="keywordflow">else</span> {
            <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>* asExternalLSA = <span class="keyword">new</span> <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>(*foundLSA);

            <span class="keywordtype">long</span> sequenceNumber = asExternalLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#aa1fa1df57d84e20fef93e765a587ff1c">getLsSequenceNumber</a>();

            asExternalLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a9851dc72d585835bfcffa08412c33f99">setLsAge</a>(0);
            asExternalLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#ad1dd1ce9ff9b1c59f8638cdbb26b2d57">setLsSequenceNumber</a>((sequenceNumber == <a class="code" href="_o_s_p_fcommon_8h.html#a35f49b34e56993fe20d3a21d144c16d3">MAX_SEQUENCE_NUMBER</a>) ? <a class="code" href="_o_s_p_fcommon_8h.html#ad441394da087bc61e24a5b99455c5589">INITIAL_SEQUENCE_NUMBER</a> : sequenceNumber + 1);
            asExternalLSA-&gt;<a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html#a34f5913c38930cb4098b1b5b2ceca1bb">getContents</a>().<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#ae9b2067a5b9cebec2cde01fe67303d5d">setNetworkMask</a>(destination.mask);
            asExternalLSA-&gt;<a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html#a34f5913c38930cb4098b1b5b2ceca1bb">getContents</a>().<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#acec64ce77d6c3bd9cac67bf136b1abfd">setE_ExternalMetricType</a>(externalMetricIsType2);
            asExternalLSA-&gt;<a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html#a34f5913c38930cb4098b1b5b2ceca1bb">getContents</a>().<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#ad819b28488dacdd94cfefe67b630a568">setRouteCost</a>(destinationCost);

            lsaToReoriginate = asExternalLSA;

            <span class="keywordflow">return</span> lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a>.<a class="code" href="class_i_pv4_address.html#abaed6078220ce34ed5407d5c0b73015f" title="Returns the broadcast address for the given netmask.">getBroadcastAddress</a>(existingMask);
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8189dfe577d24650fe61106221e282d2"></a><!-- doxytag: member="OSPF::Router::hasAddressRange" ref="a8189dfe577d24650fe61106221e282d2" args="(const IPv4AddressRange &amp;addressRange) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_s_p_f_1_1_router.html#a8189dfe577d24650fe61106221e282d2">OSPF::Router::hasAddressRange</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">IPv4AddressRange</a> &amp;&#160;</td>
          <td class="paramname"><em>addressRange</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if one of the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>'s Areas the same <a class="el" href="class_i_pv4.html" title="Implements the IPv4 protocol.">IPv4</a> address range configured as the input <a class="el" href="class_i_pv4.html" title="Implements the IPv4 protocol.">IPv4</a> address range, false otherwise. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">addressRange</td><td>[in] The <a class="el" href="class_i_pv4.html" title="Implements the IPv4 protocol.">IPv4</a> address range to look for. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
        <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;<a class="code" href="class_o_s_p_f_1_1_router.html#a8189dfe577d24650fe61106221e282d2" title="Returns true if one of the Router&#39;s Areas the same IPv4 address range configured as the input IPv4 ad...">hasAddressRange</a>(addressRange)) {
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa322d6ee424b77e7f22ef3e05681baea"></a><!-- doxytag: member="OSPF::Router::hasAnyNeighborInStates" ref="aa322d6ee424b77e7f22ef3e05681baea" args="(int states) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_s_p_f_1_1_router.html#aa322d6ee424b77e7f22ef3e05681baea">OSPF::Router::hasAnyNeighborInStates</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>states</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if any <a class="el" href="class_o_s_p_f_1_1_neighbor.html">Neighbor</a> on any <a class="el" href="class_o_s_p_f_1_1_interface.html">Interface</a> in any of the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>'s Areas is in any of the input states, false otherwise. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">states</td><td>[in] A bitfield combination of NeighborStateType values. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
        <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;<a class="code" href="class_o_s_p_f_1_1_router.html#aa322d6ee424b77e7f22ef3e05681baea" title="Returns true if any Neighbor on any Interface in any of the Router&#39;s Areas is in any of the input sta...">hasAnyNeighborInStates</a>(states)) {
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8ea3ed444f4cb7330e9be07daf522bef"></a><!-- doxytag: member="OSPF::Router::hasRouteToASBoundaryRouter" ref="a8ea3ed444f4cb7330e9be07daf522bef" args="(const std::vector&lt; RoutingTableEntry * &gt; &amp;inRoutingTable, OSPF::RouterID routerID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_s_p_f_1_1_router.html#a8ea3ed444f4cb7330e9be07daf522bef">OSPF::Router::hasRouteToASBoundaryRouter</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>inRoutingTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_p_f.html#adbcc14dbfc5290248d3f865bd3a56af4">OSPF::RouterID</a>&#160;</td>
          <td class="paramname"><em>routerID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if there is a route to the AS Boundary <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a> identified by asbrRouterID in the input inRoutingTable, false otherwise. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inRoutingTable</td><td>[in] The routing table to look in. </td></tr>
    <tr><td class="paramname">asbrRouterID</td><td>[in] The ID of the AS Boundary <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a> to look for. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> routeCount = inRoutingTable.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; routeCount; i++) {
        <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* routingEntry = inRoutingTable[i];
        <span class="keywordflow">if</span> (((routingEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a04edb0b1d732271482e6bc0f38ed158d">getDestinationType</a>() &amp; <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a1d45a5d14016d202248c9cf8c4085209">OSPF::RoutingTableEntry::AS_BOUNDARY_ROUTER_DESTINATION</a>) != 0) &amp;&amp;
            (routingEntry-&gt;<a class="code" href="class_i_pv4_route.html#a4982ef0132d4e1560371231b7c11cf8c" title="Destination address prefix to match.">getDestination</a>() == asbrRouterID))
        {
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7d3ec4918c945ee00863f46bb07fe52f"></a><!-- doxytag: member="OSPF::Router::installASExternalLSA" ref="a7d3ec4918c945ee00863f46bb07fe52f" args="(OSPFASExternalLSA *lsa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_s_p_f_1_1_router.html#a7d3ec4918c945ee00863f46bb07fe52f">OSPF::Router::installASExternalLSA</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_s_p_f_a_s_external_l_s_a.html">OSPFASExternalLSA</a> *&#160;</td>
          <td class="paramname"><em>lsa</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Installs a new AS External LSA into the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>'s database. </p>
<p>It tries to install keep one of multiple functionally equivalent AS External LSAs in the database. (See the comment in the method implementation.) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsa</td><td>[in] The LSA to install. It will be copied into the database. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the routing table needs to be updated, false otherwise. </dd></dl>
<p>From RFC2328 Section 12.4.4.1.: "If two routers, both reachable from one another, originate functionally equivalent AS-External-LSAs(i.e., same destination, cost and non-zero forwarding address), then the LSA originated by the router having the highest <a class="el" href="namespace_o_s_p_f.html" title="All OSPF classes are in this namespace.">OSPF</a> <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a> ID is used. The router having the lower <a class="el" href="namespace_o_s_p_f.html" title="All OSPF classes are in this namespace.">OSPF</a> <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a> ID can then flush its LSA." The problem is: how do we tell whether two routers are reachable from one another based on a <a class="el" href="class_link.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">Link</a> State Update packet? 0. We can assume that if this LSA reached this router, then this router is reachable from the other router. But what about the other direction? 1. The update packet is most likely not sent by the router originating the functionally equivalent AS-External-LSA, so we cannot use the <a class="el" href="class_i_pv4.html" title="Implements the IPv4 protocol.">IPv4</a> packet source address. 2. The AS-External-LSA contains only the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a> ID of the advertising router, so we can only look up "router" type routing entries in the routing table(these contain the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a> ID as their Destination ID). However these entries are only inserted into the routing table for intra-area routers...</p>
<div class="fragment"><pre class="fragment">{
     <span class="comment">// TODO: how to solve this problem?</span>

    <a class="code" href="class_i_pv4_address.html" title="IPv4 address.">OSPF::RouterID</a> advertisingRouter = lsa-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#afdeb8080774e4879f5c761fdbb1757fc">getAdvertisingRouter</a>();
    <span class="keywordtype">bool</span> reachable = <span class="keyword">false</span>;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> routeCount = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.size();

    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; routeCount; i++) {
        <span class="keywordflow">if</span> ((((<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]-&gt;getDestinationType() &amp; <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a5cba3057fd89f247aca089d6f9623ee6">OSPF::RoutingTableEntry::AREA_BORDER_ROUTER_DESTINATION</a>) != 0) ||
             ((<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]-&gt;getDestinationType() &amp; <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a1d45a5d14016d202248c9cf8c4085209">OSPF::RoutingTableEntry::AS_BOUNDARY_ROUTER_DESTINATION</a>) != 0)) &amp;&amp;
            (<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]-&gt;getDestination() == advertisingRouter))
        {
            reachable = <span class="keyword">true</span>;
            <span class="keywordflow">break</span>;
        }
    }

    <span class="keywordtype">bool</span> ownLSAFloodedOut = <span class="keyword">false</span>;
    <a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a> lsaKey;

    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a> = lsa-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a5ca4d451e700f5633b917bd547433260">getLinkStateID</a>();
    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>;

    std::map&lt;OSPF::LSAKeyType, OSPF::ASExternalLSA*, OSPF::LSAKeyType_Less&gt;::iterator lsaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.find(lsaKey);
    <span class="keywordflow">if</span> ((lsaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.end()) &amp;&amp;
        reachable &amp;&amp;
        (lsaIt-&gt;second-&gt;getContents().getE_ExternalMetricType() == lsa-&gt;<a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html#a34f5913c38930cb4098b1b5b2ceca1bb">getContents</a>().<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#a516562d1adb3fa4b65131d826a93de4c">getE_ExternalMetricType</a>()) &amp;&amp;
        (lsaIt-&gt;second-&gt;getContents().getRouteCost() == lsa-&gt;<a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html#a34f5913c38930cb4098b1b5b2ceca1bb">getContents</a>().<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#a9158b3adccf5864d8806813976f44b38">getRouteCost</a>()) &amp;&amp;
        (lsa-&gt;<a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html#a34f5913c38930cb4098b1b5b2ceca1bb">getContents</a>().<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#abaad1cfc2a0d75cd20c7bb449c999b87">getForwardingAddress</a>().<a class="code" href="class_i_pv4_address.html#ac4abdd5df9c86071f13af7a3f0931237" title="Returns the address as an int.">getInt</a>() != 0) &amp;&amp; <span class="comment">// forwarding address != 0.0.0.0</span>
        (lsaIt-&gt;second-&gt;getContents().getForwardingAddress() == lsa-&gt;<a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html#a34f5913c38930cb4098b1b5b2ceca1bb">getContents</a>().<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#abaad1cfc2a0d75cd20c7bb449c999b87">getForwardingAddress</a>()))
    {
        <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a> &gt; advertisingRouter) {
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
        } <span class="keywordflow">else</span> {
            lsaIt-&gt;second-&gt;getHeader().setLsAge(<a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a>);
            <a class="code" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4" title="Floods out the input lsa on a set of Interfaces.">floodLSA</a>(lsaIt-&gt;second, <a class="code" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">OSPF::BACKBONE_AREAID</a>);
            lsaIt-&gt;second-&gt;incrementInstallTime();
            ownLSAFloodedOut = <span class="keyword">true</span>;
        }
    }

    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = advertisingRouter;

    lsaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.find(lsaKey);
    <span class="keywordflow">if</span> (lsaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.end()) {
        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
            <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;removeFromAllRetransmissionLists(lsaKey);
        }
        <span class="keywordflow">return</span> ((lsaIt-&gt;second-&gt;update(lsa)) | ownLSAFloodedOut);
    } <span class="keywordflow">else</span> {
        <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>* lsaCopy = <span class="keyword">new</span> <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>(*lsa);
        <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>[lsaKey] = lsaCopy;
        <a class="code" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36" title="A list of the ASExternalLSAs advertised by this router.">asExternalLSAs</a>.push_back(lsaCopy);
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ada8546a2dfff49bb8010b7b11e8f634e"></a><!-- doxytag: member="OSPF::Router::installLSA" ref="ada8546a2dfff49bb8010b7b11e8f634e" args="(OSPFLSA *lsa, AreaID areaID=BACKBONE_AREAID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_s_p_f_1_1_router.html#ada8546a2dfff49bb8010b7b11e8f634e">OSPF::Router::installLSA</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_s_p_f_l_s_a.html">OSPFLSA</a> *&#160;</td>
          <td class="paramname"><em>lsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_p_f.html#a48c8e4d3af2a46ddb912740d4e2e91b1">OSPF::AreaID</a>&#160;</td>
          <td class="paramname"><em>areaID</em> = <code><a class="el" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">BACKBONE_AREAID</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Installs a new LSA into the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a> database. </p>
<p>Checks the input LSA's type and installs it into either the selected <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a>'s database, or if it's an AS External LSA then into the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>'s common asExternalLSAs list. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsa</td><td>[in] The LSA to install. It will be copied into the database. </td></tr>
    <tr><td class="paramname">areaID</td><td>[in] Identifies the input <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>, Network and Summary LSA's <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the routing table needs to be updated, false otherwise. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">switch</span> (lsa-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a5ec5eaa7d91ea4e1447766fe076d7207">getLsType</a>()) {
        <span class="keywordflow">case</span> <a class="code" href="_o_s_p_f_packet__m_8h.html#a13a450dbb578c4bd7714af8581c4f89ba364c69f32e2869591f3c446a7bd206c7">ROUTERLSA_TYPE</a>:
            {
                std::map&lt;OSPF::AreaID, OSPF::Area*&gt;::iterator areaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.find(areaID);
                <span class="keywordflow">if</span> (areaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.end()) {
                    <a class="code" href="class_o_s_p_f_router_l_s_a.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFRouterLSA</a>* ospfRouterLSA = check_and_cast&lt;<a class="code" href="class_o_s_p_f_router_l_s_a.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFRouterLSA</a>*&gt; (lsa);
                    <span class="keywordflow">return</span> areaIt-&gt;second-&gt;installRouterLSA(ospfRouterLSA);
                }
            }
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="_o_s_p_f_packet__m_8h.html#a13a450dbb578c4bd7714af8581c4f89ba2fedfd48d61b390a26c947aebdc25b8d">NETWORKLSA_TYPE</a>:
            {
                std::map&lt;OSPF::AreaID, OSPF::Area*&gt;::iterator areaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.find(areaID);
                <span class="keywordflow">if</span> (areaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.end()) {
                    <a class="code" href="class_o_s_p_f_network_l_s_a.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFNetworkLSA</a>* ospfNetworkLSA = check_and_cast&lt;<a class="code" href="class_o_s_p_f_network_l_s_a.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFNetworkLSA</a>*&gt; (lsa);
                    <span class="keywordflow">return</span> areaIt-&gt;second-&gt;installNetworkLSA(ospfNetworkLSA);
                }
            }
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="_o_s_p_f_packet__m_8h.html#a13a450dbb578c4bd7714af8581c4f89baa03619205be9ea7ba0299296dbe8fa38">SUMMARYLSA_NETWORKS_TYPE</a>:
        <span class="keywordflow">case</span> <a class="code" href="_o_s_p_f_packet__m_8h.html#a13a450dbb578c4bd7714af8581c4f89bad7e81ed4e05f467b7ca88c98f487662a">SUMMARYLSA_ASBOUNDARYROUTERS_TYPE</a>:
            {
                std::map&lt;OSPF::AreaID, OSPF::Area*&gt;::iterator areaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.find(areaID);
                <span class="keywordflow">if</span> (areaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5" title="A map of the contained areas with the AreaID as key.">areasByID</a>.end()) {
                    <a class="code" href="class_o_s_p_f_summary_l_s_a.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFSummaryLSA</a>* ospfSummaryLSA = check_and_cast&lt;<a class="code" href="class_o_s_p_f_summary_l_s_a.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFSummaryLSA</a>*&gt; (lsa);
                    <span class="keywordflow">return</span> areaIt-&gt;second-&gt;installSummaryLSA(ospfSummaryLSA);
                }
            }
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="_o_s_p_f_packet__m_8h.html#a13a450dbb578c4bd7714af8581c4f89ba5a085d8393eb69080f4819ea84627021">AS_EXTERNAL_LSA_TYPE</a>:
            {
                <a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFASExternalLSA</a>* ospfASExternalLSA = check_and_cast&lt;<a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFASExternalLSA</a>*&gt; (lsa);
                <span class="keywordflow">return</span> <a class="code" href="class_o_s_p_f_1_1_router.html#a7d3ec4918c945ee00863f46bb07fe52f" title="Installs a new AS External LSA into the Router&#39;s database.">installASExternalLSA</a>(ospfASExternalLSA);
            }
            <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>:
            ASSERT(<span class="keyword">false</span>);
            <span class="keywordflow">break</span>;
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a083894f1412443f07466e939a64fa29b"></a><!-- doxytag: member="OSPF::Router::isDestinationUnreachable" ref="a083894f1412443f07466e939a64fa29b" args="(OSPFLSA *lsa) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_s_p_f_1_1_router.html#a083894f1412443f07466e939a64fa29b">OSPF::Router::isDestinationUnreachable</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_s_p_f_l_s_a.html">OSPFLSA</a> *&#160;</td>
          <td class="paramname"><em>lsa</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the destination described by the input lsa is in the routing table, false otherwise. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsa</td><td>[in] The LSA which describes the destination to look for. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_i_pv4_address.html" title="IPv4 address.">IPv4Address</a> destination = <a class="code" href="class_i_pv4_address.html" title="IPv4 address.">IPv4Address</a>(lsa-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a5ca4d451e700f5633b917bd547433260">getLinkStateID</a>());

    <a class="code" href="class_o_s_p_f_router_l_s_a.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFRouterLSA</a>* routerLSA = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_o_s_p_f_router_l_s_a.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFRouterLSA</a>*<span class="keyword">&gt;</span> (lsa);
    <a class="code" href="class_o_s_p_f_network_l_s_a.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFNetworkLSA</a>* networkLSA = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_o_s_p_f_network_l_s_a.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFNetworkLSA</a>*<span class="keyword">&gt;</span> (lsa);
    <a class="code" href="class_o_s_p_f_summary_l_s_a.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFSummaryLSA</a>* summaryLSA = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_o_s_p_f_summary_l_s_a.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFSummaryLSA</a>*<span class="keyword">&gt;</span> (lsa);
    <a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFASExternalLSA</a>* asExternalLSA = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFASExternalLSA</a>*<span class="keyword">&gt;</span> (lsa);
    <span class="comment">// TODO: verify</span>
    <span class="keywordflow">if</span> (routerLSA != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
        <a class="code" href="class_o_s_p_f_1_1_routing_info.html">OSPF::RoutingInfo</a>* routingInfo = check_and_cast&lt;<a class="code" href="class_o_s_p_f_1_1_routing_info.html">OSPF::RoutingInfo</a>*&gt; (routerLSA);
        <span class="keywordflow">if</span> (routerLSA-&gt;getHeader().getLinkStateID() == <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>) { <span class="comment">// this is spfTreeRoot</span>
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
        }

        <span class="comment">// get the interface address pointing backwards on the shortest path tree</span>
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> linkCount = routerLSA-&gt;getLinksArraySize();
        <a class="code" href="class_o_s_p_f_1_1_router_l_s_a.html">OSPF::RouterLSA</a>* toRouterLSA = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_o_s_p_f_1_1_router_l_s_a.html">OSPF::RouterLSA</a>*<span class="keyword">&gt;</span> (routingInfo-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_info.html#a14818a13f21148cf99d6ecd05304a8f2">getParent</a>());
        <span class="keywordflow">if</span> (toRouterLSA != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
            <span class="keywordtype">bool</span> destinationFound = <span class="keyword">false</span>;
            <span class="keywordtype">bool</span> unnumberedPointToPointLink = <span class="keyword">false</span>;
            <a class="code" href="class_i_pv4_address.html" title="IPv4 address.">IPv4Address</a> firstNumberedIfAddress;

            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; linkCount; i++) {
                <a class="code" href="class_link.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">Link</a>&amp; link = routerLSA-&gt;getLinks(i);

                <span class="keywordflow">if</span> (link.<a class="code" href="class_link.html#aaa965c3ed01f358c7c328a361db3900c">getType</a>() == <a class="code" href="_o_s_p_f_packet__m_8h.html#a1e09bc05c5df6349a74bd3b9db638a96ab82b1d142b7d9afb7b16df592c6ffa8f">POINTTOPOINT_LINK</a>) {
                    <span class="keywordflow">if</span> (link.<a class="code" href="class_link.html#a75f03603367491f1b196f12bf48ae632">getLinkID</a>() == <a class="code" href="class_i_pv4_address.html" title="IPv4 address.">IPv4Address</a>(toRouterLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a5ca4d451e700f5633b917bd547433260">getLinkStateID</a>())) {
                        <span class="keywordflow">if</span> ((link.<a class="code" href="class_link.html#a12a8fd313e13f9bcdd588b1992b0c08a">getLinkData</a>() &amp; 0xFF000000) == 0) {
                            unnumberedPointToPointLink = <span class="keyword">true</span>;
                            <span class="keywordflow">if</span> (!firstNumberedIfAddress.<a class="code" href="class_i_pv4_address.html#a76dbddd2575a9e91412b998512b45a2d" title="True if all four address bytes are zero.">isUnspecified</a>()) {
                                <span class="keywordflow">break</span>;
                            }
                        } <span class="keywordflow">else</span> {
                            destination = <a class="code" href="class_i_pv4_address.html" title="IPv4 address.">IPv4Address</a>(link.<a class="code" href="class_link.html#a12a8fd313e13f9bcdd588b1992b0c08a">getLinkData</a>());
                            destinationFound = <span class="keyword">true</span>;
                            <span class="keywordflow">break</span>;
                        }
                    } <span class="keywordflow">else</span> {
                        <span class="keywordflow">if</span> (((link.<a class="code" href="class_link.html#a12a8fd313e13f9bcdd588b1992b0c08a">getLinkData</a>() &amp; 0xFF000000) != 0) &amp;&amp;
                             firstNumberedIfAddress.<a class="code" href="class_i_pv4_address.html#a76dbddd2575a9e91412b998512b45a2d" title="True if all four address bytes are zero.">isUnspecified</a>())
                        {
                            firstNumberedIfAddress = <a class="code" href="class_i_pv4_address.html" title="IPv4 address.">IPv4Address</a>(link.<a class="code" href="class_link.html#a12a8fd313e13f9bcdd588b1992b0c08a">getLinkData</a>());
                        }
                    }
                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (link.<a class="code" href="class_link.html#aaa965c3ed01f358c7c328a361db3900c">getType</a>() == <a class="code" href="_o_s_p_f_packet__m_8h.html#a1e09bc05c5df6349a74bd3b9db638a96a37c0fd9c0c591d7a83dcebdb0b21cb25">TRANSIT_LINK</a>) {
                    <span class="keywordflow">if</span> (firstNumberedIfAddress.<a class="code" href="class_i_pv4_address.html#a76dbddd2575a9e91412b998512b45a2d" title="True if all four address bytes are zero.">isUnspecified</a>()) {
                        firstNumberedIfAddress = <a class="code" href="class_i_pv4_address.html" title="IPv4 address.">IPv4Address</a>(link.<a class="code" href="class_link.html#a12a8fd313e13f9bcdd588b1992b0c08a">getLinkData</a>());
                    }
                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (link.<a class="code" href="class_link.html#aaa965c3ed01f358c7c328a361db3900c">getType</a>() == <a class="code" href="_o_s_p_f_packet__m_8h.html#a1e09bc05c5df6349a74bd3b9db638a96a9939f5f62a2a39aefbcd3013eaef1c25">VIRTUAL_LINK</a>) {
                    <span class="keywordflow">if</span> (link.<a class="code" href="class_link.html#a75f03603367491f1b196f12bf48ae632">getLinkID</a>() == toRouterLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a5ca4d451e700f5633b917bd547433260">getLinkStateID</a>()) {
                        destination = <a class="code" href="class_i_pv4_address.html" title="IPv4 address.">IPv4Address</a>(link.<a class="code" href="class_link.html#a12a8fd313e13f9bcdd588b1992b0c08a">getLinkData</a>());
                        destinationFound = <span class="keyword">true</span>;
                        <span class="keywordflow">break</span>;
                    } <span class="keywordflow">else</span> {
                        <span class="keywordflow">if</span> (firstNumberedIfAddress.<a class="code" href="class_i_pv4_address.html#a76dbddd2575a9e91412b998512b45a2d" title="True if all four address bytes are zero.">isUnspecified</a>()) {
                            firstNumberedIfAddress = <a class="code" href="class_i_pv4_address.html" title="IPv4 address.">IPv4Address</a>(link.<a class="code" href="class_link.html#a12a8fd313e13f9bcdd588b1992b0c08a">getLinkData</a>());
                        }
                    }
                }
                <span class="comment">// There&#39;s no way to get an interface address for the router from a STUB_LINK</span>
            }
            <span class="keywordflow">if</span> (unnumberedPointToPointLink) {
                <span class="keywordflow">if</span> (!firstNumberedIfAddress.<a class="code" href="class_i_pv4_address.html#a76dbddd2575a9e91412b998512b45a2d" title="True if all four address bytes are zero.">isUnspecified</a>()) {
                    destination = firstNumberedIfAddress;
                } <span class="keywordflow">else</span> {
                    <span class="keywordflow">return</span> <span class="keyword">true</span>;
                }
            }
            <span class="keywordflow">if</span> (!destinationFound) {
                <span class="keywordflow">return</span> <span class="keyword">true</span>;
            }
        } <span class="keywordflow">else</span> {
            <a class="code" href="class_o_s_p_f_1_1_network_l_s_a.html">OSPF::NetworkLSA</a>* toNetworkLSA = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_o_s_p_f_1_1_network_l_s_a.html">OSPF::NetworkLSA</a>*<span class="keyword">&gt;</span> (routingInfo-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_info.html#a14818a13f21148cf99d6ecd05304a8f2">getParent</a>());
            <span class="keywordflow">if</span> (toNetworkLSA != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
                <span class="comment">// get the interface address pointing backwards on the shortest path tree</span>
                <span class="keywordtype">bool</span> destinationFound = <span class="keyword">false</span>;
                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; linkCount; i++) {
                    <a class="code" href="class_link.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">Link</a>&amp; link = routerLSA-&gt;getLinks(i);

                    <span class="keywordflow">if</span> ((link.<a class="code" href="class_link.html#aaa965c3ed01f358c7c328a361db3900c">getType</a>() == <a class="code" href="_o_s_p_f_packet__m_8h.html#a1e09bc05c5df6349a74bd3b9db638a96a37c0fd9c0c591d7a83dcebdb0b21cb25">TRANSIT_LINK</a>) &amp;&amp;
                        (link.<a class="code" href="class_link.html#a75f03603367491f1b196f12bf48ae632">getLinkID</a>() == <a class="code" href="class_i_pv4_address.html" title="IPv4 address.">IPv4Address</a>(toNetworkLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a5ca4d451e700f5633b917bd547433260">getLinkStateID</a>())))
                    {
                        destination = <a class="code" href="class_i_pv4_address.html" title="IPv4 address.">IPv4Address</a>(link.<a class="code" href="class_link.html#a12a8fd313e13f9bcdd588b1992b0c08a">getLinkData</a>());
                        destinationFound = <span class="keyword">true</span>;
                        <span class="keywordflow">break</span>;
                    }
                }
                <span class="keywordflow">if</span> (!destinationFound) {
                    <span class="keywordflow">return</span> <span class="keyword">true</span>;
                }
            } <span class="keywordflow">else</span> {
                <span class="keywordflow">return</span> <span class="keyword">true</span>;
            }
        }
    }
    <span class="keywordflow">if</span> (networkLSA != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
        destination = networkLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a5ca4d451e700f5633b917bd547433260">getLinkStateID</a>() &amp; networkLSA-&gt;<a class="code" href="class_o_s_p_f_network_l_s_a.html#a435561dcb45638c0afe85450ff762a1c">getNetworkMask</a>();
    }
    <span class="keywordflow">if</span> ((summaryLSA != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) &amp;&amp; (summaryLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a5ec5eaa7d91ea4e1447766fe076d7207">getLsType</a>() == <a class="code" href="_o_s_p_f_packet__m_8h.html#a13a450dbb578c4bd7714af8581c4f89baa03619205be9ea7ba0299296dbe8fa38">SUMMARYLSA_NETWORKS_TYPE</a>)) {
        destination = summaryLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a5ca4d451e700f5633b917bd547433260">getLinkStateID</a>() &amp; summaryLSA-&gt;<a class="code" href="class_o_s_p_f_summary_l_s_a.html#a98fe2d75fb7cbb6b0c048bb87407eaf7">getNetworkMask</a>();
    }
    <span class="keywordflow">if</span> (asExternalLSA != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
        destination = asExternalLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a5ca4d451e700f5633b917bd547433260">getLinkStateID</a>() &amp; asExternalLSA-&gt;<a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html#a34f5913c38930cb4098b1b5b2ceca1bb">getContents</a>().<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#a6a0d7bdb279abb7fa1a3d44622c0ff60">getNetworkMask</a>();
    }

    <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#af37b73461ea85b76af17738f3b21d39f" title="Do a lookup in either the input OSPF routing table, or if it&#39;s NULL then in the Router&#39;s own routing ...">lookup</a>(destination) == <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    } <span class="keywordflow">else</span> {
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aac1b4fda6632cf425936203de702f21d"></a><!-- doxytag: member="OSPF::Router::isLocalAddress" ref="aac1b4fda6632cf425936203de702f21d" args="(IPv4Address address) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_s_p_f_1_1_router.html#aac1b4fda6632cf425936203de702f21d">OSPF::Router::isLocalAddress</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv4_address.html">IPv4Address</a>&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the input <a class="el" href="class_i_pv4.html" title="Implements the IPv4 protocol.">IPv4</a> address falls into any of the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>'s Areas' configured <a class="el" href="class_i_pv4.html" title="Implements the IPv4 protocol.">IPv4</a> address ranges, false otherwise. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>[in] The <a class="el" href="class_i_pv4.html" title="Implements the IPv4 protocol.">IPv4</a> address to look for. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
        <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;<a class="code" href="class_o_s_p_f_1_1_router.html#aac1b4fda6632cf425936203de702f21d" title="Returns true if the input IPv4 address falls into any of the Router&#39;s Areas&#39; configured IPv4 address ...">isLocalAddress</a>(address)) {
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7ea7fbacbe22d11dc419d6526e1d2dec"></a><!-- doxytag: member="OSPF::Router::isOnAnyRetransmissionList" ref="a7ea7fbacbe22d11dc419d6526e1d2dec" args="(LSAKeyType lsaKey) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_s_p_f_1_1_router.html#a7ea7fbacbe22d11dc419d6526e1d2dec">OSPF::Router::isOnAnyRetransmissionList</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a>&#160;</td>
          <td class="paramname"><em>lsaKey</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if there's at least one LSA on any <a class="el" href="class_o_s_p_f_1_1_neighbor.html">Neighbor</a>'s retransmission list identified by the input lsaKey, false otherwise. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsaKey</td><td>[in] Identifies the LSAs to look for on the retransmission lists. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
        <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;<a class="code" href="class_o_s_p_f_1_1_router.html#a7ea7fbacbe22d11dc419d6526e1d2dec" title="Returns true if there&#39;s at least one LSA on any Neighbor&#39;s retransmission list identified by the inpu...">isOnAnyRetransmissionList</a>(lsaKey)) {
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af37b73461ea85b76af17738f3b21d39f"></a><!-- doxytag: member="OSPF::Router::lookup" ref="af37b73461ea85b76af17738f3b21d39f" args="(IPv4Address destination, std::vector&lt; RoutingTableEntry * &gt; *table=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a> * <a class="el" href="class_o_s_p_f_1_1_router.html#af37b73461ea85b76af17738f3b21d39f">OSPF::Router::lookup</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv4_address.html">IPv4Address</a>&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; *&#160;</td>
          <td class="paramname"><em>table</em> = <code><a class="el" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do a lookup in either the input <a class="el" href="namespace_o_s_p_f.html" title="All OSPF classes are in this namespace.">OSPF</a> routing table, or if it's NULL then in the <a class="el" href="class_o_s_p_f_1_1_router.html" title="Represents the full OSPF data structure as laid out in RFC2328.">Router</a>'s own routing table. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>RFC2328 Section 11.1. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>[in] The destination to look up in the routing table. </td></tr>
    <tr><td class="paramname">table</td><td>[in] The routing table to do the lookup in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> describing the input destination if there's one, false otherwise. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> std::vector&lt;OSPF::RoutingTableEntry*&gt;&amp; rTable = (table == <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) ? <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a> : (*table);
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dest = destination.<a class="code" href="class_i_pv4_address.html#ac4abdd5df9c86071f13af7a3f0931237" title="Returns the address as an int.">getInt</a>();
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> routingTableSize = rTable.size();
    <span class="keywordtype">bool</span> unreachable = <span class="keyword">false</span>;
    std::vector&lt;OSPF::RoutingTableEntry*&gt; discard;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i;

    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (i = 0; i &lt; areaCount; i++) {
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> addressRangeCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;getAddressRangeCount();
        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; addressRangeCount; j++) {
            <a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">OSPF::IPv4AddressRange</a> range = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;getAddressRange(j);

            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; routingTableSize; k++) {
                <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* entry = rTable[k];

                <span class="keywordflow">if</span> (entry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a04edb0b1d732271482e6bc0f38ed158d">getDestinationType</a>() != <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a8b5b8d21ccec069a781e4f4f4eca9dca">OSPF::RoutingTableEntry::NETWORK_DESTINATION</a>) {
                    <span class="keywordflow">continue</span>;
                }
<span class="comment">//                if (((entry-&gt;getDestination().getInt() &amp; entry-&gt;getNetmask().getInt() &amp; range.mask.getInt()) == (range.address &amp; range.mask).getInt()) &amp;&amp;</span>
<span class="comment">//                    (entry-&gt;getPathType() == OSPF::RoutingTableEntry::INTRAAREA))</span>
                <span class="keywordflow">if</span> (range.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a558a2a9202729dc869b3aaf990b73912">containsRange</a>(entry-&gt;<a class="code" href="class_i_pv4_route.html#a4982ef0132d4e1560371231b7c11cf8c" title="Destination address prefix to match.">getDestination</a>(), entry-&gt;<a class="code" href="class_i_pv4_route.html#ac7d8f045f17b54b9d7e364cd525ba9ae" title="Represents length of prefix to match.">getNetmask</a>()) &amp;&amp;
                    (entry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aa2863a46a8edb4a9441df81fc4c37c92">getPathType</a>() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a3c76f6904ab261d6c8b709c7078a957f">OSPF::RoutingTableEntry::INTRAAREA</a>))
                {
                    <span class="comment">// active area address range</span>
                    <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* discardEntry = <span class="keyword">new</span> <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>;
                    discardEntry-&gt;<a class="code" href="class_i_pv4_route.html#a75d1011d4002c8a9503f3a42aff66c70">setDestination</a>(range.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a74993d6571119644535ac918c4240722">address</a>);
                    discardEntry-&gt;<a class="code" href="class_i_pv4_route.html#a625acf9119fbc2bd5255c56096a36d38">setNetmask</a>(range.<a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html#a452878c3f507f27d1de9c5b7cda2ae70">mask</a>);
                    discardEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ad6f0c1c2c3eebf202e43ba43bf5dbc1e">setDestinationType</a>(<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a8b5b8d21ccec069a781e4f4f4eca9dca">OSPF::RoutingTableEntry::NETWORK_DESTINATION</a>);
                    discardEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a56347be9b6f6283980d3ab0e78bc7cfe">setPathType</a>(<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a3877847d7f354cfef92ff2352121aae4">OSPF::RoutingTableEntry::INTERAREA</a>);
                    discardEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ae78f14a2e3bd0ec9ae05acb741046e1f">setArea</a>(<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;getAreaID());
                    discard.push_back(discardEntry);
                    <span class="keywordflow">break</span>;
                }
            }
        }
    }

    <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* bestMatch = <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> longestMatch = 0;

    <span class="keywordflow">for</span> (i = 0; i &lt; routingTableSize; i++) {
        <span class="keywordflow">if</span> (rTable[i]-&gt;getDestinationType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a8b5b8d21ccec069a781e4f4f4eca9dca">OSPF::RoutingTableEntry::NETWORK_DESTINATION</a>) {
            <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* entry = rTable[i];
            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> entryAddress = entry-&gt;<a class="code" href="class_i_pv4_route.html#a4982ef0132d4e1560371231b7c11cf8c" title="Destination address prefix to match.">getDestination</a>().<a class="code" href="class_i_pv4_address.html#ac4abdd5df9c86071f13af7a3f0931237" title="Returns the address as an int.">getInt</a>();
            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> entryMask = entry-&gt;<a class="code" href="class_i_pv4_route.html#ac7d8f045f17b54b9d7e364cd525ba9ae" title="Represents length of prefix to match.">getNetmask</a>().<a class="code" href="class_i_pv4_address.html#ac4abdd5df9c86071f13af7a3f0931237" title="Returns the address as an int.">getInt</a>();

            <span class="keywordflow">if</span> ((entryAddress &amp; entryMask) == (dest &amp; entryMask)) {
                <span class="keywordflow">if</span> ((dest &amp; entryMask) &gt; longestMatch) {
                    longestMatch = (dest &amp; entryMask);
                    bestMatch = entry;
                }
            }
        }
    }

    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> discardCount = discard.size();
    <span class="keywordflow">if</span> (bestMatch == <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
        unreachable = <span class="keyword">true</span>;
    } <span class="keywordflow">else</span> {
        <span class="keywordflow">for</span> (i = 0; i &lt; discardCount; i++) {
            <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* entry = discard[i];
            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> entryAddress = entry-&gt;<a class="code" href="class_i_pv4_route.html#a4982ef0132d4e1560371231b7c11cf8c" title="Destination address prefix to match.">getDestination</a>().<a class="code" href="class_i_pv4_address.html#ac4abdd5df9c86071f13af7a3f0931237" title="Returns the address as an int.">getInt</a>();
            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> entryMask = entry-&gt;<a class="code" href="class_i_pv4_route.html#ac7d8f045f17b54b9d7e364cd525ba9ae" title="Represents length of prefix to match.">getNetmask</a>().<a class="code" href="class_i_pv4_address.html#ac4abdd5df9c86071f13af7a3f0931237" title="Returns the address as an int.">getInt</a>();

            <span class="keywordflow">if</span> ((entryAddress &amp; entryMask) == (dest &amp; entryMask)) {
                <span class="keywordflow">if</span> ((dest &amp; entryMask) &gt; longestMatch) {
                    unreachable = <span class="keyword">true</span>;
                    <span class="keywordflow">break</span>;
                }
            }
        }
    }

    <span class="keywordflow">for</span> (i = 0; i &lt; discardCount; i++) {
        <span class="keyword">delete</span> discard[i];
    }

    <span class="keywordflow">if</span> (unreachable) {
        <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
    } <span class="keywordflow">else</span> {
        <span class="keywordflow">return</span> bestMatch;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="acae55a162eaf731e634d0b121a3f59dc"></a><!-- doxytag: member="OSPF::Router::notifyAboutRoutingTableChanges" ref="acae55a162eaf731e634d0b121a3f59dc" args="(std::vector&lt; RoutingTableEntry * &gt; &amp;oldRoutingTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_o_s_p_f_1_1_router.html#acae55a162eaf731e634d0b121a3f59dc">OSPF::Router::notifyAboutRoutingTableChanges</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldRoutingTable</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>After a routing table rebuild the changes in the routing table are identified and new SummaryLSAs are originated or old ones are flooded out in each area as necessary. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">oldRoutingTable</td><td>[in] The previous version of the routing table(which is then compared with the one in routingTable). </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>RFC2328 Section 12.4. points(5) through(6). </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size() &lt;= 1) {
        <span class="keywordflow">return</span>;
    }

    <span class="keyword">typedef</span> std::map&lt;IPv4AddressRange, RoutingTableEntry*&gt; RoutingTableEntryMap;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> routeCount = oldRoutingTable.size();
    RoutingTableEntryMap oldTableMap;
    RoutingTableEntryMap newTableMap;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>                                 i, j, k;

    <span class="keywordflow">for</span> (i = 0; i &lt; routeCount; i++) {
        IPv4AddressRange destination(oldRoutingTable[i]-&gt;getDestination() &amp; oldRoutingTable[i]-&gt;getNetmask(), oldRoutingTable[i]-&gt;getNetmask());
        oldTableMap[destination] = oldRoutingTable[i];
    }

    routeCount = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.size();
    <span class="keywordflow">for</span> (i = 0; i &lt; routeCount; i++) {
        IPv4AddressRange destination(<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]-&gt;getDestination() &amp; <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]-&gt;getNetmask(), <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]-&gt;getNetmask());
        newTableMap[destination] = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i];
    }

    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (i = 0; i &lt; areaCount; i++) {
        std::map&lt;OSPF::LSAKeyType, bool, OSPF::LSAKeyType_Less&gt; originatedLSAMap;
        std::map&lt;OSPF::LSAKeyType, bool, OSPF::LSAKeyType_Less&gt; deletedLSAMap;
        <a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a> lsaKey;

        routeCount = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.size();
        <span class="keywordflow">for</span> (j = 0; j &lt; routeCount; j++) {
            IPv4AddressRange destination(<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]-&gt;getDestination() &amp; <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]-&gt;getNetmask(), <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]-&gt;getNetmask());
            RoutingTableEntryMap::iterator destIt = oldTableMap.find(destination);
            <span class="keywordflow">if</span> (destIt == oldTableMap.end()) { <span class="comment">// new routing entry</span>
                <a class="code" href="class_o_s_p_f_1_1_summary_l_s_a.html">OSPF::SummaryLSA</a>* lsaToReoriginate = <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
                <a class="code" href="class_o_s_p_f_1_1_summary_l_s_a.html">OSPF::SummaryLSA</a>* newLSA = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;originateSummaryLSA(<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j], originatedLSAMap, lsaToReoriginate);

                <span class="keywordflow">if</span> (newLSA != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
                    <span class="keywordflow">if</span> (lsaToReoriginate != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
                        <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;installSummaryLSA(lsaToReoriginate);
<span class="comment">//                        floodLSA(lsaToReoriginate, OSPF::BACKBONE_AREAID);</span>
                        <a class="code" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4" title="Floods out the input lsa on a set of Interfaces.">floodLSA</a>(lsaToReoriginate, <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;getAreaID());

                        lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a> = lsaToReoriginate-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a5ca4d451e700f5633b917bd547433260">getLinkStateID</a>();
                        lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>;
                        originatedLSAMap[lsaKey] = <span class="keyword">true</span>;

                        <span class="keyword">delete</span> lsaToReoriginate;
                    }

                    <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;installSummaryLSA(newLSA);
<span class="comment">//                    floodLSA(newLSA, OSPF::BACKBONE_AREAID);</span>
                    <a class="code" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4" title="Floods out the input lsa on a set of Interfaces.">floodLSA</a>(newLSA, <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;getAreaID());

                    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a> = newLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a5ca4d451e700f5633b917bd547433260">getLinkStateID</a>();
                    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>;
                    originatedLSAMap[lsaKey] = <span class="keyword">true</span>;

                    <span class="keyword">delete</span> newLSA;
                }
            } <span class="keywordflow">else</span> {
                <span class="keywordflow">if</span> (*(<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]) != *(destIt-&gt;second)) {  <span class="comment">// modified routing entry</span>
                    <a class="code" href="class_o_s_p_f_1_1_summary_l_s_a.html">OSPF::SummaryLSA</a>* lsaToReoriginate = <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
                    <a class="code" href="class_o_s_p_f_1_1_summary_l_s_a.html">OSPF::SummaryLSA</a>* newLSA = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;originateSummaryLSA(<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j], originatedLSAMap, lsaToReoriginate);

                    <span class="keywordflow">if</span> (newLSA != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
                        <span class="keywordflow">if</span> (lsaToReoriginate != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
                            <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;installSummaryLSA(lsaToReoriginate);
<span class="comment">//                            floodLSA(lsaToReoriginate, OSPF::BACKBONE_AREAID);</span>
                            <a class="code" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4" title="Floods out the input lsa on a set of Interfaces.">floodLSA</a>(lsaToReoriginate, <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;getAreaID());

                            lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a> = lsaToReoriginate-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a5ca4d451e700f5633b917bd547433260">getLinkStateID</a>();
                            lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>;
                            originatedLSAMap[lsaKey] = <span class="keyword">true</span>;

                            <span class="keyword">delete</span> lsaToReoriginate;
                        }

                        <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;installSummaryLSA(newLSA);
<span class="comment">//                        floodLSA(newLSA, OSPF::BACKBONE_AREAID);</span>
                        <a class="code" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4" title="Floods out the input lsa on a set of Interfaces.">floodLSA</a>(newLSA, <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;getAreaID());

                        lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a> = newLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a5ca4d451e700f5633b917bd547433260">getLinkStateID</a>();
                        lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>;
                        originatedLSAMap[lsaKey] = <span class="keyword">true</span>;

                        <span class="keyword">delete</span> newLSA;
                    } <span class="keywordflow">else</span> {
                        <a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">OSPF::IPv4AddressRange</a> destinationAddressRange(<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]-&gt;getDestination(), <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]-&gt;getNetmask());

                        <span class="keywordflow">if</span> ((<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]-&gt;getDestinationType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a8b5b8d21ccec069a781e4f4f4eca9dca">OSPF::RoutingTableEntry::NETWORK_DESTINATION</a>) &amp;&amp;
                            ((<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]-&gt;getPathType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a3c76f6904ab261d6c8b709c7078a957f">OSPF::RoutingTableEntry::INTRAAREA</a>) ||
                             (<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]-&gt;getPathType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a3877847d7f354cfef92ff2352121aae4">OSPF::RoutingTableEntry::INTERAREA</a>)))
                        {
                            <a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">OSPF::IPv4AddressRange</a> containingAddressRange = <a class="code" href="class_o_s_p_f_1_1_router.html#a10e4eb37ccddff29e494db42e3c8debe" title="Scans through the router&#39;s areas&#39; preconfigured address ranges and returns the one containing the inp...">getContainingAddressRange</a>(destinationAddressRange);
                            <span class="keywordflow">if</span> (containingAddressRange != <a class="code" href="namespace_o_s_p_f.html#ab52eff5511df2676c0a8f83ae90e5898">OSPF::NULL_IPV4ADDRESSRANGE</a>) {
                                destinationAddressRange = containingAddressRange;
                            }
                        }

                        <a class="code" href="namespace_o_s_p_f.html#a4a99812a2d079df0f7208f2740cdb0ad">Metric</a> maxRangeCost = 0;
                        <a class="code" href="namespace_o_s_p_f.html#a4a99812a2d079df0f7208f2740cdb0ad">Metric</a> oneLessCost = 0;

                        <span class="keywordflow">for</span> (k = 0; k &lt; routeCount; k++) {
                            <span class="keywordflow">if</span> ((<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;getDestinationType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a8b5b8d21ccec069a781e4f4f4eca9dca">OSPF::RoutingTableEntry::NETWORK_DESTINATION</a>) &amp;&amp;
                                (<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;getPathType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a3c76f6904ab261d6c8b709c7078a957f">OSPF::RoutingTableEntry::INTRAAREA</a>) &amp;&amp;
                                ((<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;getDestination().getInt() &amp; <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;getNetmask().getInt() &amp; destinationAddressRange.mask.getInt()) ==
                                 (destinationAddressRange.address &amp; destinationAddressRange.mask).getInt()) &amp;&amp;
                                (<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;getCost() &gt; maxRangeCost))
                            {
                                oneLessCost = maxRangeCost;
                                maxRangeCost = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;getCost();
                            }
                        }

                        <span class="keywordflow">if</span> (maxRangeCost == <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[j]-&gt;getCost()) {  <span class="comment">// this entry gives the range&#39;s cost</span>
                            lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a> = destinationAddressRange.address;
                            lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>;

                            <a class="code" href="class_o_s_p_f_1_1_summary_l_s_a.html">OSPF::SummaryLSA</a>* summaryLSA = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;findSummaryLSA(lsaKey);

                            <span class="keywordflow">if</span> (summaryLSA != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
                                <span class="keywordflow">if</span> (oneLessCost != 0) { <span class="comment">// there&#39;s an other entry in this range</span>
                                    summaryLSA-&gt;<a class="code" href="class_o_s_p_f_summary_l_s_a.html#a2620811484632f24aae24539b55078ed">setRouteCost</a>(oneLessCost);
<span class="comment">//                                    floodLSA(summaryLSA, OSPF::BACKBONE_AREAID);</span>
                                    <a class="code" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4" title="Floods out the input lsa on a set of Interfaces.">floodLSA</a>(summaryLSA, <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;getAreaID());

                                    originatedLSAMap[lsaKey] = <span class="keyword">true</span>;
                                } <span class="keywordflow">else</span> {    <span class="comment">// no more entries in this range -&gt; delete it</span>
                                    std::map&lt;OSPF::LSAKeyType, bool, OSPF::LSAKeyType_Less&gt;::const_iterator deletedIt = deletedLSAMap.find(lsaKey);
                                    <span class="keywordflow">if</span> (deletedIt == deletedLSAMap.end()) {
                                        summaryLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a9851dc72d585835bfcffa08412c33f99">setLsAge</a>(<a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a>);
<span class="comment">//                                        floodLSA(summaryLSA, OSPF::BACKBONE_AREAID);</span>
                                        <a class="code" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4" title="Floods out the input lsa on a set of Interfaces.">floodLSA</a>(summaryLSA, <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;getAreaID());

                                        deletedLSAMap[lsaKey] = <span class="keyword">true</span>;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        routeCount = oldRoutingTable.size();
        <span class="keywordflow">for</span> (j = 0; j &lt; routeCount; j++) {
            IPv4AddressRange destination(oldRoutingTable[j]-&gt;getDestination() &amp; oldRoutingTable[j]-&gt;getNetmask(), oldRoutingTable[j]-&gt;getNetmask());
            RoutingTableEntryMap::iterator destIt = newTableMap.find(destination);
            <span class="keywordflow">if</span> (destIt == newTableMap.end()) { <span class="comment">// deleted routing entry</span>
                <a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">OSPF::IPv4AddressRange</a> destinationAddressRange(oldRoutingTable[j]-&gt;getDestination(), oldRoutingTable[j]-&gt;getNetmask());

                <span class="keywordflow">if</span> ((oldRoutingTable[j]-&gt;getDestinationType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a8b5b8d21ccec069a781e4f4f4eca9dca">OSPF::RoutingTableEntry::NETWORK_DESTINATION</a>) &amp;&amp;
                    ((oldRoutingTable[j]-&gt;getPathType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a3c76f6904ab261d6c8b709c7078a957f">OSPF::RoutingTableEntry::INTRAAREA</a>) ||
                     (oldRoutingTable[j]-&gt;getPathType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a3877847d7f354cfef92ff2352121aae4">OSPF::RoutingTableEntry::INTERAREA</a>)))
                {
                    <a class="code" href="struct_o_s_p_f_1_1_i_pv4_address_range.html">OSPF::IPv4AddressRange</a> containingAddressRange = <a class="code" href="class_o_s_p_f_1_1_router.html#a10e4eb37ccddff29e494db42e3c8debe" title="Scans through the router&#39;s areas&#39; preconfigured address ranges and returns the one containing the inp...">getContainingAddressRange</a>(destinationAddressRange);
                    <span class="keywordflow">if</span> (containingAddressRange != <a class="code" href="namespace_o_s_p_f.html#ab52eff5511df2676c0a8f83ae90e5898">OSPF::NULL_IPV4ADDRESSRANGE</a>) {
                        destinationAddressRange = containingAddressRange;
                    }
                }

                <a class="code" href="namespace_o_s_p_f.html#a4a99812a2d079df0f7208f2740cdb0ad">Metric</a> maxRangeCost = 0;

                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> newRouteCount = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.size();
                <span class="keywordflow">for</span> (k = 0; k &lt; newRouteCount; k++) {
                    <span class="keywordflow">if</span> ((<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;getDestinationType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a8b5b8d21ccec069a781e4f4f4eca9dca">OSPF::RoutingTableEntry::NETWORK_DESTINATION</a>) &amp;&amp;
                        (<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;getPathType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a3c76f6904ab261d6c8b709c7078a957f">OSPF::RoutingTableEntry::INTRAAREA</a>) &amp;&amp;
                        ((<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;getDestination().getInt() &amp; <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;getNetmask().getInt() &amp; destinationAddressRange.mask.getInt()) ==
                         (destinationAddressRange.address &amp; destinationAddressRange.mask).getInt()) &amp;&amp;     <span class="comment">//FIXME correcting network comparison</span>
                        (<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;getCost() &gt; maxRangeCost))
                    {
                        maxRangeCost = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[k]-&gt;getCost();
                    }
                }

                <span class="keywordflow">if</span> (maxRangeCost &lt; oldRoutingTable[j]-&gt;getCost()) {  <span class="comment">// the range&#39;s cost will change</span>
                    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a> = destinationAddressRange.address;
                    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>;

                    <a class="code" href="class_o_s_p_f_1_1_summary_l_s_a.html">OSPF::SummaryLSA</a>* summaryLSA = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;findSummaryLSA(lsaKey);

                    <span class="keywordflow">if</span> (summaryLSA != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
                        <span class="keywordflow">if</span> (maxRangeCost &gt; 0) { <span class="comment">// there&#39;s an other entry in this range</span>
                            summaryLSA-&gt;<a class="code" href="class_o_s_p_f_summary_l_s_a.html#a2620811484632f24aae24539b55078ed">setRouteCost</a>(maxRangeCost);
                            <a class="code" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4" title="Floods out the input lsa on a set of Interfaces.">floodLSA</a>(summaryLSA, <a class="code" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">OSPF::BACKBONE_AREAID</a>);

                            originatedLSAMap[lsaKey] = <span class="keyword">true</span>;
                        } <span class="keywordflow">else</span> {    <span class="comment">// no more entries in this range -&gt; delete it</span>
                            std::map&lt;OSPF::LSAKeyType, bool, OSPF::LSAKeyType_Less&gt;::const_iterator deletedIt = deletedLSAMap.find(lsaKey);
                            <span class="keywordflow">if</span> (deletedIt == deletedLSAMap.end()) {
                                summaryLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>().<a class="code" href="class_o_s_p_f_l_s_a_header.html#a9851dc72d585835bfcffa08412c33f99">setLsAge</a>(<a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a>);
                                <a class="code" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4" title="Floods out the input lsa on a set of Interfaces.">floodLSA</a>(summaryLSA, <a class="code" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">OSPF::BACKBONE_AREAID</a>);

                                deletedLSAMap[lsaKey] = <span class="keyword">true</span>;
                            }
                        }
                    }
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2aded30c394db977ffde8237065514e8"></a><!-- doxytag: member="OSPF::Router::originateASExternalLSA" ref="a2aded30c394db977ffde8237065514e8" args="(ASExternalLSA *lsa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a> * <a class="el" href="class_o_s_p_f_1_1_router.html#a2aded30c394db977ffde8237065514e8">OSPF::Router::originateASExternalLSA</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a> *&#160;</td>
          <td class="paramname"><em>lsa</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Originates a new AS External LSA based on the input lsa. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsa</td><td>[in] The LSA whose contents should be copied into the newly originated LSA. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The newly originated LSA. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>* asExternalLSA = <span class="keyword">new</span> <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>(*lsa);
    <a class="code" href="class_o_s_p_f_l_s_a_header.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFLSAHeader</a>&amp; lsaHeader = asExternalLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>();
    <a class="code" href="struct_o_s_p_f_options.html" title="Struct generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFOptions</a> lsaOptions;

    lsaHeader.<a class="code" href="class_o_s_p_f_l_s_a_header.html#a9851dc72d585835bfcffa08412c33f99">setLsAge</a>(0);
    memset(&amp;lsaOptions, 0, <span class="keyword">sizeof</span>(<a class="code" href="struct_o_s_p_f_options.html" title="Struct generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFOptions</a>));
    lsaOptions.<a class="code" href="struct_o_s_p_f_options.html#ae52711a2db18ba8c2c34ffbb9ac162e9">E_ExternalRoutingCapability</a> = <span class="keyword">true</span>;
    lsaHeader.<a class="code" href="class_o_s_p_f_l_s_a_header.html#ac2fc3bc4d66f96a30b45b89a375f05a8">setLsOptions</a>(lsaOptions);
    lsaHeader.<a class="code" href="class_o_s_p_f_l_s_a_header.html#ad1dd1ce9ff9b1c59f8638cdbb26b2d57">setLsSequenceNumber</a>(<a class="code" href="_o_s_p_fcommon_8h.html#ad441394da087bc61e24a5b99455c5589">INITIAL_SEQUENCE_NUMBER</a>);
    asExternalLSA-&gt;<a class="code" href="class_o_s_p_f_1_1_l_s_a_tracking_info.html#a4578b4a8970b754c7e3eabfbb620602d">setSource</a>(<a class="code" href="class_o_s_p_f_1_1_l_s_a_tracking_info.html#a25c15e523b3de9f3a023fbf0f6acbcfcad7b92a57ba931918db3eb12ec112bec0">OSPF::LSATrackingInfo::ORIGINATED</a>);

    <span class="keywordflow">return</span> asExternalLSA;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad87f546ac823bb4f9cff0454a6fe1dc8"></a><!-- doxytag: member="OSPF::Router::pruneASBoundaryRouterEntries" ref="ad87f546ac823bb4f9cff0454a6fe1dc8" args="(std::vector&lt; RoutingTableEntry * &gt; &amp;asbrEntries) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_o_s_p_f_1_1_router.html#ad87f546ac823bb4f9cff0454a6fe1dc8">OSPF::Router::pruneASBoundaryRouterEntries</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>asbrEntries</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prunes the input std::vector of RoutingTableEntries according to the RFC2328 Section 16.4.1. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">asbrEntries</td><td>[in/out] The list of RoutingTableEntries to prune. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>RFC2328 Section 16.4.1. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> hasNonBackboneIntraAreaPath = <span class="keyword">false</span>;
    <span class="keywordflow">for</span> (std::vector&lt;OSPF::RoutingTableEntry*&gt;::iterator it = asbrEntries.begin(); it != asbrEntries.end(); it++) {
        <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* routingEntry = *it;
        <span class="keywordflow">if</span> ((routingEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#aa2863a46a8edb4a9441df81fc4c37c92">getPathType</a>() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a3c76f6904ab261d6c8b709c7078a957f">OSPF::RoutingTableEntry::INTRAAREA</a>) &amp;&amp;
            (routingEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a5941dbf354e048d57e44692cfa27fb66">getArea</a>() != <a class="code" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">OSPF::BACKBONE_AREAID</a>))
        {
            hasNonBackboneIntraAreaPath = <span class="keyword">true</span>;
            <span class="keywordflow">break</span>;
        }
    }

    <span class="keywordflow">if</span> (hasNonBackboneIntraAreaPath) {
        std::vector&lt;OSPF::RoutingTableEntry*&gt;::iterator it = asbrEntries.begin();
        <span class="keywordflow">while</span> (it != asbrEntries.end()) {
            <span class="keywordflow">if</span> (((*it)-&gt;getPathType() != <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a32d865d25745b844bcc6100e11dfd254a3c76f6904ab261d6c8b709c7078a957f">OSPF::RoutingTableEntry::INTRAAREA</a>) ||
                ((*it)-&gt;getArea() == <a class="code" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">OSPF::BACKBONE_AREAID</a>))
            {
                it = asbrEntries.erase(it);
            } <span class="keywordflow">else</span> {
                it++;
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="af849f36506ebf49917f4a7f4ebdbcf53"></a><!-- doxytag: member="OSPF::Router::rebuildRoutingTable" ref="af849f36506ebf49917f4a7f4ebdbcf53" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_o_s_p_f_1_1_router.html#af849f36506ebf49917f4a7f4ebdbcf53">OSPF::Router::rebuildRoutingTable</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rebuilds the routing table from scratch(based on the LSA database). </p>
<dl class="see"><dt><b>See also:</b></dt><dd>RFC2328 Section 16. </dd></dl>

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_interface_state.html#a9f94bc7735d2a404e05eb7e26a38d033">OSPF::InterfaceState::changeState()</a>, and <a class="el" href="class_o_s_p_f_1_1_neighbor_state.html#a04b28a8b954660937a38409ecb7127e1">OSPF::NeighborState::changeState()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordtype">bool</span> hasTransitAreas = <span class="keyword">false</span>;
    std::vector&lt;OSPF::RoutingTableEntry*&gt; newTable;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i;

    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Rebuilding routing table:\n&quot;</span>;

    <span class="keywordflow">for</span> (i = 0; i &lt; areaCount; i++) {
        <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;calculateShortestPathTree(newTable);
        <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;getTransitCapability()) {
            hasTransitAreas = <span class="keyword">true</span>;
        }
    }
    <span class="keywordflow">if</span> (areaCount &gt; 1) {
        <a class="code" href="class_o_s_p_f_1_1_area.html">OSPF::Area</a>* backbone = <a class="code" href="class_o_s_p_f_1_1_router.html#abd611ae0dce1b3006eab26dd5b02a5af" title="Returns the pointer to the Area identified by the input areaID, if it&#39;s on the Area list...">getAreaByID</a>(<a class="code" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">OSPF::BACKBONE_AREAID</a>);
        <span class="keywordflow">if</span> (backbone != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
            backbone-&gt;<a class="code" href="class_o_s_p_f_1_1_area.html#ab7c6187fd8112847746e8df7a05b7867">calculateInterAreaRoutes</a>(newTable);
        }
    } <span class="keywordflow">else</span> {
        <span class="keywordflow">if</span> (areaCount == 1) {
            <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[0]-&gt;calculateInterAreaRoutes(newTable);
        }
    }
    <span class="keywordflow">if</span> (hasTransitAreas) {
        <span class="keywordflow">for</span> (i = 0; i &lt; areaCount; i++) {
            <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;getTransitCapability()) {
                <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;recheckSummaryLSAs(newTable);
            }
        }
    }
    <a class="code" href="class_o_s_p_f_1_1_router.html#a6aac8011e1bbf8166902e5ba4897684e" title="Calculate the AS External Routes from the ASExternalLSAs in the database.">calculateASExternalRoutes</a>(newTable);

    <span class="comment">// backup the routing table</span>
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> routeCount = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.size();
    std::vector&lt;OSPF::RoutingTableEntry*&gt; oldTable;

    oldTable.assign(<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.begin(), <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.end());
    <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.clear();
    <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.assign(newTable.begin(), newTable.end());

    <a class="code" href="class_routing_table_access.html" title="Gives access to the IRoutingTable.">RoutingTableAccess</a> routingTableAccess;
    std::vector&lt;IPv4Route*&gt; eraseEntries;
    <a class="code" href="class_i_routing_table.html" title="A C++ interface to abstract the functionality of IRoutingTable.">IRoutingTable</a>* simRoutingTable = routingTableAccess.<a class="code" href="class_module_access.html#a46a82b1fa0e957eb42d29c8637df1f4f">get</a>();
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> routingEntryNumber = simRoutingTable-&gt;<a class="code" href="class_i_routing_table.html#ada2fac98d1d1c80c291be239b075c63b" title="Returns the total number of unicast routes.">getNumRoutes</a>();
    <span class="comment">// remove entries from the IPv4 routing table inserted by the OSPF module</span>
    <span class="keywordflow">for</span> (i = 0; i &lt; routingEntryNumber; i++) {
        <a class="code" href="class_i_pv4_route.html" title="IPv4 unicast route in IRoutingTable.">IPv4Route</a> *entry = simRoutingTable-&gt;<a class="code" href="class_i_routing_table.html#a0f5f8297974432af7092a3ca19b0217e" title="Returns the kth route.">getRoute</a>(i);
        <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* ospfEntry = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>*<span class="keyword">&gt;</span>(entry);
        <span class="keywordflow">if</span> (ospfEntry != <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
            eraseEntries.push_back(entry);
        }
    }

    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eraseCount = eraseEntries.size();
    <span class="keywordflow">for</span> (i = 0; i &lt; eraseCount; i++) {
        simRoutingTable-&gt;<a class="code" href="class_i_routing_table.html#a318a5f6e4382cb52dbc25d714df7a994" title="Deletes the given route from the routing table.">deleteRoute</a>(eraseEntries[i]);
    }

    <span class="comment">// add the new routing entries</span>
    routeCount = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.size();
    <span class="keywordflow">for</span> (i = 0; i &lt; routeCount; i++) {
        <span class="keywordflow">if</span> (<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]-&gt;getDestinationType() == <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a8b5b8d21ccec069a781e4f4f4eca9dca">OSPF::RoutingTableEntry::NETWORK_DESTINATION</a>) {
            simRoutingTable-&gt;<a class="code" href="class_i_routing_table.html#ad7be1ebe567f40bca667ba0f33a2ca8d" title="Adds a route to the routing table.">addRoute</a>(<span class="keyword">new</span> <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>(*(<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i])));
        }
    }

    <a class="code" href="class_o_s_p_f_1_1_router.html#acae55a162eaf731e634d0b121a3f59dc" title="After a routing table rebuild the changes in the routing table are identified and new SummaryLSAs are...">notifyAboutRoutingTableChanges</a>(oldTable);

    routeCount = oldTable.size();
    <span class="keywordflow">for</span> (i = 0; i &lt; routeCount; i++) {
        <span class="keyword">delete</span> (oldTable[i]);
    }

    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Routing table was rebuilt.\n&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Results:\n&quot;</span>;

    routeCount = <a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>.size();
    <span class="keywordflow">for</span> (i = 0; i &lt; routeCount; i++) {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; *<a class="code" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090" title="The OSPF routing table - contains more information than the one in the IP layer.">routingTable</a>[i]
           &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa7e20ed6b4bdfb18375bb8e10e616e9b"></a><!-- doxytag: member="OSPF::Router::removeExternalRoute" ref="aa7e20ed6b4bdfb18375bb8e10e616e9b" args="(IPv4Address networkAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_o_s_p_f_1_1_router.html#aa7e20ed6b4bdfb18375bb8e10e616e9b">OSPF::Router::removeExternalRoute</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv4_address.html">IPv4Address</a>&#160;</td>
          <td class="paramname"><em>networkAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes an AS External Route from the database. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">networkAddress</td><td>[in] The network address of the external route which needs to be removed. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a> lsaKey;

    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a3a05e7e193451f3979803d5e93362ead">linkStateID</a> = networkAddress;
    lsaKey.<a class="code" href="struct_o_s_p_f_1_1_l_s_a_key_type.html#a583e0f1cf5e052a08dc21dbcd405e8b6">advertisingRouter</a> = <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>;

    std::map&lt;OSPF::LSAKeyType, OSPF::ASExternalLSA*, OSPF::LSAKeyType_Less&gt;::iterator lsaIt = <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.find(lsaKey);
    <span class="keywordflow">if</span> (lsaIt != <a class="code" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2" title="A map of the ASExternalLSAs advertised by this router.">asExternalLSAsByID</a>.end()) {
        lsaIt-&gt;second-&gt;getHeader().setLsAge(<a class="code" href="_o_s_p_fcommon_8h.html#a22c87c874ff5382c5d082b860110e363">MAX_AGE</a>);
        lsaIt-&gt;second-&gt;setPurgeable();
        <a class="code" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4" title="Floods out the input lsa on a set of Interfaces.">floodLSA</a>(lsaIt-&gt;second, <a class="code" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">OSPF::BACKBONE_AREAID</a>);
    }

    std::map&lt;IPv4Address, OSPFASExternalLSAContents&gt;::iterator externalIt = <a class="code" href="class_o_s_p_f_1_1_router.html#a6b43eee6bada1dbffd4e7ceb01efb58e" title="A map of the external route advertised by this router.">externalRoutes</a>.find(networkAddress);
    <span class="keywordflow">if</span> (externalIt != <a class="code" href="class_o_s_p_f_1_1_router.html#a6b43eee6bada1dbffd4e7ceb01efb58e" title="A map of the external route advertised by this router.">externalRoutes</a>.end()) {
        <a class="code" href="class_o_s_p_f_1_1_router.html#a6b43eee6bada1dbffd4e7ceb01efb58e" title="A map of the external route advertised by this router.">externalRoutes</a>.erase(externalIt);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa8c94ba4d4bd22592af06b6cef21c501"></a><!-- doxytag: member="OSPF::Router::removeFromAllRetransmissionLists" ref="aa8c94ba4d4bd22592af06b6cef21c501" args="(LSAKeyType lsaKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_o_s_p_f_1_1_router.html#aa8c94ba4d4bd22592af06b6cef21c501">OSPF::Router::removeFromAllRetransmissionLists</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">OSPF::LSAKeyType</a>&#160;</td>
          <td class="paramname"><em>lsaKey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all LSAs from all <a class="el" href="class_o_s_p_f_1_1_neighbor.html">Neighbor</a>'s retransmission lists which are identified by the input lsaKey. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lsaKey</td><td>[in] Identifies the LSAs to remove from the retransmission lists. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">long</span> areaCount = <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; areaCount; i++) {
        <a class="code" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8" title="A list of the contained areas.">areas</a>[i]-&gt;removeFromAllRetransmissionLists(lsaKey);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab3274a2e9aa8cd3b559401f68f8b44ec"></a><!-- doxytag: member="OSPF::Router::selectLeastCostRoutingEntry" ref="ab3274a2e9aa8cd3b559401f68f8b44ec" args="(std::vector&lt; RoutingTableEntry * &gt; &amp;entries) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a> * <a class="el" href="class_o_s_p_f_1_1_router.html#ab3274a2e9aa8cd3b559401f68f8b44ec">OSPF::Router::selectLeastCostRoutingEntry</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>entries</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Selects the least cost <a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a> from the input std::vector of RoutingTableEntries. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">entries</td><td>[in] The RoutingTableEntries to choose the least cost one from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The least cost entry or NULL if entries is empty. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (entries.empty()) {
        <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
    }

    <a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html">OSPF::RoutingTableEntry</a>* leastCostEntry = entries[0];
    <a class="code" href="namespace_o_s_p_f.html#a4a99812a2d079df0f7208f2740cdb0ad">Metric</a> leastCost = leastCostEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#ae88c6036122cdd9000332145c1b96859">getCost</a>();
    <span class="keywordtype">long</span> routeCount = entries.size();

    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 1; i &lt; routeCount; i++) {
        <a class="code" href="namespace_o_s_p_f.html#a4a99812a2d079df0f7208f2740cdb0ad">Metric</a> currentCost = entries[i]-&gt;getCost();
        <span class="keywordflow">if</span> ((currentCost &lt; leastCost) ||
            ((currentCost == leastCost) &amp;&amp; (entries[i]-&gt;getArea() &gt; leastCostEntry-&gt;<a class="code" href="class_o_s_p_f_1_1_routing_table_entry.html#a5941dbf354e048d57e44692cfa27fb66">getArea</a>())))
        {
            leastCostEntry = entries[i];
            leastCost = currentCost;
        }
    }

    <span class="keywordflow">return</span> leastCostEntry;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a16b7ec42a0a4072d0299fddaa5ae57bc"></a><!-- doxytag: member="OSPF::Router::setRFC1583Compatibility" ref="a16b7ec42a0a4072d0299fddaa5ae57bc" args="(bool compatibility)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_o_s_p_f_1_1_router.html#a16b7ec42a0a4072d0299fddaa5ae57bc">OSPF::Router::setRFC1583Compatibility</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compatibility</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_o_s_p_f_routing.html#abec8786045419fda13d0ccd094fa917b">OSPFRouting::loadConfigFromXML()</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="class_o_s_p_f_1_1_router.html#a10f71a71f20baa02d35f94d602758357" title="Decides whether to handle the preferred routing table entry to an AS boundary router as defined in RF...">rfc1583Compatibility</a> = compatibility; }
</pre></div>
</div>
</div>
<a class="anchor" id="ab997cc64af49534585ce56de7ba27349"></a><!-- doxytag: member="OSPF::Router::setRouterID" ref="ab997cc64af49534585ce56de7ba27349" args="(RouterID id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_o_s_p_f_1_1_router.html#ab997cc64af49534585ce56de7ba27349">OSPF::Router::setRouterID</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_o_s_p_f.html#adbcc14dbfc5290248d3f865bd3a56af4">RouterID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a> = <a class="code" href="_t_c_p___n_s_c_8cc.html#a4fc3a0c58dfbd1e68224521185cb9384">id</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a542dd39f87a1f348d9f555b9823c9a07"></a><!-- doxytag: member="OSPF::Router::updateExternalRoute" ref="a542dd39f87a1f348d9f555b9823c9a07" args="(IPv4Address networkAddress, const OSPFASExternalLSAContents &amp;externalRouteContents, int ifIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_o_s_p_f_1_1_router.html#a542dd39f87a1f348d9f555b9823c9a07">OSPF::Router::updateExternalRoute</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv4_address.html">IPv4Address</a>&#160;</td>
          <td class="paramname"><em>networkAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_s_p_f_a_s_external_l_s_a_contents.html">OSPFASExternalLSAContents</a> &amp;&#160;</td>
          <td class="paramname"><em>externalRouteContents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ifIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stores information on an AS External Route in externalRoutes and intalls(or updates) a new <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a> into the database. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">networkAddress</td><td>[in] The external route's network address. </td></tr>
    <tr><td class="paramname">externalRouteContents</td><td>[in] Route configuration data for the external route. </td></tr>
    <tr><td class="paramname">ifIndex</td><td>[in] </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="class_o_s_p_f_routing.html#a56cf176bc9fa04d309cfd47a512f291f">OSPFRouting::insertExternalRoute()</a>, and <a class="el" href="class_o_s_p_f_routing.html#ac65493078bbeb6c48808d191eda44454">OSPFRouting::loadExternalRoute()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>* asExternalLSA = <span class="keyword">new</span> <a class="code" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">OSPF::ASExternalLSA</a>;
    <a class="code" href="class_o_s_p_f_l_s_a_header.html" title="Class generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFLSAHeader</a>&amp; lsaHeader = asExternalLSA-&gt;<a class="code" href="class_o_s_p_f_l_s_a.html#a2c9acdc68e5e66deb1826ee41a07b7d1">getHeader</a>();
    <a class="code" href="struct_o_s_p_f_options.html" title="Struct generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFOptions</a> lsaOptions;
    <span class="comment">//OSPF::LSAKeyType lsaKey;</span>

    <a class="code" href="class_i_routing_table.html" title="A C++ interface to abstract the functionality of IRoutingTable.">IRoutingTable</a>* simRoutingTable = <a class="code" href="class_routing_table_access.html" title="Gives access to the IRoutingTable.">RoutingTableAccess</a>().<a class="code" href="class_module_access.html#a46a82b1fa0e957eb42d29c8637df1f4f">get</a>();
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> routingEntryNumber = simRoutingTable-&gt;<a class="code" href="class_i_routing_table.html#ada2fac98d1d1c80c291be239b075c63b" title="Returns the total number of unicast routes.">getNumRoutes</a>();
    <span class="keywordtype">bool</span> inRoutingTable = <span class="keyword">false</span>;
    <span class="comment">// add the external route to the routing table if it was not added by another module</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i = 0; i &lt; routingEntryNumber; i++)
    {
        <span class="keyword">const</span> <a class="code" href="class_i_pv4_route.html" title="IPv4 unicast route in IRoutingTable.">IPv4Route</a> *entry = simRoutingTable-&gt;<a class="code" href="class_i_routing_table.html#a0f5f8297974432af7092a3ca19b0217e" title="Returns the kth route.">getRoute</a>(i);
        <span class="keywordflow">if</span> ((entry-&gt;<a class="code" href="class_i_pv4_route.html#a4982ef0132d4e1560371231b7c11cf8c" title="Destination address prefix to match.">getDestination</a>() == networkAddress)
                &amp;&amp; (entry-&gt;<a class="code" href="class_i_pv4_route.html#ac7d8f045f17b54b9d7e364cd525ba9ae" title="Represents length of prefix to match.">getNetmask</a>() == externalRouteContents.<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#a6a0d7bdb279abb7fa1a3d44622c0ff60">getNetworkMask</a>())) <span class="comment">//TODO is it enough?</span>
        {
            inRoutingTable = <span class="keyword">true</span>;
        }
    }

    <span class="keywordflow">if</span> (!inRoutingTable)
    {
        <a class="code" href="class_i_pv4_route.html" title="IPv4 unicast route in IRoutingTable.">IPv4Route</a>* entry = <span class="keyword">new</span> <a class="code" href="class_i_pv4_route.html" title="IPv4 unicast route in IRoutingTable.">IPv4Route</a>;
        entry-&gt;<a class="code" href="class_i_pv4_route.html#a75d1011d4002c8a9503f3a42aff66c70">setDestination</a>(networkAddress);
        entry-&gt;<a class="code" href="class_i_pv4_route.html#a625acf9119fbc2bd5255c56096a36d38">setNetmask</a>(externalRouteContents.<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#a6a0d7bdb279abb7fa1a3d44622c0ff60">getNetworkMask</a>());
        entry-&gt;<a class="code" href="class_i_pv4_route.html#af7fc0b9d45d7fcbe603b679993e38ee5">setInterface</a>(<a class="code" href="class_interface_table_access.html" title="Gives access to IInterfaceTable.">InterfaceTableAccess</a>().<span class="keyword">get</span>()-&gt;getInterfaceById(ifIndex));
        entry-&gt;<a class="code" href="class_i_pv4_route.html#a2213017b93a2ee8b31dc5f38502f6166">setSource</a>(<a class="code" href="class_i_pv4_route.html#a01abe3b809ba83ebbb0a3f01f6919683a9a5c4f7f61b5d99a5c5953cfaf79590b" title="manually added static route">IPv4Route::MANUAL</a>);
        entry-&gt;<a class="code" href="class_i_pv4_route.html#a835720d0f2b89896063b1296d85c57cc">setMetric</a>(externalRouteContents.<a class="code" href="class_o_s_p_f_a_s_external_l_s_a_contents.html#a9158b3adccf5864d8806813976f44b38">getRouteCost</a>());
        simRoutingTable-&gt;<a class="code" href="class_i_routing_table.html#ad7be1ebe567f40bca667ba0f33a2ca8d" title="Adds a route to the routing table.">addRoute</a>(entry);   <span class="comment">// IRoutingTable deletes entry pointer</span>
    }

    lsaHeader.<a class="code" href="class_o_s_p_f_l_s_a_header.html#a9851dc72d585835bfcffa08412c33f99">setLsAge</a>(0);
    memset(&amp;lsaOptions, 0, <span class="keyword">sizeof</span>(<a class="code" href="struct_o_s_p_f_options.html" title="Struct generated from networklayer/ospfv2/OSPFPacket.msg by opp_msgc.">OSPFOptions</a>));
    lsaOptions.<a class="code" href="struct_o_s_p_f_options.html#ae52711a2db18ba8c2c34ffbb9ac162e9">E_ExternalRoutingCapability</a> = <span class="keyword">true</span>;
    lsaHeader.<a class="code" href="class_o_s_p_f_l_s_a_header.html#ac2fc3bc4d66f96a30b45b89a375f05a8">setLsOptions</a>(lsaOptions);
    lsaHeader.<a class="code" href="class_o_s_p_f_l_s_a_header.html#abd865c985b8ba49b4507ac361577786c">setLsType</a>(<a class="code" href="_o_s_p_f_packet__m_8h.html#a13a450dbb578c4bd7714af8581c4f89ba5a085d8393eb69080f4819ea84627021">AS_EXTERNAL_LSA_TYPE</a>);
    lsaHeader.<a class="code" href="class_o_s_p_f_l_s_a_header.html#ae920adcdc225b035fefeaf22a441c96b">setLinkStateID</a>(networkAddress);   <span class="comment">// TODO: get unique LinkStateID</span>
    lsaHeader.<a class="code" href="class_o_s_p_f_l_s_a_header.html#a0365764d198af8df2c09e38973d91411">setAdvertisingRouter</a>(<a class="code" href="class_i_pv4_address.html" title="IPv4 address.">IPv4Address</a>(<a class="code" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9" title="The router ID assigned by the IP layer.">routerID</a>));
    lsaHeader.<a class="code" href="class_o_s_p_f_l_s_a_header.html#ad1dd1ce9ff9b1c59f8638cdbb26b2d57">setLsSequenceNumber</a>(<a class="code" href="_o_s_p_fcommon_8h.html#ad441394da087bc61e24a5b99455c5589">INITIAL_SEQUENCE_NUMBER</a>);

    asExternalLSA-&gt;<a class="code" href="class_o_s_p_f_a_s_external_l_s_a.html#a6055f611d3968fead74f27276b754f25">setContents</a>(externalRouteContents);

    asExternalLSA-&gt;<a class="code" href="class_o_s_p_f_1_1_l_s_a_tracking_info.html#a4578b4a8970b754c7e3eabfbb620602d">setSource</a>(<a class="code" href="class_o_s_p_f_1_1_l_s_a_tracking_info.html#a25c15e523b3de9f3a023fbf0f6acbcfcad7b92a57ba931918db3eb12ec112bec0">OSPF::LSATrackingInfo::ORIGINATED</a>);

    <a class="code" href="class_o_s_p_f_1_1_router.html#a6b43eee6bada1dbffd4e7ceb01efb58e" title="A map of the external route advertised by this router.">externalRoutes</a>[networkAddress] = externalRouteContents;

    <span class="keywordtype">bool</span> rebuild = <a class="code" href="class_o_s_p_f_1_1_router.html#a7d3ec4918c945ee00863f46bb07fe52f" title="Installs a new AS External LSA into the Router&#39;s database.">installASExternalLSA</a>(asExternalLSA);
    <a class="code" href="class_o_s_p_f_1_1_router.html#a053e23535ff2239aacd34782df554eb4" title="Floods out the input lsa on a set of Interfaces.">floodLSA</a>(asExternalLSA, <a class="code" href="namespace_o_s_p_f.html#a291fdf79093588fa8aeb40e22fdbbfc7">OSPF::BACKBONE_AREAID</a>);
    <span class="keyword">delete</span> asExternalLSA;

    <span class="keywordflow">if</span> (rebuild) {
        <a class="code" href="class_o_s_p_f_1_1_router.html#af849f36506ebf49917f4a7f4ebdbcf53" title="Rebuilds the routing table from scratch(based on the LSA database).">rebuildRoutingTable</a>();
    }
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="acafd411e92c5c3bc952daadbc0d53cf5"></a><!-- doxytag: member="OSPF::Router::ageTimer" ref="acafd411e92c5c3bc952daadbc0d53cf5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_timer.html">OSPFTimer</a>* <a class="el" href="class_o_s_p_f_1_1_router.html#acafd411e92c5c3bc952daadbc0d53cf5">OSPF::Router::ageTimer</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Database age timer - fires every second. </p>

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_router.html#a35bbf6cd398015ef42d76223e745ba2e">Router()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ce9c0ecf94cbc5872c346750e4de6b8"></a><!-- doxytag: member="OSPF::Router::areas" ref="a5ce9c0ecf94cbc5872c346750e4de6b8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_o_s_p_f_1_1_area.html">Area</a>*&gt; <a class="el" href="class_o_s_p_f_1_1_router.html#a5ce9c0ecf94cbc5872c346750e4de6b8">OSPF::Router::areas</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A list of the contained areas. </p>

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_router.html#aabec2db341f674865b3a9e6393889371">getAreaCount()</a>.</p>

</div>
</div>
<a class="anchor" id="ab2c936939863bd82c6628c794e6409e5"></a><!-- doxytag: member="OSPF::Router::areasByID" ref="ab2c936939863bd82c6628c794e6409e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="namespace_o_s_p_f.html#a48c8e4d3af2a46ddb912740d4e2e91b1">AreaID</a>, <a class="el" href="class_o_s_p_f_1_1_area.html">Area</a>*&gt; <a class="el" href="class_o_s_p_f_1_1_router.html#ab2c936939863bd82c6628c794e6409e5">OSPF::Router::areasByID</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A map of the contained areas with the AreaID as key. </p>

</div>
</div>
<a class="anchor" id="a20e18099b999ef4fd3eebca715173f36"></a><!-- doxytag: member="OSPF::Router::asExternalLSAs" ref="a20e18099b999ef4fd3eebca715173f36" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a>*&gt; <a class="el" href="class_o_s_p_f_1_1_router.html#a20e18099b999ef4fd3eebca715173f36">OSPF::Router::asExternalLSAs</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A list of the ASExternalLSAs advertised by this router. </p>

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_router.html#a6647017c994ddead153bfda8cedc7c5f">getASExternalLSA()</a>, and <a class="el" href="class_o_s_p_f_1_1_router.html#a83627b1e7011409dd355dfd004a8a3a8">getASExternalLSACount()</a>.</p>

</div>
</div>
<a class="anchor" id="abbdacd52ab234eb19f6eeb24a06222c2"></a><!-- doxytag: member="OSPF::Router::asExternalLSAsByID" ref="abbdacd52ab234eb19f6eeb24a06222c2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="struct_o_s_p_f_1_1_l_s_a_key_type.html">LSAKeyType</a>, <a class="el" href="class_o_s_p_f_1_1_a_s_external_l_s_a.html">ASExternalLSA</a>*, <a class="el" href="class_o_s_p_f_1_1_l_s_a_key_type___less.html">LSAKeyType_Less</a>&gt; <a class="el" href="class_o_s_p_f_1_1_router.html#abbdacd52ab234eb19f6eeb24a06222c2">OSPF::Router::asExternalLSAsByID</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A map of the ASExternalLSAs advertised by this router. </p>

</div>
</div>
<a class="anchor" id="a6b43eee6bada1dbffd4e7ceb01efb58e"></a><!-- doxytag: member="OSPF::Router::externalRoutes" ref="a6b43eee6bada1dbffd4e7ceb01efb58e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="class_i_pv4_address.html">IPv4Address</a>, <a class="el" href="class_o_s_p_f_a_s_external_l_s_a_contents.html">OSPFASExternalLSAContents</a>&gt; <a class="el" href="class_o_s_p_f_1_1_router.html#a6b43eee6bada1dbffd4e7ceb01efb58e">OSPF::Router::externalRoutes</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A map of the external route advertised by this router. </p>

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_router.html#a3f6f54e668fb6f2f7298949bbcab43bf">getASBoundaryRouter()</a>.</p>

</div>
</div>
<a class="anchor" id="a532e99a63a766b3aabc007fd929fb48f"></a><!-- doxytag: member="OSPF::Router::messageHandler" ref="a532e99a63a766b3aabc007fd929fb48f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_s_p_f_1_1_message_handler.html">MessageHandler</a>* <a class="el" href="class_o_s_p_f_1_1_router.html#a532e99a63a766b3aabc007fd929fb48f">OSPF::Router::messageHandler</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The message dispatcher class. </p>

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_router.html#a0142a9cc0f45692f0af116de386f9d6b">getMessageHandler()</a>, and <a class="el" href="class_o_s_p_f_1_1_router.html#a35bbf6cd398015ef42d76223e745ba2e">Router()</a>.</p>

</div>
</div>
<a class="anchor" id="a10f71a71f20baa02d35f94d602758357"></a><!-- doxytag: member="OSPF::Router::rfc1583Compatibility" ref="a10f71a71f20baa02d35f94d602758357" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_s_p_f_1_1_router.html#a10f71a71f20baa02d35f94d602758357">OSPF::Router::rfc1583Compatibility</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decides whether to handle the preferred routing table entry to an AS boundary router as defined in RFC1583 or not. </p>

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_router.html#a3eeb651fd988d86f63d811bb88a9c121">getRFC1583Compatibility()</a>, and <a class="el" href="class_o_s_p_f_1_1_router.html#a16b7ec42a0a4072d0299fddaa5ae57bc">setRFC1583Compatibility()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ebbdb2a44054edf297b21360de68cb9"></a><!-- doxytag: member="OSPF::Router::routerID" ref="a3ebbdb2a44054edf297b21360de68cb9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_o_s_p_f.html#adbcc14dbfc5290248d3f865bd3a56af4">RouterID</a> <a class="el" href="class_o_s_p_f_1_1_router.html#a3ebbdb2a44054edf297b21360de68cb9">OSPF::Router::routerID</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The router ID assigned by the IP layer. </p>

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_router.html#abf4855bc5ad7dfb4a47d1aae3b003751">getRouterID()</a>, and <a class="el" href="class_o_s_p_f_1_1_router.html#ab997cc64af49534585ce56de7ba27349">setRouterID()</a>.</p>

</div>
</div>
<a class="anchor" id="aff527f73b1c4068c21abb9fe9dd9f090"></a><!-- doxytag: member="OSPF::Router::routingTable" ref="aff527f73b1c4068c21abb9fe9dd9f090" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_o_s_p_f_1_1_routing_table_entry.html">RoutingTableEntry</a>*&gt; <a class="el" href="class_o_s_p_f_1_1_router.html#aff527f73b1c4068c21abb9fe9dd9f090">OSPF::Router::routingTable</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <a class="el" href="namespace_o_s_p_f.html" title="All OSPF classes are in this namespace.">OSPF</a> routing table - contains more information than the one in the IP layer. </p>

<p>Referenced by <a class="el" href="class_o_s_p_f_1_1_router.html#ad98dc1515ff6fed37dfc3097a5e68e21">addRoutingTableEntry()</a>, <a class="el" href="class_o_s_p_f_1_1_router.html#a7f08a4ee470038b5e86af3491de83614">getRoutingTableEntry()</a>, and <a class="el" href="class_o_s_p_f_1_1_router.html#a77a1be6cab855fe8d2a9c269a500b313">getRoutingTableEntryCount()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_o_s_p_f_router_8h.html">OSPFRouter.h</a></li>
<li><a class="el" href="_o_s_p_f_router_8cc.html">OSPFRouter.cc</a></li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_o_s_p_f.html">OSPF</a>      </li>
      <li class="navelem"><a class="el" href="class_o_s_p_f_1_1_router.html">Router</a>      </li>

    <li class="footer">Generated on Tue Aug 7 2012 16:01:33 for INET Framework for OMNeT++/OMNEST by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
