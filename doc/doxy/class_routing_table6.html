<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>INET Framework for OMNeT++/OMNEST: RoutingTable6 Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">INET Framework for OMNeT++/OMNEST
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_routing_table6.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">RoutingTable6 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="RoutingTable6" --><!-- doxytag: inherits="INotifiable" -->
<p>Represents the <a class="el" href="class_i_pv6.html" title="IPv6 implementation.">IPv6</a> routing table and neighbour discovery data structures.  
 <a href="class_routing_table6.html#details">More...</a></p>

<p><code>#include &lt;RoutingTable6.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RoutingTable6:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_routing_table6.png" usemap="#RoutingTable6_map" alt=""/>
  <map id="RoutingTable6_map" name="RoutingTable6_map">
<area href="class_i_notifiable.html" title="Clients can receive change notifications from the NotificationBoard via this interface." alt="INotifiable" shape="rect" coords="0,0,92,24"/>
</map>
 </div></div>

<p><a href="class_routing_table6-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_routing_table6_1_1_dest_cache_entry.html">DestCacheEntry</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a212c6cdbc175cef88bfcc3cc17ef842d">RoutingTable6</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#aa08b78617d4f08502d746686ecf0a58c">~RoutingTable6</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a79a742fa2d94543412e183ebe0e83d3a">isRouter</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IP forwarding on/off.  <a href="#a79a742fa2d94543412e183ebe0e83d3a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Interfaces</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a24cede6c1b7ed7a17fad2525a4702851">getInterfaceByAddress</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;address)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an interface given by its address.  <a href="#a24cede6c1b7ed7a17fad2525a4702851"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Routing functions</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#acbf9dbfff5efa25eec0982afa1bbf061">isLocalAddress</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;dest) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the address is one of the host's addresses, i.e.  <a href="#acbf9dbfff5efa25eec0982afa1bbf061"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#abb5be347a43ea6c6fb5ddfd6711e15a3">lookupDestCache</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;dest, int &amp;outInterfaceId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up the given destination address in the Destination Cache, then returns the next-hop address and the interface in the outInterfaceId variable.  <a href="#abb5be347a43ea6c6fb5ddfd6711e15a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_i_pv6_route.html">IPv6Route</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#aa3ba1d17dc59f3e5d77ead359dd3a999">doLongestPrefixMatch</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;dest)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs longest prefix match in the routing table and returns the resulting route, or NULL if there was no match.  <a href="#aa3ba1d17dc59f3e5d77ead359dd3a999"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#afef0aa2431b02b3744b58238c7a73547">isPrefixPresent</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;prefix) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given prefix already exists in the routing table (prefix list)  <a href="#afef0aa2431b02b3744b58238c7a73547"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Managing the destination cache</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a1e7fbe36b5dcdfa80e6af5b0c0eea235">updateDestCache</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;dest, const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;nextHopAddr, int interfaceId, simtime_t expiryTime)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or update a destination cache entry.  <a href="#a1e7fbe36b5dcdfa80e6af5b0c0eea235"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a508ea0dd32bd3256348e99abe32a48a9">purgeDestCache</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard all entries in destination cache.  <a href="#a508ea0dd32bd3256348e99abe32a48a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a1b4f1c86d678de8ac3f873ac7de0687f">purgeDestCacheEntriesToNeighbour</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;nextHopAddr, int interfaceId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard all entries in destination cache where next hop is the given address on the given interface.  <a href="#a1b4f1c86d678de8ac3f873ac7de0687f"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Managing prefixes and the route table</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#ad942d6cb5b1376b132947f75924344f6">addOrUpdateOnLinkPrefix</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;destPrefix, int prefixLength, int interfaceId, simtime_t expiryTime)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add on-link prefix (route of type FROM_RA), or update existing one.  <a href="#ad942d6cb5b1376b132947f75924344f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a85e00922381c188efc0ad51197e5f718">removeOnLinkPrefix</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;destPrefix, int prefixLength)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an on-link prefix.  <a href="#a85e00922381c188efc0ad51197e5f718"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#aad45eef791b41fe469357f1f4c6090bb">addOrUpdateOwnAdvPrefix</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;destPrefix, int prefixLength, int interfaceId, simtime_t expiryTime)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add route of type OWN_ADV_PREFIX.  <a href="#aad45eef791b41fe469357f1f4c6090bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#adf9413825a24ef26051d8a78539dec29">addStaticRoute</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;destPrefix, int prefixLength, unsigned int interfaceId, const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;nextHop, int metric=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static route.  <a href="#adf9413825a24ef26051d8a78539dec29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a50f73e181d9c5e965ad72f74f0b43c40">addDefaultRoute</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;raSrcAddr, unsigned int ifID, simtime_t routerLifetime)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a default route for a host.  <a href="#a50f73e181d9c5e965ad72f74f0b43c40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#af11c468a66aa9edc3b16cc7b6b01d5bb">addRoutingProtocolRoute</a> (<a class="el" href="class_i_pv6_route.html">IPv6Route</a> *route)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given getRoute(which can be OSPF, BGP, RIP or any other route) with src==ROUTING_PROT.  <a href="#af11c468a66aa9edc3b16cc7b6b01d5bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#acd6b7dbf0bfa1e923366a2bcb1f309fc">removeRoute</a> (<a class="el" href="class_i_pv6_route.html">IPv6Route</a> *route)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the given route from the route table.  <a href="#acd6b7dbf0bfa1e923366a2bcb1f309fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a384a101ad5895b4cdbc796ec0fb427e3">getNumRoutes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of routes.  <a href="#a384a101ad5895b4cdbc796ec0fb427e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_i_pv6_route.html">IPv6Route</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a037e2206e766dff2c8cc904694feba88">getRoute</a> (int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ith route.  <a href="#a037e2206e766dff2c8cc904694feba88"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="class_i_pv6_address.html">IPv6Address</a>, <br class="typebreak"/>
<a class="el" href="struct_routing_table6_1_1_dest_cache_entry.html">DestCacheEntry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#ae97d16a39dd6e82ed1fef07e2bd5ac49">DestCache</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="class_i_pv6_route.html">IPv6Route</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#ae2d7a96a112758e54bb1fa5e5f41d4bc">RouteList</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#ac5315cdff4b757915773f1c22f273ba4">addRoute</a> (<a class="el" href="class_i_pv6_route.html">IPv6Route</a> *route)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#ab78638e39019d6ca1690d926da5f04fe">configureInterfaceForIPv6</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a84a7121fd02397bfd4ea169675381e3e">assignRequiredNodeAddresses</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">RFC 3513: Section 2.8 A Node's Required Address Assign the various addresses to the node's respective interface.  <a href="#a84a7121fd02397bfd4ea169675381e3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a5d4f86dbabc31663a4bd12f50a72140f">configureInterfaceFromXML</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie, cXMLElement *cfg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a0a0c804ccf3360f7476aa1e21b66e79e">configureTunnelFromXML</a> (cXMLElement *cfg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#ac174c90714b3e6b245c5084850651af7">updateDisplayString</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a19bf3f3581b2564834e3afda3c7181e6">numInitStages</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a3a930dca8cabc52375c754dfce15252d">initialize</a> (int stage)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a3dc6e638b861a416cd1a44f8dbde473a">parseXMLConfigFile</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a3aa22d18d79d749697aba97c01e21076">handleMessage</a> (cMessage *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises an error.  <a href="#a3aa22d18d79d749697aba97c01e21076"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a6d1b8498895ed9efdefd0227219a9f85">receiveChangeNotification</a> (int category, const cObject *details)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the <a class="el" href="class_notification_board.html" title="Acts as a intermediary between module where state changes can occur and modules which are interested ...">NotificationBoard</a> whenever a change of a category occurs to which this client has subscribed.  <a href="#a6d1b8498895ed9efdefd0227219a9f85"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a707cec2ac6652e7eb0ff97b53f70d9b9">routeLessThan</a> (const <a class="el" href="class_i_pv6_route.html">IPv6Route</a> *a, const <a class="el" href="class_i_pv6_route.html">IPv6Route</a> *b)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_interface_table.html">IInterfaceTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#aaaec39a83ad4a660b4cea65d1266b0e4">ift</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_notification_board.html">NotificationBoard</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a03a9b00ecf47fb5395108c427d9e05f7">nb</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a0cebbe3d99a2059179fbb17dc833476d">isrouter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_routing_table6.html#ae97d16a39dd6e82ed1fef07e2bd5ac49">DestCache</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a40eeef91dde2b4b37c53fdc2d88a6b7d">destCache</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_routing_table6.html#ae2d7a96a112758e54bb1fa5e5f41d4bc">RouteList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_routing_table6.html#a9a8e6d548f687ed667d614b61d4b7ab8">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="struct_routing_table6_1_1_dest_cache_entry.html">DestCacheEntry</a> &amp;e)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Represents the <a class="el" href="class_i_pv6.html" title="IPv6 implementation.">IPv6</a> routing table and neighbour discovery data structures. </p>
<p>This object has one instance per host or router.</p>
<p>See the NED documentation for general overview.</p>
<p>This is a simple module without gates, it requires function calls to it (message handling does nothing). Methods are provided for reading and updating the interface table and the route table, as well as for unicast and multicast routing.</p>
<p>The route table is read from a file. The route table can also be read and modified during simulation, typically by routing protocol implementations. </p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ae97d16a39dd6e82ed1fef07e2bd5ac49"></a><!-- doxytag: member="RoutingTable6::DestCache" ref="ae97d16a39dd6e82ed1fef07e2bd5ac49" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="class_i_pv6_address.html">IPv6Address</a>,<a class="el" href="struct_routing_table6_1_1_dest_cache_entry.html">DestCacheEntry</a>&gt; <a class="el" href="class_routing_table6.html#ae97d16a39dd6e82ed1fef07e2bd5ac49">RoutingTable6::DestCache</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae2d7a96a112758e54bb1fa5e5f41d4bc"></a><!-- doxytag: member="RoutingTable6::RouteList" ref="ae2d7a96a112758e54bb1fa5e5f41d4bc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="class_i_pv6_route.html">IPv6Route</a>*&gt; <a class="el" href="class_routing_table6.html#ae2d7a96a112758e54bb1fa5e5f41d4bc">RoutingTable6::RouteList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a212c6cdbc175cef88bfcc3cc17ef842d"></a><!-- doxytag: member="RoutingTable6::RoutingTable6" ref="a212c6cdbc175cef88bfcc3cc17ef842d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_routing_table6.html#a212c6cdbc175cef88bfcc3cc17ef842d">RoutingTable6::RoutingTable6</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa08b78617d4f08502d746686ecf0a58c"></a><!-- doxytag: member="RoutingTable6::~RoutingTable6" ref="aa08b78617d4f08502d746686ecf0a58c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_routing_table6.html#aa08b78617d4f08502d746686ecf0a58c">RoutingTable6::~RoutingTable6</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.size(); i++)
        <span class="keyword">delete</span> <a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>[i];
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a50f73e181d9c5e965ad72f74f0b43c40"></a><!-- doxytag: member="RoutingTable6::addDefaultRoute" ref="a50f73e181d9c5e965ad72f74f0b43c40" args="(const IPv6Address &amp;raSrcAddr, unsigned int ifID, simtime_t routerLifetime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#a50f73e181d9c5e965ad72f74f0b43c40">RoutingTable6::addDefaultRoute</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>raSrcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ifID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&#160;</td>
          <td class="paramname"><em>routerLifetime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a default route for a host. </p>
<p>This method requires the RA's source address and the router expiry time plus the simTime(). </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a41da6658d387e46e3e656d4704bf908f">IPv6NeighbourDiscovery::processRAForRouterUpdates()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// create route object</span>
    <a class="code" href="class_i_pv6_route.html" title="Represents a route in the route table.">IPv6Route</a> *route = <span class="keyword">new</span> <a class="code" href="class_i_pv6_route.html" title="Represents a route in the route table.">IPv6Route</a>(<a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a>(), 0, <a class="code" href="class_i_pv6_route.html#a4eac9172e292e624476a22b74478e087a7e360222defd4f4a1af6d1e70442a5c8" title="on-link prefix, from Router Advertisement">IPv6Route::FROM_RA</a>);
    route-&gt;<a class="code" href="class_i_pv6_route.html#a7619951592a3ab6f32eb8b5c1beaf864">setInterfaceId</a>(ifID);
    route-&gt;<a class="code" href="class_i_pv6_route.html#aafb5f10807c0d3d563c3459d99faf109">setNextHop</a>(nextHop);
    route-&gt;<a class="code" href="class_i_pv6_route.html#a04c4ec94dbc0fa34799091a3fa7a0e8d">setMetric</a>(10); <span class="comment">//FIXME:should be filled from interface metric</span>

<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>    route-&gt;<a class="code" href="class_i_pv6_route.html#a946095196f3826b1c3a3390245dcda05">setExpiryTime</a>(routerLifetime); <span class="comment">// lifetime useful after transitioning to new AR // 27.07.08 - CB</span>
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

    <span class="comment">// then add it</span>
    <a class="code" href="class_routing_table6.html#ac5315cdff4b757915773f1c22f273ba4">addRoute</a>(route);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad942d6cb5b1376b132947f75924344f6"></a><!-- doxytag: member="RoutingTable6::addOrUpdateOnLinkPrefix" ref="ad942d6cb5b1376b132947f75924344f6" args="(const IPv6Address &amp;destPrefix, int prefixLength, int interfaceId, simtime_t expiryTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#ad942d6cb5b1376b132947f75924344f6">RoutingTable6::addOrUpdateOnLinkPrefix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>destPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prefixLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interfaceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&#160;</td>
          <td class="paramname"><em>expiryTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add on-link prefix (route of type FROM_RA), or update existing one. </p>
<p>To be called from code processing on-link prefixes in Router Advertisements. Expiry time can be derived from the Valid Lifetime field in the Router Advertisements.</p>
<p>NOTE: This method does NOT update the lifetime of matching addresses in the <a class="el" href="class_i_interface_table.html" title="A C++ interface to abstract the functionality of InterfaceTable.">IInterfaceTable</a> (see <a class="el" href="class_i_pv6_interface_data.html" title="IPv6-specific data for InterfaceEntry.">IPv6InterfaceData</a>); that has to be done separately. </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a5acf0814f6ca500c38d87763c0a5aef7">IPv6NeighbourDiscovery::processRAPrefixInfo()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// see if prefix exists in table</span>
    <a class="code" href="class_i_pv6_route.html" title="Represents a route in the route table.">IPv6Route</a> *route = <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
    <span class="keywordflow">for</span> (RouteList::iterator it=<a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.begin(); it!=<a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.end(); it++)
    {
        <span class="keywordflow">if</span> ((*it)-&gt;getSrc()==<a class="code" href="class_i_pv6_route.html#a4eac9172e292e624476a22b74478e087a7e360222defd4f4a1af6d1e70442a5c8" title="on-link prefix, from Router Advertisement">IPv6Route::FROM_RA</a> &amp;&amp; (*it)-&gt;getDestPrefix()==destPrefix &amp;&amp; (*it)-&gt;getPrefixLength()==prefixLength)
        {
            route = *it;
            <span class="keywordflow">break</span>;
        }
    }

    <span class="keywordflow">if</span> (route==<a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
    {
        <span class="comment">// create new route object</span>
        <a class="code" href="class_i_pv6_route.html" title="Represents a route in the route table.">IPv6Route</a> *route = <span class="keyword">new</span> <a class="code" href="class_i_pv6_route.html" title="Represents a route in the route table.">IPv6Route</a>(destPrefix, prefixLength, <a class="code" href="class_i_pv6_route.html#a4eac9172e292e624476a22b74478e087a7e360222defd4f4a1af6d1e70442a5c8" title="on-link prefix, from Router Advertisement">IPv6Route::FROM_RA</a>);
        route-&gt;<a class="code" href="class_i_pv6_route.html#a7619951592a3ab6f32eb8b5c1beaf864">setInterfaceId</a>(interfaceId);
        route-&gt;<a class="code" href="class_i_pv6_route.html#a946095196f3826b1c3a3390245dcda05">setExpiryTime</a>(expiryTime);
        route-&gt;<a class="code" href="class_i_pv6_route.html#a04c4ec94dbc0fa34799091a3fa7a0e8d">setMetric</a>(0);

        <span class="comment">// then add it</span>
        <a class="code" href="class_routing_table6.html#ac5315cdff4b757915773f1c22f273ba4">addRoute</a>(route);
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">// update existing one; notification-wise, we pretend the route got removed then re-added</span>
        <a class="code" href="structnb.html">nb</a>-&gt;fireChangeNotification(<a class="code" href="_notifier_consts_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a6c8f0e68e262e322d82609fae7425c5f">NF_IPv6_ROUTE_DELETED</a>, route);
        route-&gt;<a class="code" href="class_i_pv6_route.html#a7619951592a3ab6f32eb8b5c1beaf864">setInterfaceId</a>(interfaceId);
        route-&gt;<a class="code" href="class_i_pv6_route.html#a946095196f3826b1c3a3390245dcda05">setExpiryTime</a>(expiryTime);
        <a class="code" href="structnb.html">nb</a>-&gt;fireChangeNotification(<a class="code" href="_notifier_consts_8h.html#adf764cbdea00d65edcd07bb9953ad2b7aa58d74dc8cd5ab0b63267030da712cc1">NF_IPv6_ROUTE_ADDED</a>, route);
    }

    <a class="code" href="class_routing_table6.html#ac174c90714b3e6b245c5084850651af7">updateDisplayString</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="aad45eef791b41fe469357f1f4c6090bb"></a><!-- doxytag: member="RoutingTable6::addOrUpdateOwnAdvPrefix" ref="aad45eef791b41fe469357f1f4c6090bb" args="(const IPv6Address &amp;destPrefix, int prefixLength, int interfaceId, simtime_t expiryTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#aad45eef791b41fe469357f1f4c6090bb">RoutingTable6::addOrUpdateOwnAdvPrefix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>destPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prefixLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interfaceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&#160;</td>
          <td class="paramname"><em>expiryTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add route of type OWN_ADV_PREFIX. </p>
<p>This is a prefix that *this* router advertises on this interface. </p>

<p>Referenced by <a class="el" href="class_flat_network_configurator6.html#aa4e9be7807116b4b03193292cefa7368">FlatNetworkConfigurator6::addOwnAdvPrefixRoutes()</a>, and <a class="el" href="class_routing_table6.html#a3a930dca8cabc52375c754dfce15252d">initialize()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// FIXME this is very similar to the one above -- refactor!!</span>

    <span class="comment">// see if prefix exists in table</span>
    <a class="code" href="class_i_pv6_route.html" title="Represents a route in the route table.">IPv6Route</a> *route = <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
    <span class="keywordflow">for</span> (RouteList::iterator it=<a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.begin(); it!=<a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.end(); it++)
    {
        <span class="keywordflow">if</span> ((*it)-&gt;getSrc()==<a class="code" href="class_i_pv6_route.html#a4eac9172e292e624476a22b74478e087ad46ec93945a0a1b07a9097be97e56c1e" title="on routers: on-link prefix that the router **itself** advertises on the link">IPv6Route::OWN_ADV_PREFIX</a> &amp;&amp; (*it)-&gt;getDestPrefix()==destPrefix &amp;&amp; (*it)-&gt;getPrefixLength()==prefixLength)
        {
            route = *it;
            <span class="keywordflow">break</span>;
        }
    }

    <span class="keywordflow">if</span> (route==<a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
    {
        <span class="comment">// create new route object</span>
        <a class="code" href="class_i_pv6_route.html" title="Represents a route in the route table.">IPv6Route</a> *route = <span class="keyword">new</span> <a class="code" href="class_i_pv6_route.html" title="Represents a route in the route table.">IPv6Route</a>(destPrefix, prefixLength, <a class="code" href="class_i_pv6_route.html#a4eac9172e292e624476a22b74478e087ad46ec93945a0a1b07a9097be97e56c1e" title="on routers: on-link prefix that the router **itself** advertises on the link">IPv6Route::OWN_ADV_PREFIX</a>);
        route-&gt;<a class="code" href="class_i_pv6_route.html#a7619951592a3ab6f32eb8b5c1beaf864">setInterfaceId</a>(interfaceId);
        route-&gt;<a class="code" href="class_i_pv6_route.html#a946095196f3826b1c3a3390245dcda05">setExpiryTime</a>(expiryTime);
        route-&gt;<a class="code" href="class_i_pv6_route.html#a04c4ec94dbc0fa34799091a3fa7a0e8d">setMetric</a>(0);

        <span class="comment">// then add it</span>
        <a class="code" href="class_routing_table6.html#ac5315cdff4b757915773f1c22f273ba4">addRoute</a>(route);
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">// update existing one; notification-wise, we pretend the route got removed then re-added</span>
        <a class="code" href="structnb.html">nb</a>-&gt;fireChangeNotification(<a class="code" href="_notifier_consts_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a6c8f0e68e262e322d82609fae7425c5f">NF_IPv6_ROUTE_DELETED</a>, route);
        route-&gt;<a class="code" href="class_i_pv6_route.html#a7619951592a3ab6f32eb8b5c1beaf864">setInterfaceId</a>(interfaceId);
        route-&gt;<a class="code" href="class_i_pv6_route.html#a946095196f3826b1c3a3390245dcda05">setExpiryTime</a>(expiryTime);
        <a class="code" href="structnb.html">nb</a>-&gt;fireChangeNotification(<a class="code" href="_notifier_consts_8h.html#adf764cbdea00d65edcd07bb9953ad2b7aa58d74dc8cd5ab0b63267030da712cc1">NF_IPv6_ROUTE_ADDED</a>, route);
    }

    <a class="code" href="class_routing_table6.html#ac174c90714b3e6b245c5084850651af7">updateDisplayString</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac5315cdff4b757915773f1c22f273ba4"></a><!-- doxytag: member="RoutingTable6::addRoute" ref="ac5315cdff4b757915773f1c22f273ba4" args="(IPv6Route *route)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#ac5315cdff4b757915773f1c22f273ba4">RoutingTable6::addRoute</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_route.html">IPv6Route</a> *&#160;</td>
          <td class="paramname"><em>route</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_routing_table6.html#a50f73e181d9c5e965ad72f74f0b43c40">addDefaultRoute()</a>, <a class="el" href="class_routing_table6.html#ad942d6cb5b1376b132947f75924344f6">addOrUpdateOnLinkPrefix()</a>, <a class="el" href="class_routing_table6.html#aad45eef791b41fe469357f1f4c6090bb">addOrUpdateOwnAdvPrefix()</a>, <a class="el" href="class_routing_table6.html#af11c468a66aa9edc3b16cc7b6b01d5bb">addRoutingProtocolRoute()</a>, and <a class="el" href="class_routing_table6.html#adf9413825a24ef26051d8a78539dec29">addStaticRoute()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.push_back(route);

    <span class="comment">// we keep entries sorted by prefix length in routeList, so that we can</span>
    <span class="comment">// stop at the first match when doing the longest prefix matching</span>
    std::sort(<a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.begin(), <a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.end(), <a class="code" href="class_routing_table6.html#a707cec2ac6652e7eb0ff97b53f70d9b9">routeLessThan</a>);

    <a class="code" href="class_routing_table6.html#ac174c90714b3e6b245c5084850651af7">updateDisplayString</a>();

    <a class="code" href="structnb.html">nb</a>-&gt;fireChangeNotification(<a class="code" href="_notifier_consts_8h.html#adf764cbdea00d65edcd07bb9953ad2b7aa58d74dc8cd5ab0b63267030da712cc1">NF_IPv6_ROUTE_ADDED</a>, route);
}
</pre></div>
</div>
</div>
<a class="anchor" id="af11c468a66aa9edc3b16cc7b6b01d5bb"></a><!-- doxytag: member="RoutingTable6::addRoutingProtocolRoute" ref="af11c468a66aa9edc3b16cc7b6b01d5bb" args="(IPv6Route *route)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#af11c468a66aa9edc3b16cc7b6b01d5bb">RoutingTable6::addRoutingProtocolRoute</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_route.html">IPv6Route</a> *&#160;</td>
          <td class="paramname"><em>route</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the given getRoute(which can be OSPF, BGP, RIP or any other route) with src==ROUTING_PROT. </p>
<p>To store additional information with the route, one can subclass from <a class="el" href="class_i_pv6_route.html" title="Represents a route in the route table.">IPv6Route</a> and add more fields. </p>
<div class="fragment"><pre class="fragment">{
    ASSERT(route-&gt;<a class="code" href="class_i_pv6_route.html#ac5098952cb1e2a9f2cf12bd0b8b0887d">getSrc</a>()==<a class="code" href="class_i_pv6_route.html#a4eac9172e292e624476a22b74478e087aa0040039d1490c0b7bdd8602269a894b" title="route is managed by a routing protocol (OSPF,BGP,etc)">IPv6Route::ROUTING_PROT</a>);
    <a class="code" href="class_routing_table6.html#ac5315cdff4b757915773f1c22f273ba4">addRoute</a>(route);
}
</pre></div>
</div>
</div>
<a class="anchor" id="adf9413825a24ef26051d8a78539dec29"></a><!-- doxytag: member="RoutingTable6::addStaticRoute" ref="adf9413825a24ef26051d8a78539dec29" args="(const IPv6Address &amp;destPrefix, int prefixLength, unsigned int interfaceId, const IPv6Address &amp;nextHop, int metric=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#adf9413825a24ef26051d8a78539dec29">RoutingTable6::addStaticRoute</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>destPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prefixLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>interfaceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>nextHop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>metric</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a static route. </p>
<p>If metric is omitted, it gets initialized to the interface's metric value. </p>

<p>Referenced by <a class="el" href="class_flat_network_configurator6.html#a684fdefcfe46d118e158423c3f77fe22">FlatNetworkConfigurator6::addStaticRoutes()</a>, and <a class="el" href="class_routing_table6.html#ab78638e39019d6ca1690d926da5f04fe">configureInterfaceForIPv6()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// create route object</span>
    <a class="code" href="class_i_pv6_route.html" title="Represents a route in the route table.">IPv6Route</a> *route = <span class="keyword">new</span> <a class="code" href="class_i_pv6_route.html" title="Represents a route in the route table.">IPv6Route</a>(destPrefix, prefixLength, <a class="code" href="class_i_pv6_route.html#a4eac9172e292e624476a22b74478e087a97c5ec5cf895578cbd6247a8bba80638" title="static route">IPv6Route::STATIC</a>);
    route-&gt;<a class="code" href="class_i_pv6_route.html#a7619951592a3ab6f32eb8b5c1beaf864">setInterfaceId</a>(interfaceId);
    route-&gt;<a class="code" href="class_i_pv6_route.html#aafb5f10807c0d3d563c3459d99faf109">setNextHop</a>(nextHop);
    <span class="keywordflow">if</span> (metric==0)
        metric = 10; <span class="comment">// TBD should be filled from interface metric</span>
    route-&gt;<a class="code" href="class_i_pv6_route.html#a04c4ec94dbc0fa34799091a3fa7a0e8d">setMetric</a>(metric);

    <span class="comment">// then add it</span>
    <a class="code" href="class_routing_table6.html#ac5315cdff4b757915773f1c22f273ba4">addRoute</a>(route);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a84a7121fd02397bfd4ea169675381e3e"></a><!-- doxytag: member="RoutingTable6::assignRequiredNodeAddresses" ref="a84a7121fd02397bfd4ea169675381e3e" args="(InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#a84a7121fd02397bfd4ea169675381e3e">RoutingTable6::assignRequiredNodeAddresses</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>RFC 3513: Section 2.8 A Node's Required Address Assign the various addresses to the node's respective interface. </p>
<p>This should be done when the <a class="el" href="class_i_pv6.html" title="IPv6 implementation.">IPv6</a> Protocol stack is created. </p>

<p>Referenced by <a class="el" href="class_routing_table6.html#ab78638e39019d6ca1690d926da5f04fe">configureInterfaceForIPv6()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//RFC 3513 Section 2.8:A Node&#39;s Required Addresses</span>
    <span class="comment">/*A host is required to recognize the following addresses as</span>
<span class="comment">    identifying itself:*/</span>

    <span class="comment">//o  The loopback address.</span>
    <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a0ee93e88273f61390d1293dae55004d1">isLoopback</a>())
    {
        ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a715b339dc41612149940ed0607af1535" title="Assigns the given address to the interface.">assignAddress</a>(<a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a>(<span class="stringliteral">&quot;::1&quot;</span>), <span class="keyword">false</span>, 0, 0);
        <span class="keywordflow">return</span>;
    }
    <span class="comment">//o  Its required Link-Local Address for each interface.</span>

<span class="preprocessor">#ifndef WITH_xMIPv6</span>
<span class="preprocessor"></span>    <span class="comment">//IPv6Address linkLocalAddr = IPv6Address().formLinkLocalAddress(ie-&gt;getInterfaceToken());</span>
    <span class="comment">//ie-&gt;ipv6Data()-&gt;assignAddress(linkLocalAddr, true, 0, 0);</span>
<span class="preprocessor">#else </span><span class="comment">/* WITH_xMIPv6 */</span>
    <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> linkLocalAddr = <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a>().<a class="code" href="class_i_pv6_address.html#aa8a3ef9e930a6703ea9cbde5a3ecaaca" title="Forms a link-local address using the given interface identifier.">formLinkLocalAddress</a>(ie-&gt;<a class="code" href="class_interface_entry.html#a1196c8e3f1a10a26778296af4c14a4bb">getInterfaceToken</a>());
    ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a715b339dc41612149940ed0607af1535" title="Assigns the given address to the interface.">assignAddress</a>(linkLocalAddr, <span class="keyword">true</span>, 0, 0);
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

    <span class="comment">/*o  Any additional Unicast and Anycast Addresses that have been configured</span>
<span class="comment">    for the node&#39;s interfaces (manually or automatically).*/</span>

    <span class="comment">// FIXME FIXME Andras: commented out the following lines, because these addresses</span>
    <span class="comment">// are implicitly checked for in isLocalAddress()  (we don&#39;t want redundancy,</span>
    <span class="comment">// and manually adding solicited-node mcast address for each and every address</span>
    <span class="comment">// is very error-prone!)</span>
    <span class="comment">//</span>
    <span class="comment">//o  The All-Nodes Multicast Addresses defined in section 2.7.1.</span>

    <span class="comment">/*o  The Solicited-Node Multicast Address for each of its unicast and anycast</span>
<span class="comment">    addresses.*/</span>

    <span class="comment">//o  Multicast Addresses of all other groups to which the node belongs.</span>

    <span class="comment">/*A router is required to recognize all addresses that a host is</span>
<span class="comment">    required to recognize, plus the following addresses as identifying</span>
<span class="comment">    itself:*/</span>
    <span class="comment">/*o  The Subnet-Router Anycast Addresses for all interfaces for</span>
<span class="comment">    which it is configured to act as a router.*/</span>

    <span class="comment">//o  All other Anycast Addresses with which the router has been configured.</span>
    <span class="comment">//o  The All-Routers Multicast Addresses defined in section 2.7.1.</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab78638e39019d6ca1690d926da5f04fe"></a><!-- doxytag: member="RoutingTable6::configureInterfaceForIPv6" ref="ab78638e39019d6ca1690d926da5f04fe" args="(InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#ab78638e39019d6ca1690d926da5f04fe">RoutingTable6::configureInterfaceForIPv6</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_routing_table6.html#a3a930dca8cabc52375c754dfce15252d">initialize()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_i_pv6_interface_data.html" title="IPv6-specific data for InterfaceEntry.">IPv6InterfaceData</a> *ipv6IfData = <span class="keyword">new</span> <a class="code" href="class_i_pv6_interface_data.html" title="IPv6-specific data for InterfaceEntry.">IPv6InterfaceData</a>();
    ie-&gt;<a class="code" href="class_interface_entry.html#a1a2550df394a766847d0ad89aa1a9349">setIPv6Data</a>(ipv6IfData);

    <span class="comment">// for routers, turn on advertisements by default</span>
    <span class="comment">//FIXME: we will use this isRouter flag for now. what if future implementations</span>
    <span class="comment">//have 2 interfaces where one interface is configured as a router and the other</span>
    <span class="comment">//as a host?</span>
    ipv6IfData-&gt;<a class="code" href="class_i_pv6_interface_data.html#a18958f1a76719473e9e2a0099032075f">setAdvSendAdvertisements</a>(<a class="code" href="class_routing_table6.html#a0cebbe3d99a2059179fbb17dc833476d">isrouter</a>); <span class="comment">//Added by WEI</span>

    <span class="comment">// metric: some hints: OSPF cost (2e9/bps value), MS KB article Q299540, ...</span>
    <span class="comment">//d-&gt;setMetric((int)ceil(2e9/ie-&gt;getDatarate())); // use OSPF cost as default</span>
    <span class="comment">//FIXME TBD fill in the rest</span>

    <a class="code" href="class_routing_table6.html#a84a7121fd02397bfd4ea169675381e3e" title="RFC 3513: Section 2.8 A Node&#39;s Required Address Assign the various addresses to the node&#39;s respective...">assignRequiredNodeAddresses</a>(ie);

    <span class="comment">// add link-local prefix to each interface according to RFC 4861 5.1</span>
    <span class="keywordflow">if</span> (!ie-&gt;<a class="code" href="class_interface_entry.html#a0ee93e88273f61390d1293dae55004d1">isLoopback</a>())
        <a class="code" href="class_routing_table6.html#adf9413825a24ef26051d8a78539dec29" title="Creates a static route.">addStaticRoute</a>(<a class="code" href="class_i_pv6_address.html#ac34c13834df9731ffbdc909f98228df7" title="The link-local prefix (fe80::)">IPv6Address::LINKLOCAL_PREFIX</a>, 10, ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>(), <a class="code" href="class_i_pv6_address.html#a0c1e137cb3b1470ec6b8d9a95e03dbe5" title="The unspecified address.">IPv6Address::UNSPECIFIED_ADDRESS</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5d4f86dbabc31663a4bd12f50a72140f"></a><!-- doxytag: member="RoutingTable6::configureInterfaceFromXML" ref="a5d4f86dbabc31663a4bd12f50a72140f" args="(InterfaceEntry *ie, cXMLElement *cfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#a5d4f86dbabc31663a4bd12f50a72140f">RoutingTable6::configureInterfaceFromXML</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>ie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cXMLElement *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_routing_table6.html#a3dc6e638b861a416cd1a44f8dbde473a">parseXMLConfigFile()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">/*XML parsing capabilities tweaked by WEI. For now, we can configure a specific</span>
<span class="comment">    node&#39;s interface. We can set advertising prefixes and other variables to be used</span>
<span class="comment">    in RAs. The IPv6 interface data gets overwritten if lines 249 to 262 is uncommented.</span>
<span class="comment">    The fix is to create an XML file with all the default values. Customised XML files</span>
<span class="comment">    can be used for future protocols that requires different values. (MIPv6)*/</span>
    <a class="code" href="class_i_pv6_interface_data.html" title="IPv6-specific data for InterfaceEntry.">IPv6InterfaceData</a> *d = ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>();

    <span class="comment">// parse basic config (attributes)</span>
    d-&gt;<a class="code" href="class_i_pv6_interface_data.html#a18958f1a76719473e9e2a0099032075f">setAdvSendAdvertisements</a>(toBool(getRequiredAttr(cfg, <span class="stringliteral">&quot;AdvSendAdvertisements&quot;</span>)));
    <span class="comment">//TODO: leave this off first!! They overwrite stuff!</span>

    <span class="comment">/* TODO: Wei commented out the stuff below. To be checked why (Andras).</span>
<span class="comment">    d-&gt;setMaxRtrAdvInterval(OPP_Global::atod(getRequiredAttr(cfg, &quot;MaxRtrAdvInterval&quot;)));</span>
<span class="comment">    d-&gt;setMinRtrAdvInterval(OPP_Global::atod(getRequiredAttr(cfg, &quot;MinRtrAdvInterval&quot;)));</span>
<span class="comment">    d-&gt;setAdvManagedFlag(toBool(getRequiredAttr(cfg, &quot;AdvManagedFlag&quot;)));</span>
<span class="comment">    d-&gt;setAdvOtherConfigFlag(toBool(getRequiredAttr(cfg, &quot;AdvOtherConfigFlag&quot;)));</span>
<span class="comment">    d-&gt;setAdvLinkMTU(OPP_Global::atoul(getRequiredAttr(cfg, &quot;AdvLinkMTU&quot;)));</span>
<span class="comment">    d-&gt;setAdvReachableTime(OPP_Global::atoul(getRequiredAttr(cfg, &quot;AdvReachableTime&quot;)));</span>
<span class="comment">    d-&gt;setAdvRetransTimer(OPP_Global::atoul(getRequiredAttr(cfg, &quot;AdvRetransTimer&quot;)));</span>
<span class="comment">    d-&gt;setAdvCurHopLimit(OPP_Global::atoul(getRequiredAttr(cfg, &quot;AdvCurHopLimit&quot;)));</span>
<span class="comment">    d-&gt;setAdvDefaultLifetime(OPP_Global::atoul(getRequiredAttr(cfg, &quot;AdvDefaultLifetime&quot;)));</span>
<span class="comment">    ie-&gt;setMtu(OPP_Global::atoul(getRequiredAttr(cfg, &quot;HostLinkMTU&quot;)));</span>
<span class="comment">    d-&gt;setCurHopLimit(OPP_Global::atoul(getRequiredAttr(cfg, &quot;HostCurHopLimit&quot;)));</span>
<span class="comment">    d-&gt;setBaseReachableTime(OPP_Global::atoul(getRequiredAttr(cfg, &quot;HostBaseReachableTime&quot;)));</span>
<span class="comment">    d-&gt;setRetransTimer(OPP_Global::atoul(getRequiredAttr(cfg, &quot;HostRetransTimer&quot;)));</span>
<span class="comment">    d-&gt;setDupAddrDetectTransmits(OPP_Global::atoul(getRequiredAttr(cfg, &quot;HostDupAddrDetectTransmits&quot;)));</span>
<span class="comment">    */</span>

    <span class="comment">// parse prefixes (AdvPrefix elements; they should be inside an AdvPrefixList</span>
    <span class="comment">// element, but we don&#39;t check that)</span>
    cXMLElementList prefixList = cfg-&gt;getElementsByTagName(<span class="stringliteral">&quot;AdvPrefix&quot;</span>);
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;prefixList.size(); i++)
    {
        cXMLElement *node = prefixList[i];
        <a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html" title="For routers: advertised prefix configuration.">IPv6InterfaceData::AdvPrefix</a> prefix;

        <span class="comment">// FIXME todo implement: advValidLifetime, advPreferredLifetime can</span>
        <span class="comment">// store (absolute) expiry time (if &gt;0) or lifetime (delta) (if &lt;0);</span>
        <span class="comment">// 0 should be treated as infinity</span>
        <span class="keywordtype">int</span> pfxLen;
        <span class="keywordflow">if</span> (!prefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a8dbd979f7860762721b55d4793629258">prefix</a>.<a class="code" href="class_i_pv6_address.html#a55ffa37e2140d970b86e62d03b973ea2" title="Expects a string in the &quot;&lt;address&gt;/&lt;prefixlength&gt;&quot; syntax, parses the address into the object (see tr...">tryParseAddrWithPrefix</a>(node-&gt;getNodeValue(), pfxLen))
            <span class="keywordflow">throw</span> cRuntimeError(<span class="stringliteral">&quot;Element &lt;%s&gt; at %s: wrong IPv6Address/prefix syntax %s&quot;</span>,
                      node-&gt;getTagName(), node-&gt;getSourceLocation(), node-&gt;getNodeValue());

        prefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a8e68016dcc5cb215199e7f61402f854b">prefixLength</a> = pfxLen;
        prefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a8a0703cb25c21fb9db5e7a4408e40680">advValidLifetime</a> = <a class="code" href="namespace_o_p_p___global.html#a7a945483736b99900d3da3c648c33f5e" title="Converts string to unsigned long.">OPP_Global::atoul</a>(getRequiredAttr(node, <span class="stringliteral">&quot;AdvValidLifetime&quot;</span>));
        prefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a9c2fa49f3db59393e76c08e022c4e12c">advOnLinkFlag</a> = toBool(getRequiredAttr(node, <span class="stringliteral">&quot;AdvOnLinkFlag&quot;</span>));
        prefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a0df07072856386db3465443deffacd6f">advPreferredLifetime</a> = <a class="code" href="namespace_o_p_p___global.html#a7a945483736b99900d3da3c648c33f5e" title="Converts string to unsigned long.">OPP_Global::atoul</a>(getRequiredAttr(node, <span class="stringliteral">&quot;AdvPreferredLifetime&quot;</span>));
        prefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#ac593127a85f0ced6a4f8d9c0aee2184d">advAutonomousFlag</a> = toBool(getRequiredAttr(node, <span class="stringliteral">&quot;AdvAutonomousFlag&quot;</span>));
        d-&gt;<a class="code" href="class_i_pv6_interface_data.html#ac746c3ceb962985e4b6fb17364294e46" title="Adds the given advertised prefix to the interface.">addAdvPrefix</a>(prefix);
    }

    <span class="comment">// parse addresses</span>
    cXMLElementList addrList = cfg-&gt;getChildrenByTagName(<span class="stringliteral">&quot;inetAddr&quot;</span>);
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;addrList.size(); k++)
    {
        cXMLElement *node = addrList[k];
        <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> address = <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a>(node-&gt;getNodeValue());
        <span class="comment">//We can now decide if the address is tentative or not.</span>
        d-&gt;<a class="code" href="class_i_pv6_interface_data.html#a715b339dc41612149940ed0607af1535" title="Assigns the given address to the interface.">assignAddress</a>(address, toBool(getRequiredAttr(node, <span class="stringliteral">&quot;tentative&quot;</span>)), 0, 0);  <span class="comment">// set up with infinite lifetimes</span>
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0a0c804ccf3360f7476aa1e21b66e79e"></a><!-- doxytag: member="RoutingTable6::configureTunnelFromXML" ref="a0a0c804ccf3360f7476aa1e21b66e79e" args="(cXMLElement *cfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#a0a0c804ccf3360f7476aa1e21b66e79e">RoutingTable6::configureTunnelFromXML</a> </td>
          <td>(</td>
          <td class="paramtype">cXMLElement *&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_routing_table6.html#a3dc6e638b861a416cd1a44f8dbde473a">parseXMLConfigFile()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_i_pv6_tunneling.html" title="Management of IP tunnels.">IPv6Tunneling</a>* tunneling = <a class="code" href="class_i_pv6_tunneling_access.html" title="Gives access to IPv6Tunneling.">IPv6TunnelingAccess</a>().<a class="code" href="class_module_access.html#a46a82b1fa0e957eb42d29c8637df1f4f">get</a>();

    <span class="comment">// parse basic config (attributes)</span>
    cXMLElementList tunnelList = cfg-&gt;getElementsByTagName(<span class="stringliteral">&quot;tunnelEntry&quot;</span>);
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;tunnelList.size(); i++)
    {
        cXMLElement *node = tunnelList[i];

        <a class="code" href="class_i_pv6_address.html" title="Stores a 128-bit IPv6 address in an efficient way.">IPv6Address</a> entry, exit, trigger;
        entry.<a class="code" href="class_i_pv6_address.html#a5560a79b66ee963af78b0a1dde71ce99" title="Sets the IPv6 address.">set</a>( getRequiredAttr(node, <span class="stringliteral">&quot;entryPoint&quot;</span>) );
        exit.<a class="code" href="class_i_pv6_address.html#a5560a79b66ee963af78b0a1dde71ce99" title="Sets the IPv6 address.">set</a>( getRequiredAttr(node, <span class="stringliteral">&quot;exitPoint&quot;</span>) );

        cXMLElementList triggerList = node-&gt;getElementsByTagName(<span class="stringliteral">&quot;triggers&quot;</span>);

        <span class="keywordflow">if</span> (triggerList.size() != 1)
            opp_error(<span class="stringliteral">&quot;element &lt;%s&gt; at %s: Only exactly one trigger allowed&quot;</span>,
                    node-&gt;getTagName(), node-&gt;getSourceLocation());

        cXMLElement *triggerNode = triggerList[0];
        trigger.<a class="code" href="class_i_pv6_address.html#a5560a79b66ee963af78b0a1dde71ce99" title="Sets the IPv6 address.">set</a>( getRequiredAttr(triggerNode, <span class="stringliteral">&quot;destination&quot;</span>) );

        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;New tunnel: &quot;</span> &lt;&lt; <span class="stringliteral">&quot;entry=&quot;</span> &lt;&lt; entry &lt;&lt; <span class="stringliteral">&quot;,exit=&quot;</span> &lt;&lt; exit &lt;&lt; <span class="stringliteral">&quot;,trigger=&quot;</span> &lt;&lt; trigger &lt;&lt; endl;
        tunneling-&gt;<a class="code" href="class_i_pv6_tunneling.html#a766b601e89d6251771b8405bce8a334e" title="Creates a tunnel with given entry and exit point, which will be used for datagrams destined for destT...">createTunnel</a>(<a class="code" href="class_i_pv6_tunneling.html#a8167e5cdd0dbcd4c1756f6f01fb690d8a03e6e804de16cce32bc10c6df72dfa86">IPv6Tunneling::NORMAL</a>, entry, exit, trigger);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa3ba1d17dc59f3e5d77ead359dd3a999"></a><!-- doxytag: member="RoutingTable6::doLongestPrefixMatch" ref="aa3ba1d17dc59f3e5d77ead359dd3a999" args="(const IPv6Address &amp;dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_i_pv6_route.html">IPv6Route</a> * <a class="el" href="class_routing_table6.html#aa3ba1d17dc59f3e5d77ead359dd3a999">RoutingTable6::doLongestPrefixMatch</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs longest prefix match in the routing table and returns the resulting route, or NULL if there was no match. </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a4bddad274cd8eb1472d37ddcd559c629">IPv6NeighbourDiscovery::determineNextHop()</a>, and <a class="el" href="class_i_pv6.html#a641e893f2ada9c52fd0d694fa0947503">IPv6::determineOutputInterface()</a>.</p>
<div class="fragment"><pre class="fragment">{
    Enter_Method(<span class="stringliteral">&quot;doLongestPrefixMatch(%s)&quot;</span>, dest.<a class="code" href="class_i_pv6_address.html#a7c42fb066db81588a439aed1de5e4b3a" title="Returns the textual representation of the address in the standard notation.">str</a>().c_str());

    <span class="comment">// we&#39;ll just stop at the first match, because the table is sorted</span>
    <span class="comment">// by prefix lengths and metric (see addRoute())</span>

    <span class="comment">// bugfix - CB</span>
    RouteList::iterator it = <a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.begin();
    <span class="keywordflow">while</span> (it!=<a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.end())
    {
        <span class="keywordflow">if</span> (dest.<a class="code" href="class_i_pv6_address.html#a4d9102b52fcf98d1945c75a098bc678a" title="Returns true if the address matches the given prefix.">matches</a>((*it)-&gt;getDestPrefix(), (*it)-&gt;getPrefixLength()))
        {
            <span class="keywordflow">if</span> (simTime() &gt; (*it)-&gt;getExpiryTime() &amp;&amp; (*it)-&gt;getExpiryTime() != 0)<span class="comment">//since 0 represents infinity.</span>
            {
                <span class="keywordflow">if</span> ( (*it)-&gt;getSrc()==<a class="code" href="class_i_pv6_route.html#a4eac9172e292e624476a22b74478e087a7e360222defd4f4a1af6d1e70442a5c8" title="on-link prefix, from Router Advertisement">IPv6Route::FROM_RA</a> )
                {
                    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Expired prefix detected!!&quot;</span> &lt;&lt; endl;
                    it = <a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.erase(it);
                    <span class="comment">//RouteList::iterator oldIt = it++;</span>
                    <span class="comment">//removeOnLinkPrefix((*oldIt)-&gt;getDestPrefix(), (*oldIt)-&gt;getPrefixLength());</span>
                }
            }
            <span class="keywordflow">else</span>
                <span class="keywordflow">return</span> *it;
        }
        <span class="keywordflow">else</span>
            ++it;
    }
    <span class="comment">// FIXME todo: if we selected an expired route, throw it out and select again!</span>
    <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a24cede6c1b7ed7a17fad2525a4702851"></a><!-- doxytag: member="RoutingTable6::getInterfaceByAddress" ref="a24cede6c1b7ed7a17fad2525a4702851" args="(const IPv6Address &amp;address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> * <a class="el" href="class_routing_table6.html#a24cede6c1b7ed7a17fad2525a4702851">RoutingTable6::getInterfaceByAddress</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an interface given by its address. </p>
<p>Returns NULL if not found. </p>

<p>Referenced by <a class="el" href="class_i_pv6.html#a77a162c6ccb060cd4b690988725c381b">IPv6::encapsulate()</a>.</p>
<div class="fragment"><pre class="fragment">{
    Enter_Method(<span class="stringliteral">&quot;getInterfaceByAddress(%s)=?&quot;</span>, addr.str().c_str());

    <span class="keywordflow">if</span> (addr.isUnspecified())
        <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="class_routing_table6.html#aaaec39a83ad4a660b4cea65d1266b0e4">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a2b0ce46cd92da6f64fc363410dc71904" title="Returns the number of interfaces.">getNumInterfaces</a>(); ++i)
    {
        <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_routing_table6.html#aaaec39a83ad4a660b4cea65d1266b0e4">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a19ce4ca3b47b52b8e2b67c25806c4b49" title="Returns the InterfaceEntry specified by an index 0..numInterfaces-1.">getInterface</a>(i);
        <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#af4856e5c4da3563e03fbc388db63ba8a" title="Returns true if the given address is one of the addresses assigned, regardless whether it is tentativ...">hasAddress</a>(addr))
            <span class="keywordflow">return</span> ie;
    }
    <span class="keywordflow">return</span> <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a384a101ad5895b4cdbc796ec0fb427e3"></a><!-- doxytag: member="RoutingTable6::getNumRoutes" ref="a384a101ad5895b4cdbc796ec0fb427e3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_routing_table6.html#a384a101ad5895b4cdbc796ec0fb427e3">RoutingTable6::getNumRoutes</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of routes. </p>

<p>Referenced by <a class="el" href="class_routing_table6.html#ac174c90714b3e6b245c5084850651af7">updateDisplayString()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.size();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a037e2206e766dff2c8cc904694feba88"></a><!-- doxytag: member="RoutingTable6::getRoute" ref="a037e2206e766dff2c8cc904694feba88" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_route.html">IPv6Route</a> * <a class="el" href="class_routing_table6.html#a037e2206e766dff2c8cc904694feba88">RoutingTable6::getRoute</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the ith route. </p>
<div class="fragment"><pre class="fragment">{
    ASSERT(i&gt;=0 &amp;&amp; i&lt;(<span class="keywordtype">int</span>)<a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.size());
    <span class="keywordflow">return</span> <a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>[i];
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3aa22d18d79d749697aba97c01e21076"></a><!-- doxytag: member="RoutingTable6::handleMessage" ref="a3aa22d18d79d749697aba97c01e21076" args="(cMessage *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#a3aa22d18d79d749697aba97c01e21076">RoutingTable6::handleMessage</a> </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Raises an error. </p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">throw</span> cRuntimeError(<span class="stringliteral">&quot;This module doesn&#39;t process messages&quot;</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3a930dca8cabc52375c754dfce15252d"></a><!-- doxytag: member="RoutingTable6::initialize" ref="a3a930dca8cabc52375c754dfce15252d" args="(int stage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#a3a930dca8cabc52375c754dfce15252d">RoutingTable6::initialize</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (stage==1)
    {
        <a class="code" href="class_routing_table6.html#aaaec39a83ad4a660b4cea65d1266b0e4">ift</a> = <a class="code" href="class_interface_table_access.html" title="Gives access to IInterfaceTable.">InterfaceTableAccess</a>().<a class="code" href="class_module_access.html#a46a82b1fa0e957eb42d29c8637df1f4f">get</a>();
        <a class="code" href="structnb.html">nb</a> = <a class="code" href="class_notification_board_access.html" title="Gives access to the NotificationBoard instance within the host/router.">NotificationBoardAccess</a>().<a class="code" href="class_module_access.html#a46a82b1fa0e957eb42d29c8637df1f4f">get</a>();

        <a class="code" href="structnb.html">nb</a>-&gt;subscribe(<span class="keyword">this</span>, <a class="code" href="_notifier_consts_8h.html#adf764cbdea00d65edcd07bb9953ad2b7aea2d4297f1e519520524d4bd8ff865b4">NF_INTERFACE_CREATED</a>);
        <a class="code" href="structnb.html">nb</a>-&gt;subscribe(<span class="keyword">this</span>, <a class="code" href="_notifier_consts_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a4f8e57f4754cbf2e6ba92a7079b483e4">NF_INTERFACE_DELETED</a>);
        <a class="code" href="structnb.html">nb</a>-&gt;subscribe(<span class="keyword">this</span>, <a class="code" href="_notifier_consts_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a5ed0701efe7413c8f98fd0ba7fa9947d">NF_INTERFACE_STATE_CHANGED</a>);
        <a class="code" href="structnb.html">nb</a>-&gt;subscribe(<span class="keyword">this</span>, <a class="code" href="_notifier_consts_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a3a1d2cac1cec476f84c60030a70ef902">NF_INTERFACE_CONFIG_CHANGED</a>);
        <a class="code" href="structnb.html">nb</a>-&gt;subscribe(<span class="keyword">this</span>, <a class="code" href="_notifier_consts_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a7ce81127c07e25b007f9ec96f3643d52">NF_INTERFACE_IPv6CONFIG_CHANGED</a>);

        WATCH_PTRVECTOR(<a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>);
        WATCH_MAP(<a class="code" href="class_routing_table6.html#a40eeef91dde2b4b37c53fdc2d88a6b7d">destCache</a>); <span class="comment">// FIXME commented out for now</span>
        <a class="code" href="class_routing_table6.html#a0cebbe3d99a2059179fbb17dc833476d">isrouter</a> = par(<span class="stringliteral">&quot;isRouter&quot;</span>);
        WATCH(<a class="code" href="class_routing_table6.html#a0cebbe3d99a2059179fbb17dc833476d">isrouter</a>);

<span class="preprocessor">#ifdef WITH_xMIPv6</span>
<span class="preprocessor"></span>        <span class="comment">// the following MIPv6 related flags will be overridden by the MIPv6 module (if existing)</span>
        ishome_agent = <span class="keyword">false</span>;
        WATCH(ishome_agent);

        ismobile_node = <span class="keyword">false</span>;
        WATCH(ismobile_node);

        mipv6Support = <span class="keyword">false</span>; <span class="comment">// 4.9.07 - CB</span>
<span class="preprocessor">#endif </span><span class="comment">/* WITH_xMIPv6 */</span>

        <span class="comment">// add IPv6InterfaceData to interfaces</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="class_routing_table6.html#aaaec39a83ad4a660b4cea65d1266b0e4">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a2b0ce46cd92da6f64fc363410dc71904" title="Returns the number of interfaces.">getNumInterfaces</a>(); i++)
        {
            <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_routing_table6.html#aaaec39a83ad4a660b4cea65d1266b0e4">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a19ce4ca3b47b52b8e2b67c25806c4b49" title="Returns the InterfaceEntry specified by an index 0..numInterfaces-1.">getInterface</a>(i);
            <a class="code" href="class_routing_table6.html#ab78638e39019d6ca1690d926da5f04fe">configureInterfaceForIPv6</a>(ie);
        }

        <a class="code" href="class_routing_table6.html#a3dc6e638b861a416cd1a44f8dbde473a">parseXMLConfigFile</a>();

        <span class="comment">// skip hosts</span>
        <span class="keywordflow">if</span> (<a class="code" href="class_routing_table6.html#a0cebbe3d99a2059179fbb17dc833476d">isrouter</a>)
        {
            <span class="comment">// add globally routable prefixes to routing table</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; <a class="code" href="class_routing_table6.html#aaaec39a83ad4a660b4cea65d1266b0e4">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a2b0ce46cd92da6f64fc363410dc71904" title="Returns the number of interfaces.">getNumInterfaces</a>(); x++)
            {
                <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_routing_table6.html#aaaec39a83ad4a660b4cea65d1266b0e4">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a19ce4ca3b47b52b8e2b67c25806c4b49" title="Returns the InterfaceEntry specified by an index 0..numInterfaces-1.">getInterface</a>(x);

                <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a0ee93e88273f61390d1293dae55004d1">isLoopback</a>())
                    <span class="keywordflow">continue</span>;

                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a1d84187cfbe9e91f7af79927c813f61c" title="Returns the number of advertised prefixes on the interface.">getNumAdvPrefixes</a>(); y++)
                    <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a90da8f012bd443c75e6e742bcf6f7d38" title="Returns the ith advertised prefix on the interface.">getAdvPrefix</a>(y).<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a8dbd979f7860762721b55d4793629258">prefix</a>.<a class="code" href="class_i_pv6_address.html#aa2c2499a9e2ca1fd41b615d38654d8aa" title="Utility function based on getScope()">isGlobal</a>())
                        <a class="code" href="class_routing_table6.html#aad45eef791b41fe469357f1f4c6090bb" title="Add route of type OWN_ADV_PREFIX.">addOrUpdateOwnAdvPrefix</a>(ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a90da8f012bd443c75e6e742bcf6f7d38" title="Returns the ith advertised prefix on the interface.">getAdvPrefix</a>(y).<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a8dbd979f7860762721b55d4793629258">prefix</a>,
                                                ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a90da8f012bd443c75e6e742bcf6f7d38" title="Returns the ith advertised prefix on the interface.">getAdvPrefix</a>(y).<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a8e68016dcc5cb215199e7f61402f854b">prefixLength</a>,
                                                ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>(), 0);
            }
        }
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (stage==4)
    {
        <span class="comment">// configurator adds routes only in stage==3</span>
        <a class="code" href="class_routing_table6.html#ac174c90714b3e6b245c5084850651af7">updateDisplayString</a>();
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="acbf9dbfff5efa25eec0982afa1bbf061"></a><!-- doxytag: member="RoutingTable6::isLocalAddress" ref="acbf9dbfff5efa25eec0982afa1bbf061" args="(const IPv6Address &amp;dest) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_routing_table6.html#acbf9dbfff5efa25eec0982afa1bbf061">RoutingTable6::isLocalAddress</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if the address is one of the host's addresses, i.e. </p>
<p>assigned to one of its interfaces (tentatively or not). </p>

<p>Referenced by <a class="el" href="class_i_pv6_tunneling.html#a766b601e89d6251771b8405bce8a334e">IPv6Tunneling::createTunnel()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a1d21eff02fed770d1bf56dbb995c3db9">IPv6NeighbourDiscovery::processNSForTentativeAddress()</a>, <a class="el" href="class_i_pv6.html#a61eb7d75c2414e64fbcf82c69f9db7bf">IPv6::routeMulticastPacket()</a>, and <a class="el" href="class_i_pv6.html#a33a99910431c17c57350ee894d9024e3">IPv6::routePacket()</a>.</p>
<div class="fragment"><pre class="fragment">{
    Enter_Method(<span class="stringliteral">&quot;isLocalAddress(%s) y/n&quot;</span>, dest.<a class="code" href="class_i_pv6_address.html#a7c42fb066db81588a439aed1de5e4b3a" title="Returns the textual representation of the address in the standard notation.">str</a>().c_str());

    <span class="comment">// first, check if we have an interface with this address</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="class_routing_table6.html#aaaec39a83ad4a660b4cea65d1266b0e4">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a2b0ce46cd92da6f64fc363410dc71904" title="Returns the number of interfaces.">getNumInterfaces</a>(); i++)
    {
        <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_routing_table6.html#aaaec39a83ad4a660b4cea65d1266b0e4">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a19ce4ca3b47b52b8e2b67c25806c4b49" title="Returns the InterfaceEntry specified by an index 0..numInterfaces-1.">getInterface</a>(i);
        <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#af4856e5c4da3563e03fbc388db63ba8a" title="Returns true if the given address is one of the addresses assigned, regardless whether it is tentativ...">hasAddress</a>(dest))
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }

    <span class="comment">// then check for special, preassigned multicast addresses</span>
    <span class="comment">// (these addresses occur more rarely than specific interface addresses,</span>
    <span class="comment">// that&#39;s why we check for them last)</span>

    <span class="keywordflow">if</span> (dest==<a class="code" href="class_i_pv6_address.html#affc233fad6ef60e013d37bd105a7d2fd" title="All-nodes multicast address, scope 1 (interface-local)">IPv6Address::ALL_NODES_1</a> || dest==<a class="code" href="class_i_pv6_address.html#af71ff608917fe0fc14baf50d11815aeb" title="All-nodes multicast address, scope 2 (link-local)">IPv6Address::ALL_NODES_2</a>)
        <span class="keywordflow">return</span> <span class="keyword">true</span>;

    <span class="keywordflow">if</span> (<a class="code" href="class_routing_table6.html#a79a742fa2d94543412e183ebe0e83d3a" title="IP forwarding on/off.">isRouter</a>() &amp;&amp; (dest==<a class="code" href="class_i_pv6_address.html#a6b3ccf4a474ef48fb87935d5d4f92c17" title="All-routers multicast address, scope 1 (interface-local)">IPv6Address::ALL_ROUTERS_1</a> || dest==<a class="code" href="class_i_pv6_address.html#a3550339d4b3388eb3891c4744dca2aa1" title="All-routers multicast address, scope 2 (link-local)">IPv6Address::ALL_ROUTERS_2</a> || dest==<a class="code" href="class_i_pv6_address.html#ae88319a24467c2ed45c6ef94c1105007" title="All-routers multicast address, scope 5 (site-local)">IPv6Address::ALL_ROUTERS_5</a>))
        <span class="keywordflow">return</span> <span class="keyword">true</span>;

    <span class="comment">// check for solicited-node multicast address</span>
    <span class="keywordflow">if</span> (dest.<a class="code" href="class_i_pv6_address.html#a4d9102b52fcf98d1945c75a098bc678a" title="Returns true if the address matches the given prefix.">matches</a>(<a class="code" href="class_i_pv6_address.html#a05683ca5f1a158a96c9a319314cb47bd" title="The solicited-node multicast address prefix (prefix length = 104)">IPv6Address::SOLICITED_NODE_PREFIX</a>, 104))
    {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="class_routing_table6.html#aaaec39a83ad4a660b4cea65d1266b0e4">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a2b0ce46cd92da6f64fc363410dc71904" title="Returns the number of interfaces.">getNumInterfaces</a>(); i++)
        {
            <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_routing_table6.html#aaaec39a83ad4a660b4cea65d1266b0e4">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a19ce4ca3b47b52b8e2b67c25806c4b49" title="Returns the InterfaceEntry specified by an index 0..numInterfaces-1.">getInterface</a>(i);
            <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a19083391271368e371346eb41ccc6c93">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#af4999b8a05ad79d0f97920b1d8a5cadd" title="Returns true if the interface has an address matching the given solicited-node multicast addresses...">matchesSolicitedNodeMulticastAddress</a>(dest))
                <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="afef0aa2431b02b3744b58238c7a73547"></a><!-- doxytag: member="RoutingTable6::isPrefixPresent" ref="afef0aa2431b02b3744b58238c7a73547" args="(const IPv6Address &amp;prefix) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_routing_table6.html#afef0aa2431b02b3744b58238c7a73547">RoutingTable6::isPrefixPresent</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if the given prefix already exists in the routing table (prefix list) </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a5acf0814f6ca500c38d87763c0a5aef7">IPv6NeighbourDiscovery::processRAPrefixInfo()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">for</span> (RouteList::const_iterator it=<a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.begin(); it!=<a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.end(); it++)
        <span class="keywordflow">if</span> (prefix.<a class="code" href="class_i_pv6_address.html#a4d9102b52fcf98d1945c75a098bc678a" title="Returns true if the address matches the given prefix.">matches</a>((*it)-&gt;getDestPrefix(), 128))
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a79a742fa2d94543412e183ebe0e83d3a"></a><!-- doxytag: member="RoutingTable6::isRouter" ref="a79a742fa2d94543412e183ebe0e83d3a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_routing_table6.html#a79a742fa2d94543412e183ebe0e83d3a">RoutingTable6::isRouter</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>IP forwarding on/off. </p>

<p>Referenced by <a class="el" href="class_i_pv6_tunneling.html#a766b601e89d6251771b8405bce8a334e">IPv6Tunneling::createTunnel()</a>, <a class="el" href="class_i_pv6.html#a641e893f2ada9c52fd0d694fa0947503">IPv6::determineOutputInterface()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#a6855729184a9f8c2e0072f6773f5e96c">IPv6NeighbourDiscovery::initialize()</a>, <a class="el" href="class_routing_table6.html#acbf9dbfff5efa25eec0982afa1bbf061">isLocalAddress()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#ab645e6aeaba5afb6cfede0a13d0de5a5">IPv6NeighbourDiscovery::makeTentativeAddressPermanent()</a>, <a class="el" href="class_i_pv6.html#a61eb7d75c2414e64fbcf82c69f9db7bf">IPv6::routeMulticastPacket()</a>, <a class="el" href="class_i_pv6.html#a33a99910431c17c57350ee894d9024e3">IPv6::routePacket()</a>, <a class="el" href="class_i_pv6_neighbour_discovery.html#ac2a5f2e2cbd6845ecd10038fce448ead">IPv6NeighbourDiscovery::sendSolicitedNA()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#a30bc9cd2bec93e40e238fe91b573ca9f">IPv6NeighbourDiscovery::sendUnsolicitedNA()</a>.</p>
<div class="fragment"><pre class="fragment">{<span class="keywordflow">return</span> <a class="code" href="class_routing_table6.html#a0cebbe3d99a2059179fbb17dc833476d">isrouter</a>;}
</pre></div>
</div>
</div>
<a class="anchor" id="abb5be347a43ea6c6fb5ddfd6711e15a3"></a><!-- doxytag: member="RoutingTable6::lookupDestCache" ref="abb5be347a43ea6c6fb5ddfd6711e15a3" args="(const IPv6Address &amp;dest, int &amp;outInterfaceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp; <a class="el" href="class_routing_table6.html#abb5be347a43ea6c6fb5ddfd6711e15a3">RoutingTable6::lookupDestCache</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>outInterfaceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Looks up the given destination address in the Destination Cache, then returns the next-hop address and the interface in the outInterfaceId variable. </p>
<p>If the destination is not in the cache, outInterfaceId is set to -1 and the unspecified address is returned. The caller should check for interfaceId==-1, because unspecified address is also returned if the link layer doesn't use addresses at all (e.g. <a class="el" href="class_p_p_p.html" title="PPP implementation.">PPP</a>).</p>
<p>NOTE: outInterfaceId is an OUTPUT parameter -- its initial value is ignored, and the <a class="el" href="class_routing_table6.html#abb5be347a43ea6c6fb5ddfd6711e15a3" title="Looks up the given destination address in the Destination Cache, then returns the next-hop address an...">lookupDestCache()</a> sets it to the correct value instead. </p>

<p>Referenced by <a class="el" href="class_i_pv6.html#a641e893f2ada9c52fd0d694fa0947503">IPv6::determineOutputInterface()</a>, and <a class="el" href="class_i_pv6_tunneling.html#ab7f405c4359671ad1021598935fde70d">IPv6Tunneling::encapsulateDatagram()</a>.</p>
<div class="fragment"><pre class="fragment">{
    Enter_Method(<span class="stringliteral">&quot;lookupDestCache(%s)&quot;</span>, dest.<a class="code" href="class_i_pv6_address.html#a7c42fb066db81588a439aed1de5e4b3a" title="Returns the textual representation of the address in the standard notation.">str</a>().c_str());

    DestCache::iterator it = <a class="code" href="class_routing_table6.html#a40eeef91dde2b4b37c53fdc2d88a6b7d">destCache</a>.find(dest);
    <span class="keywordflow">if</span> (it == <a class="code" href="class_routing_table6.html#a40eeef91dde2b4b37c53fdc2d88a6b7d">destCache</a>.end())
    {
        outInterfaceId = -1;
        <span class="keywordflow">return</span> <a class="code" href="class_i_pv6_address.html#a0c1e137cb3b1470ec6b8d9a95e03dbe5" title="The unspecified address.">IPv6Address::UNSPECIFIED_ADDRESS</a>;
    }
    DestCacheEntry &amp;entry = it-&gt;second;
    <span class="keywordflow">if</span> (entry.expiryTime &gt; 0 &amp;&amp; simTime() &gt; entry.expiryTime)
    {
        <a class="code" href="class_routing_table6.html#a40eeef91dde2b4b37c53fdc2d88a6b7d">destCache</a>.erase(it);
        outInterfaceId = -1;
        <span class="keywordflow">return</span> <a class="code" href="class_i_pv6_address.html#a0c1e137cb3b1470ec6b8d9a95e03dbe5" title="The unspecified address.">IPv6Address::UNSPECIFIED_ADDRESS</a>;
    }

    outInterfaceId = entry.interfaceId;
    <span class="keywordflow">return</span> entry.nextHopAddr;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a19bf3f3581b2564834e3afda3c7181e6"></a><!-- doxytag: member="RoutingTable6::numInitStages" ref="a19bf3f3581b2564834e3afda3c7181e6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="class_routing_table6.html#a19bf3f3581b2564834e3afda3c7181e6">RoutingTable6::numInitStages</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{<span class="keywordflow">return</span> 5;}
</pre></div>
</div>
</div>
<a class="anchor" id="a3dc6e638b861a416cd1a44f8dbde473a"></a><!-- doxytag: member="RoutingTable6::parseXMLConfigFile" ref="a3dc6e638b861a416cd1a44f8dbde473a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#a3dc6e638b861a416cd1a44f8dbde473a">RoutingTable6::parseXMLConfigFile</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_routing_table6.html#a3a930dca8cabc52375c754dfce15252d">initialize()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// TODO to be revised by Andras</span>
    <span class="comment">// configure interfaces from XML config file</span>
    cXMLElement *config = par(<span class="stringliteral">&quot;routingTable&quot;</span>);
    <span class="keywordflow">for</span> (cXMLElement *child=config-&gt;getFirstChild(); child; child = child-&gt;getNextSibling())
    {
        <span class="comment">//std::cout &lt;&lt; &quot;configuring interfaces from XML file.&quot; &lt;&lt; endl;</span>
        <span class="comment">//std::cout &lt;&lt; &quot;selected element is: &quot; &lt;&lt; child-&gt;getTagName() &lt;&lt; endl;</span>
        <span class="comment">// we ensure that the selected element is local.</span>
        <span class="keywordflow">if</span> (opp_strcmp(child-&gt;getTagName(), <span class="stringliteral">&quot;local&quot;</span>)!=0) <span class="keywordflow">continue</span>;
        <span class="comment">//ensure that this is the right parent module we are configuring.</span>
        <span class="keywordflow">if</span> (opp_strcmp(child-&gt;getAttribute(<span class="stringliteral">&quot;node&quot;</span>), getParentModule()-&gt;getFullName())!=0)
            <span class="keywordflow">continue</span>;
        <span class="comment">//Go one level deeper.</span>
        <span class="comment">//child = child-&gt;getFirstChild();</span>
        <span class="keywordflow">for</span> (cXMLElement *ifTag=child-&gt;getFirstChild(); ifTag; ifTag = ifTag-&gt;getNextSibling())
        {
            <span class="comment">//The next tag should be &quot;interface&quot;.</span>
            <span class="keywordflow">if</span> (opp_strcmp(ifTag-&gt;getTagName(), <span class="stringliteral">&quot;interface&quot;</span>)==0)
            {
                <span class="comment">//std::cout &lt;&lt; &quot;Getting attribute: name&quot; &lt;&lt; endl;</span>
                <span class="keyword">const</span> <span class="keywordtype">char</span> *ifname = ifTag-&gt;getAttribute(<span class="stringliteral">&quot;name&quot;</span>);
                <span class="keywordflow">if</span> (!ifname)
                    error(<span class="stringliteral">&quot;&lt;interface&gt; without name attribute at %s&quot;</span>, child-&gt;getSourceLocation());

                <a class="code" href="class_interface_entry.html" title="Interface entry for the interface table in IInterfaceTable.">InterfaceEntry</a> *ie = <a class="code" href="class_routing_table6.html#aaaec39a83ad4a660b4cea65d1266b0e4">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a8ad86ee823d6200b4f558383b39af658" title="Returns an interface given by its name.">getInterfaceByName</a>(ifname);
                <span class="keywordflow">if</span> (!ie)
                    error(<span class="stringliteral">&quot;no interface named %s was registered, %s&quot;</span>, ifname, child-&gt;getSourceLocation());

                <a class="code" href="class_routing_table6.html#a5d4f86dbabc31663a4bd12f50a72140f">configureInterfaceFromXML</a>(ie, ifTag);
            }
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opp_strcmp(ifTag-&gt;getTagName(), <span class="stringliteral">&quot;tunnel&quot;</span>)==0)
                <a class="code" href="class_routing_table6.html#a0a0c804ccf3360f7476aa1e21b66e79e">configureTunnelFromXML</a>(ifTag);
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a508ea0dd32bd3256348e99abe32a48a9"></a><!-- doxytag: member="RoutingTable6::purgeDestCache" ref="a508ea0dd32bd3256348e99abe32a48a9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#a508ea0dd32bd3256348e99abe32a48a9">RoutingTable6::purgeDestCache</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Discard all entries in destination cache. </p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_routing_table6.html#a40eeef91dde2b4b37c53fdc2d88a6b7d">destCache</a>.clear();
    <a class="code" href="class_routing_table6.html#ac174c90714b3e6b245c5084850651af7">updateDisplayString</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1b4f1c86d678de8ac3f873ac7de0687f"></a><!-- doxytag: member="RoutingTable6::purgeDestCacheEntriesToNeighbour" ref="a1b4f1c86d678de8ac3f873ac7de0687f" args="(const IPv6Address &amp;nextHopAddr, int interfaceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#a1b4f1c86d678de8ac3f873ac7de0687f">RoutingTable6::purgeDestCacheEntriesToNeighbour</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>nextHopAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interfaceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Discard all entries in destination cache where next hop is the given address on the given interface. </p>
<p>This is typically called when a router becomes unreachable, and all destinations going via that router have to go though router selection again. </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a303391440ad2004ff69cfc5e4cf7504a">IPv6NeighbourDiscovery::timeoutDefaultRouter()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">for</span> (DestCache::iterator it=<a class="code" href="class_routing_table6.html#a40eeef91dde2b4b37c53fdc2d88a6b7d">destCache</a>.begin(); it!=<a class="code" href="class_routing_table6.html#a40eeef91dde2b4b37c53fdc2d88a6b7d">destCache</a>.end(); )
    {
        <span class="keywordflow">if</span> (it-&gt;second.interfaceId==interfaceId &amp;&amp; it-&gt;second.nextHopAddr==nextHopAddr)
        {
            <span class="comment">// move the iterator past this element before removing it</span>
            <a class="code" href="class_routing_table6.html#a40eeef91dde2b4b37c53fdc2d88a6b7d">destCache</a>.erase(it++);
        }
        <span class="keywordflow">else</span>
        {
            it++;
        }
    }

    <a class="code" href="class_routing_table6.html#ac174c90714b3e6b245c5084850651af7">updateDisplayString</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6d1b8498895ed9efdefd0227219a9f85"></a><!-- doxytag: member="RoutingTable6::receiveChangeNotification" ref="a6d1b8498895ed9efdefd0227219a9f85" args="(int category, const cObject *details)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#a6d1b8498895ed9efdefd0227219a9f85">RoutingTable6::receiveChangeNotification</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cObject *&#160;</td>
          <td class="paramname"><em>details</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called by the <a class="el" href="class_notification_board.html" title="Acts as a intermediary between module where state changes can occur and modules which are interested ...">NotificationBoard</a> whenever a change of a category occurs to which this client has subscribed. </p>

<p>Implements <a class="el" href="class_i_notifiable.html#a26809ed59b2ff3e9379b1b4440227a8d">INotifiable</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (simulation.getContextType()==CTX_INITIALIZE)
        <span class="keywordflow">return</span>;  <span class="comment">// ignore notifications during initialize</span>

    Enter_Method_Silent();
    <a class="code" href="_notifier_consts_8cc.html#a97f9fe597921659345dbf486bc49069c" title="Utility function.">printNotificationBanner</a>(category, details);

    <span class="keywordflow">if</span> (category==<a class="code" href="_notifier_consts_8h.html#adf764cbdea00d65edcd07bb9953ad2b7aea2d4297f1e519520524d4bd8ff865b4">NF_INTERFACE_CREATED</a>)
    {
        <span class="comment">//TODO something like this:</span>
        <span class="comment">//InterfaceEntry *ie = check_and_cast&lt;InterfaceEntry*&gt;(details);</span>
        <span class="comment">//configureInterfaceForIPv6(ie);</span>
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (category==<a class="code" href="_notifier_consts_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a4f8e57f4754cbf2e6ba92a7079b483e4">NF_INTERFACE_DELETED</a>)
    {
        <span class="comment">//TODO remove all routes that point to that interface (?)</span>
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (category==<a class="code" href="_notifier_consts_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a5ed0701efe7413c8f98fd0ba7fa9947d">NF_INTERFACE_STATE_CHANGED</a>)
    {
        <span class="comment">//TODO invalidate routing cache (?)</span>
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (category==<a class="code" href="_notifier_consts_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a3a1d2cac1cec476f84c60030a70ef902">NF_INTERFACE_CONFIG_CHANGED</a>)
    {
        <span class="comment">//TODO invalidate routing cache (?)</span>
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (category==<a class="code" href="_notifier_consts_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a7ce81127c07e25b007f9ec96f3643d52">NF_INTERFACE_IPv6CONFIG_CHANGED</a>)
    {
        <span class="comment">//TODO</span>
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a85e00922381c188efc0ad51197e5f718"></a><!-- doxytag: member="RoutingTable6::removeOnLinkPrefix" ref="a85e00922381c188efc0ad51197e5f718" args="(const IPv6Address &amp;destPrefix, int prefixLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#a85e00922381c188efc0ad51197e5f718">RoutingTable6::removeOnLinkPrefix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>destPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prefixLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove an on-link prefix. </p>
<p>To be called when the prefix gets advertised with zero lifetime, or to purge an expired prefix.</p>
<p>NOTE: This method does NOT remove the matching addresses from the <a class="el" href="class_i_interface_table.html" title="A C++ interface to abstract the functionality of InterfaceTable.">IInterfaceTable</a> (see <a class="el" href="class_i_pv6_interface_data.html" title="IPv6-specific data for InterfaceEntry.">IPv6InterfaceData</a>); that has to be done separately. </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a5acf0814f6ca500c38d87763c0a5aef7">IPv6NeighbourDiscovery::processRAPrefixInfo()</a>, and <a class="el" href="class_i_pv6_neighbour_discovery.html#a0e59b5c2995f7bdec6b6a67e60a1e675">IPv6NeighbourDiscovery::timeoutPrefixEntry()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// scan the routing table for this prefix and remove it</span>
    <span class="keywordflow">for</span> (RouteList::iterator it=<a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.begin(); it!=<a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.end(); it++)
    {
        <span class="keywordflow">if</span> ((*it)-&gt;getSrc()==<a class="code" href="class_i_pv6_route.html#a4eac9172e292e624476a22b74478e087a7e360222defd4f4a1af6d1e70442a5c8" title="on-link prefix, from Router Advertisement">IPv6Route::FROM_RA</a> &amp;&amp; (*it)-&gt;getDestPrefix()==destPrefix &amp;&amp; (*it)-&gt;getPrefixLength()==prefixLength)
        {
            <a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.erase(it);
            <span class="keywordflow">return</span>; <span class="comment">// there can be only one such route, addOrUpdateOnLinkPrefix() guarantees that</span>
        }
    }

    <a class="code" href="class_routing_table6.html#ac174c90714b3e6b245c5084850651af7">updateDisplayString</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="acd6b7dbf0bfa1e923366a2bcb1f309fc"></a><!-- doxytag: member="RoutingTable6::removeRoute" ref="acd6b7dbf0bfa1e923366a2bcb1f309fc" args="(IPv6Route *route)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#acd6b7dbf0bfa1e923366a2bcb1f309fc">RoutingTable6::removeRoute</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_route.html">IPv6Route</a> *&#160;</td>
          <td class="paramname"><em>route</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes the given route from the route table. </p>
<div class="fragment"><pre class="fragment">{
    RouteList::iterator it = <a class="code" href="_utils_8cc.html#af9d5523fc1489796aef3d897862ef06c" title="TODO documentation.">std::find</a>(<a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.begin(), <a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.end(), route);
    ASSERT(it!=<a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.end());

    <a class="code" href="structnb.html">nb</a>-&gt;fireChangeNotification(<a class="code" href="_notifier_consts_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a6c8f0e68e262e322d82609fae7425c5f">NF_IPv6_ROUTE_DELETED</a>, route); <span class="comment">// rather: going to be deleted</span>

    <a class="code" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">routeList</a>.erase(it);
    <span class="keyword">delete</span> route;

    <a class="code" href="class_routing_table6.html#ac174c90714b3e6b245c5084850651af7">updateDisplayString</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a707cec2ac6652e7eb0ff97b53f70d9b9"></a><!-- doxytag: member="RoutingTable6::routeLessThan" ref="a707cec2ac6652e7eb0ff97b53f70d9b9" args="(const IPv6Route *a, const IPv6Route *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_routing_table6.html#a707cec2ac6652e7eb0ff97b53f70d9b9">RoutingTable6::routeLessThan</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_route.html">IPv6Route</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_route.html">IPv6Route</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_routing_table6.html#ac5315cdff4b757915773f1c22f273ba4">addRoute()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// helper for sort() in addRoute(). We want routes with longer</span>
    <span class="comment">// prefixes to be at front, so we compare them as &quot;less&quot;.</span>
    <span class="comment">// For metric, a smaller value is better (we report that as &quot;less&quot;).</span>
    <span class="keywordflow">if</span> (a-&gt;<a class="code" href="class_i_pv6_route.html#af9fbb20e012a32c3511e426b4d939457">getPrefixLength</a>()!=b-&gt;<a class="code" href="class_i_pv6_route.html#af9fbb20e012a32c3511e426b4d939457">getPrefixLength</a>())
        <span class="keywordflow">return</span> a-&gt;<a class="code" href="class_i_pv6_route.html#af9fbb20e012a32c3511e426b4d939457">getPrefixLength</a>() &gt; b-&gt;<a class="code" href="class_i_pv6_route.html#af9fbb20e012a32c3511e426b4d939457">getPrefixLength</a>();

    <span class="keywordflow">return</span> a-&gt;<a class="code" href="class_i_pv6_route.html#ab62f850b1e21b95cbd200f2d3099fb7d">getMetric</a>() &lt; b-&gt;<a class="code" href="class_i_pv6_route.html#ab62f850b1e21b95cbd200f2d3099fb7d">getMetric</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1e7fbe36b5dcdfa80e6af5b0c0eea235"></a><!-- doxytag: member="RoutingTable6::updateDestCache" ref="a1e7fbe36b5dcdfa80e6af5b0c0eea235" args="(const IPv6Address &amp;dest, const IPv6Address &amp;nextHopAddr, int interfaceId, simtime_t expiryTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#a1e7fbe36b5dcdfa80e6af5b0c0eea235">RoutingTable6::updateDestCache</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&#160;</td>
          <td class="paramname"><em>nextHopAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interfaceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&#160;</td>
          <td class="paramname"><em>expiryTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add or update a destination cache entry. </p>

<p>Referenced by <a class="el" href="class_i_pv6_neighbour_discovery.html#a4bddad274cd8eb1472d37ddcd559c629">IPv6NeighbourDiscovery::determineNextHop()</a>, and <a class="el" href="class_i_pv6.html#a641e893f2ada9c52fd0d694fa0947503">IPv6::determineOutputInterface()</a>.</p>
<div class="fragment"><pre class="fragment">{
    DestCacheEntry &amp;entry = <a class="code" href="class_routing_table6.html#a40eeef91dde2b4b37c53fdc2d88a6b7d">destCache</a>[dest];
    entry.nextHopAddr = nextHopAddr;
    entry.interfaceId = interfaceId;
    entry.expiryTime = expiryTime;

    <a class="code" href="class_routing_table6.html#ac174c90714b3e6b245c5084850651af7">updateDisplayString</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac174c90714b3e6b245c5084850651af7"></a><!-- doxytag: member="RoutingTable6::updateDisplayString" ref="ac174c90714b3e6b245c5084850651af7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer__queue_8h.html#a07640d68b3fdfaa5c48a36265e8f10b8">void</a> <a class="el" href="class_routing_table6.html#ac174c90714b3e6b245c5084850651af7">RoutingTable6::updateDisplayString</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_routing_table6.html#ad942d6cb5b1376b132947f75924344f6">addOrUpdateOnLinkPrefix()</a>, <a class="el" href="class_routing_table6.html#aad45eef791b41fe469357f1f4c6090bb">addOrUpdateOwnAdvPrefix()</a>, <a class="el" href="class_routing_table6.html#ac5315cdff4b757915773f1c22f273ba4">addRoute()</a>, <a class="el" href="class_routing_table6.html#a3a930dca8cabc52375c754dfce15252d">initialize()</a>, <a class="el" href="class_routing_table6.html#a508ea0dd32bd3256348e99abe32a48a9">purgeDestCache()</a>, <a class="el" href="class_routing_table6.html#a1b4f1c86d678de8ac3f873ac7de0687f">purgeDestCacheEntriesToNeighbour()</a>, <a class="el" href="class_routing_table6.html#a85e00922381c188efc0ad51197e5f718">removeOnLinkPrefix()</a>, <a class="el" href="class_routing_table6.html#acd6b7dbf0bfa1e923366a2bcb1f309fc">removeRoute()</a>, and <a class="el" href="class_routing_table6.html#a1e7fbe36b5dcdfa80e6af5b0c0eea235">updateDestCache()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (!ev.isGUI())
        <span class="keywordflow">return</span>;

    std::stringstream os;

    os &lt;&lt; <a class="code" href="class_routing_table6.html#a384a101ad5895b4cdbc796ec0fb427e3" title="Return the number of routes.">getNumRoutes</a>() &lt;&lt; <span class="stringliteral">&quot; routes\n&quot;</span> &lt;&lt; <a class="code" href="class_routing_table6.html#a40eeef91dde2b4b37c53fdc2d88a6b7d">destCache</a>.size() &lt;&lt; <span class="stringliteral">&quot; destcache entries&quot;</span>;
    getDisplayString().setTagArg(<span class="stringliteral">&quot;t&quot;</span>, 0, os.str().c_str());
}
</pre></div>
</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a9a8e6d548f687ed667d614b61d4b7ab8"></a><!-- doxytag: member="RoutingTable6::operator&lt;&lt;" ref="a9a8e6d548f687ed667d614b61d4b7ab8" args="(std::ostream &amp;os, const DestCacheEntry &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_routing_table6_1_1_dest_cache_entry.html">DestCacheEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    os &lt;&lt; <span class="stringliteral">&quot;if=&quot;</span> &lt;&lt; e.interfaceId &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; e.nextHopAddr;  <span class="comment">//FIXME try printing interface name</span>
    <span class="keywordflow">return</span> os;
};
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a40eeef91dde2b4b37c53fdc2d88a6b7d"></a><!-- doxytag: member="RoutingTable6::destCache" ref="a40eeef91dde2b4b37c53fdc2d88a6b7d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_routing_table6.html#ae97d16a39dd6e82ed1fef07e2bd5ac49">DestCache</a> <a class="el" href="class_routing_table6.html#a40eeef91dde2b4b37c53fdc2d88a6b7d">RoutingTable6::destCache</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_routing_table6.html#a3a930dca8cabc52375c754dfce15252d">initialize()</a>, <a class="el" href="class_routing_table6.html#abb5be347a43ea6c6fb5ddfd6711e15a3">lookupDestCache()</a>, <a class="el" href="class_routing_table6.html#a508ea0dd32bd3256348e99abe32a48a9">purgeDestCache()</a>, <a class="el" href="class_routing_table6.html#a1b4f1c86d678de8ac3f873ac7de0687f">purgeDestCacheEntriesToNeighbour()</a>, <a class="el" href="class_routing_table6.html#a1e7fbe36b5dcdfa80e6af5b0c0eea235">updateDestCache()</a>, and <a class="el" href="class_routing_table6.html#ac174c90714b3e6b245c5084850651af7">updateDisplayString()</a>.</p>

</div>
</div>
<a class="anchor" id="aaaec39a83ad4a660b4cea65d1266b0e4"></a><!-- doxytag: member="RoutingTable6::ift" ref="aaaec39a83ad4a660b4cea65d1266b0e4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_interface_table.html">IInterfaceTable</a>* <a class="el" href="class_routing_table6.html#aaaec39a83ad4a660b4cea65d1266b0e4">RoutingTable6::ift</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_routing_table6.html#a24cede6c1b7ed7a17fad2525a4702851">getInterfaceByAddress()</a>, <a class="el" href="class_routing_table6.html#a3a930dca8cabc52375c754dfce15252d">initialize()</a>, <a class="el" href="class_routing_table6.html#acbf9dbfff5efa25eec0982afa1bbf061">isLocalAddress()</a>, and <a class="el" href="class_routing_table6.html#a3dc6e638b861a416cd1a44f8dbde473a">parseXMLConfigFile()</a>.</p>

</div>
</div>
<a class="anchor" id="a0cebbe3d99a2059179fbb17dc833476d"></a><!-- doxytag: member="RoutingTable6::isrouter" ref="a0cebbe3d99a2059179fbb17dc833476d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_routing_table6.html#a0cebbe3d99a2059179fbb17dc833476d">RoutingTable6::isrouter</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_routing_table6.html#ab78638e39019d6ca1690d926da5f04fe">configureInterfaceForIPv6()</a>, and <a class="el" href="class_routing_table6.html#a3a930dca8cabc52375c754dfce15252d">initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a03a9b00ecf47fb5395108c427d9e05f7"></a><!-- doxytag: member="RoutingTable6::nb" ref="a03a9b00ecf47fb5395108c427d9e05f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_notification_board.html">NotificationBoard</a>* <a class="el" href="class_routing_table6.html#a03a9b00ecf47fb5395108c427d9e05f7">RoutingTable6::nb</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a876169265a1d3d1fc1224becfcb7ca67"></a><!-- doxytag: member="RoutingTable6::routeList" ref="a876169265a1d3d1fc1224becfcb7ca67" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_routing_table6.html#ae2d7a96a112758e54bb1fa5e5f41d4bc">RouteList</a> <a class="el" href="class_routing_table6.html#a876169265a1d3d1fc1224becfcb7ca67">RoutingTable6::routeList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_routing_table6.html#ad942d6cb5b1376b132947f75924344f6">addOrUpdateOnLinkPrefix()</a>, <a class="el" href="class_routing_table6.html#aad45eef791b41fe469357f1f4c6090bb">addOrUpdateOwnAdvPrefix()</a>, <a class="el" href="class_routing_table6.html#ac5315cdff4b757915773f1c22f273ba4">addRoute()</a>, <a class="el" href="class_routing_table6.html#aa3ba1d17dc59f3e5d77ead359dd3a999">doLongestPrefixMatch()</a>, <a class="el" href="class_routing_table6.html#a384a101ad5895b4cdbc796ec0fb427e3">getNumRoutes()</a>, <a class="el" href="class_routing_table6.html#a037e2206e766dff2c8cc904694feba88">getRoute()</a>, <a class="el" href="class_routing_table6.html#a3a930dca8cabc52375c754dfce15252d">initialize()</a>, <a class="el" href="class_routing_table6.html#afef0aa2431b02b3744b58238c7a73547">isPrefixPresent()</a>, <a class="el" href="class_routing_table6.html#a85e00922381c188efc0ad51197e5f718">removeOnLinkPrefix()</a>, <a class="el" href="class_routing_table6.html#acd6b7dbf0bfa1e923366a2bcb1f309fc">removeRoute()</a>, and <a class="el" href="class_routing_table6.html#aa08b78617d4f08502d746686ecf0a58c">~RoutingTable6()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_routing_table6_8h.html">RoutingTable6.h</a></li>
<li><a class="el" href="_routing_table6_8cc.html">RoutingTable6.cc</a></li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="class_routing_table6.html">RoutingTable6</a>      </li>

    <li class="footer">Generated on Tue Aug 7 2012 16:01:29 for INET Framework for OMNeT++/OMNEST by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
