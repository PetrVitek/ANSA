<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>INET Framework for OMNeT++/OMNEST: UDP Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">INET Framework for OMNeT++/OMNEST</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_u_d_p.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">UDP Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="UDP" -->
<p><code>#include &lt;UDP.h&gt;</code></p>

<p><a href="class_u_d_p-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_d_p_1_1_sock_desc.html">SockDesc</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; <a class="el" href="struct_u_d_p_1_1_sock_desc.html">SockDesc</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a17d5eac534fa0d896ceef2831cd28d77">SockDescList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; int, <a class="el" href="struct_u_d_p_1_1_sock_desc.html">SockDesc</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a68d5e94d3be14183856abf7f7ac8002a">SocketsByIdMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; int, <br class="typebreak"/>
<a class="el" href="class_u_d_p.html#a17d5eac534fa0d896ceef2831cd28d77">SockDescList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a829a029b999e1f99838cd59e10eab3a9">SocketsByPortMap</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#ac9e9b89f827804de5bb675e8adbc9eab">UDP</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#ac9c6eaf3e5f1bd64ea3ac0552137ca0e">~UDP</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a5c2df70abc011c2753a47cbff187a306">updateDisplayString</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a7ad4f9f51d27f92e0d23041f9b64a896">bind</a> (int gateIndex, UDPControlInfo *ctrl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a9fb94355db86e280d8de7b1ef7ced43c">connect</a> (int sockId, <a class="el" href="class_i_pv_x_address.html">IPvXAddress</a> addr, int port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a92b95e9e592cd6beff8f0b20228bc214">unbind</a> (int sockId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="_i_n_e_t_defs_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a28ca0f88569dadf1b8f5eaad7e039c49">getEphemeralPort</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a7e436c2b0a7b563bae29603603422cc0">matchesSocket</a> (<a class="el" href="struct_u_d_p_1_1_sock_desc.html">SockDesc</a> *sd, UDPPacket *udp, <a class="el" href="class_i_p_control_info.html">IPControlInfo</a> *ctrl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a6529b4917795bbb08f2fe013045718aa">matchesSocket</a> (<a class="el" href="struct_u_d_p_1_1_sock_desc.html">SockDesc</a> *sd, UDPPacket *udp, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *ctrl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a329e083aa2cd0a847fd977f2833e1645">matchesSocket</a> (<a class="el" href="struct_u_d_p_1_1_sock_desc.html">SockDesc</a> *sd, const <a class="el" href="class_i_pv_x_address.html">IPvXAddress</a> &amp;localAddr, const <a class="el" href="class_i_pv_x_address.html">IPvXAddress</a> &amp;remoteAddr, <a class="el" href="_i_n_e_t_defs_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a> remotePort)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#affa73f57d52206f4aa5bc2539ac63c0f">sendUp</a> (cPacket *payload, UDPPacket *udpHeader, <a class="el" href="class_i_p_control_info.html">IPControlInfo</a> *ctrl, <a class="el" href="struct_u_d_p_1_1_sock_desc.html">SockDesc</a> *sd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#ac693a0a152b8577d646493c325f15b45">sendUp</a> (cPacket *payload, UDPPacket *udpHeader, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *ctrl, <a class="el" href="struct_u_d_p_1_1_sock_desc.html">SockDesc</a> *sd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a5a411e560693182d2cde11ab5566e1fc">processUndeliverablePacket</a> (UDPPacket *udpPacket, cPolymorphic *ctrl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#aa6d3f6a65fcb255abab778a7f13ca771">sendUpErrorNotification</a> (<a class="el" href="struct_u_d_p_1_1_sock_desc.html">SockDesc</a> *sd, int msgkind, const <a class="el" href="class_i_pv_x_address.html">IPvXAddress</a> &amp;localAddr, const <a class="el" href="class_i_pv_x_address.html">IPvXAddress</a> &amp;remoteAddr, <a class="el" href="_i_n_e_t_defs_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a> remotePort)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a8f0e27d03d3e209f437bfa72dd3efe38">processICMPError</a> (cPacket *icmpErrorMsg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a333fddcf308d3c6348c9cc5e6bfa796d">processUDPPacket</a> (UDPPacket *udpPacket)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a1d2e34c55abb9e373694d77d3bac8f09">processMsgFromApp</a> (cPacket *appData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#ae251c9826aa3b5242ad02d6620ea2616">processCommandFromApp</a> (cMessage *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual UDPPacket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#af5e2c13d9e3a33936212cefdfa723d18">createUDPPacket</a> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a9ff0a87c6965238d54bb67997d6912ca">initialize</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a79daccc47126abbf6740b029d7a57089">handleMessage</a> (cMessage *msg)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_u_d_p.html#a68d5e94d3be14183856abf7f7ac8002a">SocketsByIdMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a7019475e3a2bd786a634fbbe72aa91c6">socketsByIdMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_u_d_p.html#a829a029b999e1f99838cd59e10eab3a9">SocketsByPortMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#af6f8ebb75300e83c3b28ba5bd0ed585d">socketsByPortMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_i_n_e_t_defs_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a277fa200fd58e593bc1263149ce85831">lastEphemeralPort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_c_m_p.html">ICMP</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a4995c941113ffc075a8a4b6051fb1ca4">icmp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_c_m_pv6.html">ICMPv6</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a63a772449305921a2f57b9066336c389">icmpv6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#aa7f7b7568b014af23fb3f7c2efc218c1">numSent</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#ab6bee27f7907a894de4173e003adbd69">numPassedUp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#ac262e3d6e3c88dbb2ff457c1c8837162">numDroppedWrongPort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_d_p.html#a9ed09aeb9c434f9c7931dc82d3b2d34c">numDroppedBadChecksum</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Implements the <a class="el" href="class_u_d_p.html">UDP</a> protocol: encapsulates/decapsulates user data into/from <a class="el" href="class_u_d_p.html">UDP</a>.</p>
<p>More info in the NED file. </p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a17d5eac534fa0d896ceef2831cd28d77"></a><!-- doxytag: member="UDP::SockDescList" ref="a17d5eac534fa0d896ceef2831cd28d77" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="struct_u_d_p_1_1_sock_desc.html">SockDesc</a> *&gt; <a class="el" href="class_u_d_p.html#a17d5eac534fa0d896ceef2831cd28d77">UDP::SockDescList</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a68d5e94d3be14183856abf7f7ac8002a"></a><!-- doxytag: member="UDP::SocketsByIdMap" ref="a68d5e94d3be14183856abf7f7ac8002a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;int,<a class="el" href="struct_u_d_p_1_1_sock_desc.html">SockDesc</a> *&gt; <a class="el" href="class_u_d_p.html#a68d5e94d3be14183856abf7f7ac8002a">UDP::SocketsByIdMap</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a829a029b999e1f99838cd59e10eab3a9"></a><!-- doxytag: member="UDP::SocketsByPortMap" ref="a829a029b999e1f99838cd59e10eab3a9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;int,<a class="el" href="class_u_d_p.html#a17d5eac534fa0d896ceef2831cd28d77">SockDescList</a>&gt; <a class="el" href="class_u_d_p.html#a829a029b999e1f99838cd59e10eab3a9">UDP::SocketsByPortMap</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac9e9b89f827804de5bb675e8adbc9eab"></a><!-- doxytag: member="UDP::UDP" ref="ac9e9b89f827804de5bb675e8adbc9eab" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDP::UDP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{}
</pre></div>
</div>
</div>
<a class="anchor" id="ac9c6eaf3e5f1bd64ea3ac0552137ca0e"></a><!-- doxytag: member="UDP::~UDP" ref="ac9c6eaf3e5f1bd64ea3ac0552137ca0e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDP::~UDP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">for</span> (SocketsByIdMap::iterator i=<a class="code" href="class_u_d_p.html#a7019475e3a2bd786a634fbbe72aa91c6">socketsByIdMap</a>.begin(); i!=<a class="code" href="class_u_d_p.html#a7019475e3a2bd786a634fbbe72aa91c6">socketsByIdMap</a>.end(); ++i)
        <span class="keyword">delete</span> i-&gt;second;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7ad4f9f51d27f92e0d23041f9b64a896"></a><!-- doxytag: member="UDP::bind" ref="a7ad4f9f51d27f92e0d23041f9b64a896" args="(int gateIndex, UDPControlInfo *ctrl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UDP::bind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gateIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UDPControlInfo *&#160;</td>
          <td class="paramname"><em>ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#ae251c9826aa3b5242ad02d6620ea2616">processCommandFromApp()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// XXX checks could be added, of when the bind should be allowed to proceed</span>

    <span class="comment">// create and fill in SockDesc</span>
    SockDesc *sd = <span class="keyword">new</span> SockDesc();
    sd-&gt;sockId = ctrl-&gt;getSockId();
    sd-&gt;userId = ctrl-&gt;getUserId();
    sd-&gt;appGateIndex = gateIndex;
    sd-&gt;localAddr = ctrl-&gt;getSrcAddr();
    sd-&gt;remoteAddr = ctrl-&gt;getDestAddr();
    sd-&gt;localPort = ctrl-&gt;getSrcPort();
    sd-&gt;remotePort = ctrl-&gt;getDestPort();
    sd-&gt;interfaceId = ctrl-&gt;getInterfaceId();

    <span class="keywordflow">if</span> (sd-&gt;sockId==-1)
        error(<span class="stringliteral">&quot;sockId in BIND message not filled in&quot;</span>);
    <span class="keywordflow">if</span> (sd-&gt;localPort==0)
        sd-&gt;localPort = <a class="code" href="class_u_d_p.html#a28ca0f88569dadf1b8f5eaad7e039c49">getEphemeralPort</a>();

    sd-&gt;onlyLocalPortIsSet = sd-&gt;localAddr.isUnspecified() &amp;&amp;
                             sd-&gt;remoteAddr.isUnspecified() &amp;&amp;
                             sd-&gt;remotePort==0 &amp;&amp;
                             sd-&gt;interfaceId==-1;

    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Binding socket: &quot;</span> &lt;&lt; *sd &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

    <span class="comment">// add to socketsByIdMap</span>
    ASSERT(<a class="code" href="class_u_d_p.html#a7019475e3a2bd786a634fbbe72aa91c6">socketsByIdMap</a>.find(sd-&gt;sockId)==<a class="code" href="class_u_d_p.html#a7019475e3a2bd786a634fbbe72aa91c6">socketsByIdMap</a>.end());
    <a class="code" href="class_u_d_p.html#a7019475e3a2bd786a634fbbe72aa91c6">socketsByIdMap</a>[sd-&gt;sockId] = sd;

    <span class="comment">// add to socketsByPortMap</span>
    <a class="code" href="class_u_d_p.html#a17d5eac534fa0d896ceef2831cd28d77">SockDescList</a>&amp; list = <a class="code" href="class_u_d_p.html#af6f8ebb75300e83c3b28ba5bd0ed585d">socketsByPortMap</a>[sd-&gt;localPort]; <span class="comment">// create if doesn&#39;t exist</span>
    list.push_back(sd);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9fb94355db86e280d8de7b1ef7ced43c"></a><!-- doxytag: member="UDP::connect" ref="a9fb94355db86e280d8de7b1ef7ced43c" args="(int sockId, IPvXAddress addr, int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UDP::connect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sockId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv_x_address.html">IPvXAddress</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#ae251c9826aa3b5242ad02d6620ea2616">processCommandFromApp()</a>.</p>
<div class="fragment"><pre class="fragment">{
    SocketsByIdMap::iterator it = <a class="code" href="class_u_d_p.html#a7019475e3a2bd786a634fbbe72aa91c6">socketsByIdMap</a>.find(sockId);
    <span class="keywordflow">if</span> (it==<a class="code" href="class_u_d_p.html#a7019475e3a2bd786a634fbbe72aa91c6">socketsByIdMap</a>.end())
        error(<span class="stringliteral">&quot;socket id=%d doesn&#39;t exist (already closed?)&quot;</span>, sockId);
    <span class="keywordflow">if</span> (addr.<a class="code" href="class_i_pv_x_address.html#aa3534408a9aa5e4cb3fc141597d0ed1e">isUnspecified</a>())
        opp_error(<span class="stringliteral">&quot;connect: unspecified remote address&quot;</span>);
    <span class="keywordflow">if</span> (port&lt;=0 || port&gt;65535)
        opp_error(<span class="stringliteral">&quot;connect: invalid remote port number %d&quot;</span>, port);

    SockDesc *sd = it-&gt;second;
    sd-&gt;remoteAddr = addr;
    sd-&gt;remotePort = port;

    sd-&gt;onlyLocalPortIsSet = <span class="keyword">false</span>;

    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Connecting socket: &quot;</span> &lt;&lt; *sd &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af5e2c13d9e3a33936212cefdfa723d18"></a><!-- doxytag: member="UDP::createUDPPacket" ref="af5e2c13d9e3a33936212cefdfa723d18" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPPacket * UDP::createUDPPacket </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a1d2e34c55abb9e373694d77d3bac8f09">processMsgFromApp()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <span class="keyword">new</span> UDPPacket(name);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a28ca0f88569dadf1b8f5eaad7e039c49"></a><!-- doxytag: member="UDP::getEphemeralPort" ref="a28ca0f88569dadf1b8f5eaad7e039c49" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_i_n_e_t_defs_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a> UDP::getEphemeralPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a7ad4f9f51d27f92e0d23041f9b64a896">bind()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// start at the last allocated port number + 1, and search for an unused one</span>
    <a class="code" href="_i_n_e_t_defs_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a> searchUntil = <a class="code" href="class_u_d_p.html#a277fa200fd58e593bc1263149ce85831">lastEphemeralPort</a>++;
    <span class="keywordflow">if</span> (<a class="code" href="class_u_d_p.html#a277fa200fd58e593bc1263149ce85831">lastEphemeralPort</a> == <a class="code" href="_u_d_p_8cc.html#a689da7c4b794eb247004b316117da9d9">EPHEMERAL_PORTRANGE_END</a>) <span class="comment">// wrap</span>
        <a class="code" href="class_u_d_p.html#a277fa200fd58e593bc1263149ce85831">lastEphemeralPort</a> = <a class="code" href="_u_d_p_8cc.html#ae0f9dd1223cbb93271a6c1d5789b5be5">EPHEMERAL_PORTRANGE_START</a>;

    <span class="keywordflow">while</span> (<a class="code" href="class_u_d_p.html#af6f8ebb75300e83c3b28ba5bd0ed585d">socketsByPortMap</a>.find(<a class="code" href="class_u_d_p.html#a277fa200fd58e593bc1263149ce85831">lastEphemeralPort</a>)!=<a class="code" href="class_u_d_p.html#af6f8ebb75300e83c3b28ba5bd0ed585d">socketsByPortMap</a>.end())
    {
        <span class="keywordflow">if</span> (<a class="code" href="class_u_d_p.html#a277fa200fd58e593bc1263149ce85831">lastEphemeralPort</a> == searchUntil) <span class="comment">// got back to starting point?</span>
            error(<span class="stringliteral">&quot;Ephemeral port range %d..%d exhausted, all ports occupied&quot;</span>, <a class="code" href="_u_d_p_8cc.html#ae0f9dd1223cbb93271a6c1d5789b5be5">EPHEMERAL_PORTRANGE_START</a>, <a class="code" href="_u_d_p_8cc.html#a689da7c4b794eb247004b316117da9d9">EPHEMERAL_PORTRANGE_END</a>);
        <a class="code" href="class_u_d_p.html#a277fa200fd58e593bc1263149ce85831">lastEphemeralPort</a>++;
        <span class="keywordflow">if</span> (<a class="code" href="class_u_d_p.html#a277fa200fd58e593bc1263149ce85831">lastEphemeralPort</a> == <a class="code" href="_u_d_p_8cc.html#a689da7c4b794eb247004b316117da9d9">EPHEMERAL_PORTRANGE_END</a>) <span class="comment">// wrap</span>
            <a class="code" href="class_u_d_p.html#a277fa200fd58e593bc1263149ce85831">lastEphemeralPort</a> = <a class="code" href="_u_d_p_8cc.html#ae0f9dd1223cbb93271a6c1d5789b5be5">EPHEMERAL_PORTRANGE_START</a>;
    }

    <span class="comment">// found a free one, return it</span>
    <span class="keywordflow">return</span> <a class="code" href="class_u_d_p.html#a277fa200fd58e593bc1263149ce85831">lastEphemeralPort</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a79daccc47126abbf6740b029d7a57089"></a><!-- doxytag: member="UDP::handleMessage" ref="a79daccc47126abbf6740b029d7a57089" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UDP::handleMessage </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="comment">// received from IP layer</span>
    <span class="keywordflow">if</span> (msg-&gt;arrivedOn(<span class="stringliteral">&quot;ipIn&quot;</span>) || msg-&gt;arrivedOn(<span class="stringliteral">&quot;ipv6In&quot;</span>))
    {
        <span class="keywordflow">if</span> (dynamic_cast&lt;ICMPMessage *&gt;(msg) || <span class="keyword">dynamic_cast&lt;</span>ICMPv6Message *<span class="keyword">&gt;</span>(msg))
            <a class="code" href="class_u_d_p.html#a8f0e27d03d3e209f437bfa72dd3efe38">processICMPError</a>(<a class="code" href="_i_n_e_t_defs_8h.html#ae5b816f7de3c5248c812bdb6920f4e06">PK</a>(msg));
        <span class="keywordflow">else</span>
            <a class="code" href="class_u_d_p.html#a333fddcf308d3c6348c9cc5e6bfa796d">processUDPPacket</a>(check_and_cast&lt;UDPPacket *&gt;(msg));
    }
    <span class="keywordflow">else</span> <span class="comment">// received from application layer</span>
    {
        <span class="keywordflow">if</span> (msg-&gt;getKind()==UDP_C_DATA)
            <a class="code" href="class_u_d_p.html#a1d2e34c55abb9e373694d77d3bac8f09">processMsgFromApp</a>(<a class="code" href="_i_n_e_t_defs_8h.html#ae5b816f7de3c5248c812bdb6920f4e06">PK</a>(msg));
        <span class="keywordflow">else</span>
            <a class="code" href="class_u_d_p.html#ae251c9826aa3b5242ad02d6620ea2616">processCommandFromApp</a>(msg);
    }

    <span class="keywordflow">if</span> (ev.isGUI())
        <a class="code" href="class_u_d_p.html#a5c2df70abc011c2753a47cbff187a306">updateDisplayString</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9ff0a87c6965238d54bb67997d6912ca"></a><!-- doxytag: member="UDP::initialize" ref="a9ff0a87c6965238d54bb67997d6912ca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UDP::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    WATCH_PTRMAP(<a class="code" href="class_u_d_p.html#a7019475e3a2bd786a634fbbe72aa91c6">socketsByIdMap</a>);
    WATCH_MAP(<a class="code" href="class_u_d_p.html#af6f8ebb75300e83c3b28ba5bd0ed585d">socketsByPortMap</a>);

    <a class="code" href="class_u_d_p.html#a277fa200fd58e593bc1263149ce85831">lastEphemeralPort</a> = <a class="code" href="_u_d_p_8cc.html#ae0f9dd1223cbb93271a6c1d5789b5be5">EPHEMERAL_PORTRANGE_START</a>;
    <a class="code" href="structicmp.html">icmp</a> = NULL;
    <a class="code" href="class_u_d_p.html#a63a772449305921a2f57b9066336c389">icmpv6</a> = NULL;

    <a class="code" href="class_u_d_p.html#aa7f7b7568b014af23fb3f7c2efc218c1">numSent</a> = 0;
    <a class="code" href="class_u_d_p.html#ab6bee27f7907a894de4173e003adbd69">numPassedUp</a> = 0;
    <a class="code" href="class_u_d_p.html#ac262e3d6e3c88dbb2ff457c1c8837162">numDroppedWrongPort</a> = 0;
    <a class="code" href="class_u_d_p.html#a9ed09aeb9c434f9c7931dc82d3b2d34c">numDroppedBadChecksum</a> = 0;
    WATCH(<a class="code" href="class_u_d_p.html#aa7f7b7568b014af23fb3f7c2efc218c1">numSent</a>);
    WATCH(<a class="code" href="class_u_d_p.html#ab6bee27f7907a894de4173e003adbd69">numPassedUp</a>);
    WATCH(<a class="code" href="class_u_d_p.html#ac262e3d6e3c88dbb2ff457c1c8837162">numDroppedWrongPort</a>);
    WATCH(<a class="code" href="class_u_d_p.html#a9ed09aeb9c434f9c7931dc82d3b2d34c">numDroppedBadChecksum</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a329e083aa2cd0a847fd977f2833e1645"></a><!-- doxytag: member="UDP::matchesSocket" ref="a329e083aa2cd0a847fd977f2833e1645" args="(SockDesc *sd, const IPvXAddress &amp;localAddr, const IPvXAddress &amp;remoteAddr, ushort remotePort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UDP::matchesSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_d_p_1_1_sock_desc.html">SockDesc</a> *&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_pv_x_address.html">IPvXAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>localAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_pv_x_address.html">IPvXAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>remoteAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_i_n_e_t_defs_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a>&#160;</td>
          <td class="paramname"><em>remotePort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> (sd-&gt;remotePort==0 || sd-&gt;remotePort!=remotePort) &amp;&amp;
           (sd-&gt;localAddr.isUnspecified() || sd-&gt;localAddr==localAddr) &amp;&amp;
           (sd-&gt;remoteAddr.isUnspecified() || sd-&gt;remoteAddr==remoteAddr);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7e436c2b0a7b563bae29603603422cc0"></a><!-- doxytag: member="UDP::matchesSocket" ref="a7e436c2b0a7b563bae29603603422cc0" args="(SockDesc *sd, UDPPacket *udp, IPControlInfo *ctrl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UDP::matchesSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_d_p_1_1_sock_desc.html">SockDesc</a> *&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UDPPacket *&#160;</td>
          <td class="paramname"><em>udp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_p_control_info.html">IPControlInfo</a> *&#160;</td>
          <td class="paramname"><em>ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a8f0e27d03d3e209f437bfa72dd3efe38">processICMPError()</a>, and <a class="el" href="class_u_d_p.html#a333fddcf308d3c6348c9cc5e6bfa796d">processUDPPacket()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// IPv4 version</span>
    <span class="keywordflow">if</span> (sd-&gt;remotePort!=0 &amp;&amp; sd-&gt;remotePort!=udp-&gt;getSourcePort())
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    <span class="keywordflow">if</span> (!sd-&gt;localAddr.isUnspecified() &amp;&amp; sd-&gt;localAddr.get4()!=ipCtrl-&gt;getDestAddr())
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    <span class="keywordflow">if</span> (!sd-&gt;remoteAddr.isUnspecified() &amp;&amp; sd-&gt;remoteAddr.get4()!=ipCtrl-&gt;getSrcAddr())
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    <span class="keywordflow">if</span> (sd-&gt;interfaceId!=-1 &amp;&amp; sd-&gt;interfaceId!=ipCtrl-&gt;getInterfaceId())
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6529b4917795bbb08f2fe013045718aa"></a><!-- doxytag: member="UDP::matchesSocket" ref="a6529b4917795bbb08f2fe013045718aa" args="(SockDesc *sd, UDPPacket *udp, IPv6ControlInfo *ctrl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UDP::matchesSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_d_p_1_1_sock_desc.html">SockDesc</a> *&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UDPPacket *&#160;</td>
          <td class="paramname"><em>udp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&#160;</td>
          <td class="paramname"><em>ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="comment">// IPv6 version</span>
    <span class="keywordflow">if</span> (sd-&gt;remotePort!=0 &amp;&amp; sd-&gt;remotePort!=udp-&gt;getSourcePort())
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    <span class="keywordflow">if</span> (!sd-&gt;localAddr.isUnspecified() &amp;&amp; sd-&gt;localAddr.get6()!=ipCtrl-&gt;getDestAddr())
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    <span class="keywordflow">if</span> (!sd-&gt;remoteAddr.isUnspecified() &amp;&amp; sd-&gt;remoteAddr.get6()!=ipCtrl-&gt;getSrcAddr())
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    <span class="keywordflow">if</span> (sd-&gt;interfaceId!=-1 &amp;&amp; sd-&gt;interfaceId!=ipCtrl-&gt;getInterfaceId())
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae251c9826aa3b5242ad02d6620ea2616"></a><!-- doxytag: member="UDP::processCommandFromApp" ref="ae251c9826aa3b5242ad02d6620ea2616" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UDP::processCommandFromApp </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a79daccc47126abbf6740b029d7a57089">handleMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    UDPControlInfo *udpCtrl = check_and_cast&lt;UDPControlInfo *&gt;(msg-&gt;removeControlInfo());
    <span class="keywordflow">switch</span> (msg-&gt;getKind())
    {
        <span class="keywordflow">case</span> UDP_C_BIND:
            <a class="code" href="class_u_d_p.html#a7ad4f9f51d27f92e0d23041f9b64a896">bind</a>(msg-&gt;getArrivalGate()-&gt;getIndex(), udpCtrl);
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> UDP_C_CONNECT:
            <a class="code" href="class_u_d_p.html#a9fb94355db86e280d8de7b1ef7ced43c">connect</a>(udpCtrl-&gt;getSockId(), udpCtrl-&gt;getDestAddr(), udpCtrl-&gt;getDestPort());
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> UDP_C_UNBIND:
            <a class="code" href="class_u_d_p.html#a92b95e9e592cd6beff8f0b20228bc214">unbind</a>(udpCtrl-&gt;getSockId());
            <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>:
            error(<span class="stringliteral">&quot;unknown command code (message kind) %d received from app&quot;</span>, msg-&gt;getKind());
    }

    <span class="keyword">delete</span> udpCtrl;
    <span class="keyword">delete</span> msg;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8f0e27d03d3e209f437bfa72dd3efe38"></a><!-- doxytag: member="UDP::processICMPError" ref="a8f0e27d03d3e209f437bfa72dd3efe38" args="(cPacket *icmpErrorMsg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UDP::processICMPError </td>
          <td>(</td>
          <td class="paramtype">cPacket *&#160;</td>
          <td class="paramname"><em>icmpErrorMsg</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a79daccc47126abbf6740b029d7a57089">handleMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// extract details from the error message, then try to notify socket that sent bogus packet</span>
    <span class="keywordtype">int</span> type, code;
    <a class="code" href="class_i_pv_x_address.html">IPvXAddress</a> localAddr, remoteAddr;
    <a class="code" href="_i_n_e_t_defs_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a> localPort, remotePort;

    <span class="keywordflow">if</span> (dynamic_cast&lt;ICMPMessage *&gt;(msg))
    {
        ICMPMessage *icmpMsg = (ICMPMessage *)msg;
        type = icmpMsg-&gt;getType();
        code = icmpMsg-&gt;getCode();
        <span class="comment">// Note: we must NOT use decapsulate() because payload in ICMP is conceptually truncated</span>
        IPDatagram *datagram = check_and_cast&lt;IPDatagram *&gt;(icmpMsg-&gt;getEncapsulatedPacket());
        UDPPacket *packet = check_and_cast&lt;UDPPacket *&gt;(datagram-&gt;getEncapsulatedPacket());
        localAddr = datagram-&gt;getSrcAddress();
        remoteAddr = datagram-&gt;getDestAddress();
        localPort = packet-&gt;getSourcePort();
        remotePort = packet-&gt;getDestinationPort();
        <span class="keyword">delete</span> icmpMsg;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;ICMPv6Message *&gt;(msg))
    {
        ICMPv6Message *icmpMsg = (ICMPv6Message *)msg;
        type = icmpMsg-&gt;getType();
        code = -1; <span class="comment">// FIXME this is dependent on getType()...</span>
        <span class="comment">// Note: we must NOT use decapsulate() because payload in ICMP is conceptually truncated</span>
        <a class="code" href="class_i_pv6_datagram.html">IPv6Datagram</a> *datagram = check_and_cast&lt;<a class="code" href="class_i_pv6_datagram.html">IPv6Datagram</a> *&gt;(icmpMsg-&gt;getEncapsulatedPacket());
        UDPPacket *packet = check_and_cast&lt;UDPPacket *&gt;(datagram-&gt;getEncapsulatedPacket());
        localAddr = datagram-&gt;getSrcAddress();
        remoteAddr = datagram-&gt;getDestAddress();
        localPort = packet-&gt;getSourcePort();
        remotePort = packet-&gt;getDestinationPort();
        <span class="keyword">delete</span> icmpMsg;
    }
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;ICMP error received: type=&quot;</span> &lt;&lt; type &lt;&lt; <span class="stringliteral">&quot; code=&quot;</span> &lt;&lt; code
       &lt;&lt; <span class="stringliteral">&quot; about packet &quot;</span> &lt;&lt; localAddr &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; localPort &lt;&lt; <span class="stringliteral">&quot; &gt; &quot;</span>
       &lt;&lt; remoteAddr &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; remotePort &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

    <span class="comment">// identify socket and report error to it</span>
    SocketsByPortMap::iterator it = <a class="code" href="class_u_d_p.html#af6f8ebb75300e83c3b28ba5bd0ed585d">socketsByPortMap</a>.find(localPort);
    <span class="keywordflow">if</span> (it==<a class="code" href="class_u_d_p.html#af6f8ebb75300e83c3b28ba5bd0ed585d">socketsByPortMap</a>.end())
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;No socket on that local port, ignoring ICMP error\n&quot;</span>;
        <span class="keywordflow">return</span>;
    }
    <a class="code" href="class_u_d_p.html#a17d5eac534fa0d896ceef2831cd28d77">SockDescList</a>&amp; list = it-&gt;second;
    SockDesc *srcSocket = NULL;
    <span class="keywordflow">for</span> (SockDescList::iterator it=list.begin(); it!=list.end(); ++it)
    {
        SockDesc *sd = *it;
        <span class="keywordflow">if</span> (sd-&gt;onlyLocalPortIsSet || <a class="code" href="class_u_d_p.html#a7e436c2b0a7b563bae29603603422cc0">matchesSocket</a>(sd, localAddr, remoteAddr, remotePort))
        {
            srcSocket = sd; <span class="comment">// FIXME what to do if there&#39;s more than one matching socket ???</span>
        }
    }
    <span class="keywordflow">if</span> (!srcSocket)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;No matching socket, ignoring ICMP error\n&quot;</span>;
        <span class="keywordflow">return</span>;
    }

    <span class="comment">// send UDP_I_ERROR to socket</span>
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Source socket is sockId=&quot;</span> &lt;&lt; srcSocket-&gt;sockId &lt;&lt; <span class="stringliteral">&quot;, notifying.\n&quot;</span>;
    <a class="code" href="class_u_d_p.html#aa6d3f6a65fcb255abab778a7f13ca771">sendUpErrorNotification</a>(srcSocket, UDP_I_ERROR, localAddr, remoteAddr, remotePort);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1d2e34c55abb9e373694d77d3bac8f09"></a><!-- doxytag: member="UDP::processMsgFromApp" ref="a1d2e34c55abb9e373694d77d3bac8f09" args="(cPacket *appData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UDP::processMsgFromApp </td>
          <td>(</td>
          <td class="paramtype">cPacket *&#160;</td>
          <td class="paramname"><em>appData</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a79daccc47126abbf6740b029d7a57089">handleMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    UDPControlInfo *udpCtrl = check_and_cast&lt;UDPControlInfo *&gt;(appData-&gt;removeControlInfo());

    UDPPacket *udpPacket = <a class="code" href="class_u_d_p.html#af5e2c13d9e3a33936212cefdfa723d18">createUDPPacket</a>(appData-&gt;getName());
    udpPacket-&gt;setByteLength(<a class="code" href="_u_d_p_8h.html#aef334ff0aa0d9bd45ea8385f98a49805">UDP_HEADER_BYTES</a>);
    udpPacket-&gt;encapsulate(appData);

    <span class="comment">// set source and destination port</span>
    udpPacket-&gt;setSourcePort(udpCtrl-&gt;getSrcPort());
    udpPacket-&gt;setDestinationPort(udpCtrl-&gt;getDestPort());

    <span class="keywordflow">if</span> (!udpCtrl-&gt;getDestAddr().isIPv6())
    {
        <span class="comment">// send to IPv4</span>
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Sending app packet &quot;</span> &lt;&lt; appData-&gt;getName() &lt;&lt; <span class="stringliteral">&quot; over IPv4.\n&quot;</span>;
        <a class="code" href="class_i_p_control_info.html">IPControlInfo</a> *ipControlInfo = <span class="keyword">new</span> <a class="code" href="class_i_p_control_info.html">IPControlInfo</a>();
        ipControlInfo-&gt;setProtocol(IP_PROT_UDP);
        ipControlInfo-&gt;setSrcAddr(udpCtrl-&gt;getSrcAddr().get4());
        ipControlInfo-&gt;setDestAddr(udpCtrl-&gt;getDestAddr().get4());
        ipControlInfo-&gt;setInterfaceId(udpCtrl-&gt;getInterfaceId());
        udpPacket-&gt;setControlInfo(ipControlInfo);
        <span class="keyword">delete</span> udpCtrl;

        send(udpPacket,<span class="stringliteral">&quot;ipOut&quot;</span>);
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">// send to IPv6</span>
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Sending app packet &quot;</span> &lt;&lt; appData-&gt;getName() &lt;&lt; <span class="stringliteral">&quot; over IPv6.\n&quot;</span>;
        <a class="code" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *ipControlInfo = <span class="keyword">new</span> <a class="code" href="class_i_pv6_control_info.html">IPv6ControlInfo</a>();
        ipControlInfo-&gt;setProtocol(IP_PROT_UDP);
        ipControlInfo-&gt;setSrcAddr(udpCtrl-&gt;getSrcAddr().get6());
        ipControlInfo-&gt;setDestAddr(udpCtrl-&gt;getDestAddr().get6());
        <span class="comment">// ipControlInfo-&gt;setInterfaceId(udpCtrl-&gt;InterfaceId()); FIXME extend IPv6 with this!!!</span>
        udpPacket-&gt;setControlInfo(ipControlInfo);
        <span class="keyword">delete</span> udpCtrl;

        send(udpPacket,<span class="stringliteral">&quot;ipv6Out&quot;</span>);
    }
    <a class="code" href="class_u_d_p.html#aa7f7b7568b014af23fb3f7c2efc218c1">numSent</a>++;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a333fddcf308d3c6348c9cc5e6bfa796d"></a><!-- doxytag: member="UDP::processUDPPacket" ref="a333fddcf308d3c6348c9cc5e6bfa796d" args="(UDPPacket *udpPacket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UDP::processUDPPacket </td>
          <td>(</td>
          <td class="paramtype">UDPPacket *&#160;</td>
          <td class="paramname"><em>udpPacket</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a79daccc47126abbf6740b029d7a57089">handleMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// simulate checksum: discard packet if it has bit error</span>
    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Packet &quot;</span> &lt;&lt; udpPacket-&gt;getName() &lt;&lt; <span class="stringliteral">&quot; received from network, dest port &quot;</span> &lt;&lt; udpPacket-&gt;getDestinationPort() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
    <span class="keywordflow">if</span> (udpPacket-&gt;hasBitError())
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Packet has bit error, discarding\n&quot;</span>;
        <span class="keyword">delete</span> udpPacket;
        <a class="code" href="class_u_d_p.html#a9ed09aeb9c434f9c7931dc82d3b2d34c">numDroppedBadChecksum</a>++;
        <span class="keywordflow">return</span>;
    }

    <span class="keywordtype">int</span> destPort = udpPacket-&gt;getDestinationPort();
    cPolymorphic *ctrl = udpPacket-&gt;removeControlInfo();

    <span class="comment">// send back ICMP error if no socket is bound to that port</span>
    SocketsByPortMap::iterator it = <a class="code" href="class_u_d_p.html#af6f8ebb75300e83c3b28ba5bd0ed585d">socketsByPortMap</a>.find(destPort);
    <span class="keywordflow">if</span> (it==<a class="code" href="class_u_d_p.html#af6f8ebb75300e83c3b28ba5bd0ed585d">socketsByPortMap</a>.end())
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;No socket registered on port &quot;</span> &lt;&lt; destPort &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
        <a class="code" href="class_u_d_p.html#a5a411e560693182d2cde11ab5566e1fc">processUndeliverablePacket</a>(udpPacket, ctrl);
        <span class="keywordflow">return</span>;
    }
    <a class="code" href="class_u_d_p.html#a17d5eac534fa0d896ceef2831cd28d77">SockDescList</a>&amp; list = it-&gt;second;

    <span class="keywordtype">int</span> matches = 0;

    <span class="comment">// deliver a copy of the packet to each matching socket</span>
    cPacket *payload = udpPacket-&gt;getEncapsulatedPacket();
    <span class="keywordflow">if</span> (dynamic_cast&lt;IPControlInfo *&gt;(ctrl)!=NULL)
    {
        <a class="code" href="class_i_p_control_info.html">IPControlInfo</a> *ctrl4 = (<a class="code" href="class_i_p_control_info.html">IPControlInfo</a> *)ctrl;
        <span class="keywordflow">for</span> (SockDescList::iterator it=list.begin(); it!=list.end(); ++it)
        {
            SockDesc *sd = *it;
            <span class="keywordflow">if</span> (sd-&gt;onlyLocalPortIsSet || <a class="code" href="class_u_d_p.html#a7e436c2b0a7b563bae29603603422cc0">matchesSocket</a>(sd, udpPacket, ctrl4))
            {
                <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Socket sockId=&quot;</span> &lt;&lt; sd-&gt;sockId &lt;&lt; <span class="stringliteral">&quot; matches, sending up a copy.\n&quot;</span>;
                <a class="code" href="class_u_d_p.html#affa73f57d52206f4aa5bc2539ac63c0f">sendUp</a>((cPacket*)payload-&gt;dup(), udpPacket, ctrl4, sd);
                matches++;
            }
        }
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;IPv6ControlInfo *&gt;(ctrl)!=NULL)
    {
        <a class="code" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *ctrl6 = (<a class="code" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *)ctrl;
        <span class="keywordflow">for</span> (SockDescList::iterator it=list.begin(); it!=list.end(); ++it)
        {
            SockDesc *sd = *it;
            <span class="keywordflow">if</span> (sd-&gt;onlyLocalPortIsSet || <a class="code" href="class_u_d_p.html#a7e436c2b0a7b563bae29603603422cc0">matchesSocket</a>(sd, udpPacket, ctrl6))
            {
                <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Socket sockId=&quot;</span> &lt;&lt; sd-&gt;sockId &lt;&lt; <span class="stringliteral">&quot; matches, sending up a copy.\n&quot;</span>;
                <a class="code" href="class_u_d_p.html#affa73f57d52206f4aa5bc2539ac63c0f">sendUp</a>((cPacket*)payload-&gt;dup(), udpPacket, ctrl6, sd);
                matches++;
            }
        }
    }
    <span class="keywordflow">else</span>
    {
        error(<span class="stringliteral">&quot;(%s)%s arrived from lower layer without control info&quot;</span>, udpPacket-&gt;getClassName(), udpPacket-&gt;getName());
    }

    <span class="comment">// send back ICMP error if there is no matching socket</span>
    <span class="keywordflow">if</span> (matches==0)
    {
        <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;None of the sockets on port &quot;</span> &lt;&lt; destPort &lt;&lt; <span class="stringliteral">&quot; matches the packet\n&quot;</span>;
        <a class="code" href="class_u_d_p.html#a5a411e560693182d2cde11ab5566e1fc">processUndeliverablePacket</a>(udpPacket, ctrl);
        <span class="keywordflow">return</span>;
    }

    <span class="keyword">delete</span> udpPacket;
    <span class="keyword">delete</span> ctrl;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5a411e560693182d2cde11ab5566e1fc"></a><!-- doxytag: member="UDP::processUndeliverablePacket" ref="a5a411e560693182d2cde11ab5566e1fc" args="(UDPPacket *udpPacket, cPolymorphic *ctrl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UDP::processUndeliverablePacket </td>
          <td>(</td>
          <td class="paramtype">UDPPacket *&#160;</td>
          <td class="paramname"><em>udpPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cPolymorphic *&#160;</td>
          <td class="paramname"><em>ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a333fddcf308d3c6348c9cc5e6bfa796d">processUDPPacket()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_u_d_p.html#ac262e3d6e3c88dbb2ff457c1c8837162">numDroppedWrongPort</a>++;

    <span class="comment">// send back ICMP PORT_UNREACHABLE</span>
    <span class="keywordflow">if</span> (dynamic_cast&lt;IPControlInfo *&gt;(ctrl)!=NULL)
    {
        <span class="keywordflow">if</span> (!<a class="code" href="structicmp.html">icmp</a>)
            <a class="code" href="structicmp.html">icmp</a> = <a class="code" href="class_i_c_m_p_access.html">ICMPAccess</a>().<a class="code" href="class_module_access.html#a44956ddb52973612afbba0eeecf8bb66">get</a>();
        <a class="code" href="class_i_p_control_info.html">IPControlInfo</a> *ctrl4 = (<a class="code" href="class_i_p_control_info.html">IPControlInfo</a> *)ctrl;
        <span class="keywordflow">if</span> (!ctrl4-&gt;getDestAddr().isMulticast())
            <a class="code" href="structicmp.html">icmp</a>-&gt;sendErrorMessage(udpPacket, ctrl4, ICMP_DESTINATION_UNREACHABLE, ICMP_DU_PORT_UNREACHABLE);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;IPv6ControlInfo *&gt;(udpPacket-&gt;getControlInfo())!=NULL)
    {
        <span class="keywordflow">if</span> (!<a class="code" href="class_u_d_p.html#a63a772449305921a2f57b9066336c389">icmpv6</a>)
            <a class="code" href="class_u_d_p.html#a63a772449305921a2f57b9066336c389">icmpv6</a> = <a class="code" href="class_i_c_m_pv6_access.html">ICMPv6Access</a>().<a class="code" href="class_module_access.html#a44956ddb52973612afbba0eeecf8bb66">get</a>();
        <a class="code" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *ctrl6 = (<a class="code" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *)ctrl;
        <span class="keywordflow">if</span> (!ctrl6-&gt;getDestAddr().isMulticast())
            <a class="code" href="class_u_d_p.html#a63a772449305921a2f57b9066336c389">icmpv6</a>-&gt;<a class="code" href="class_i_c_m_pv6.html#a3968b2c9964bb40a3d14b3fda9fdbba5">sendErrorMessage</a>(udpPacket, ctrl6, ICMPv6_DESTINATION_UNREACHABLE, PORT_UNREACHABLE);
    }
    <span class="keywordflow">else</span>
    {
        error(<span class="stringliteral">&quot;(%s)%s arrived from lower layer without control info&quot;</span>, udpPacket-&gt;getClassName(), udpPacket-&gt;getName());
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac693a0a152b8577d646493c325f15b45"></a><!-- doxytag: member="UDP::sendUp" ref="ac693a0a152b8577d646493c325f15b45" args="(cPacket *payload, UDPPacket *udpHeader, IPv6ControlInfo *ctrl, SockDesc *sd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UDP::sendUp </td>
          <td>(</td>
          <td class="paramtype">cPacket *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UDPPacket *&#160;</td>
          <td class="paramname"><em>udpHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&#160;</td>
          <td class="paramname"><em>ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_u_d_p_1_1_sock_desc.html">SockDesc</a> *&#160;</td>
          <td class="paramname"><em>sd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="comment">// send payload with UDPControlInfo up to the application -- IPv6 version</span>
    UDPControlInfo *udpCtrl = <span class="keyword">new</span> UDPControlInfo();
    udpCtrl-&gt;setSockId(sd-&gt;sockId);
    udpCtrl-&gt;setUserId(sd-&gt;userId);
    udpCtrl-&gt;setSrcAddr(ipCtrl-&gt;getSrcAddr());
    udpCtrl-&gt;setDestAddr(ipCtrl-&gt;getDestAddr());
    udpCtrl-&gt;setSrcPort(udpHeader-&gt;getSourcePort());
    udpCtrl-&gt;setDestPort(udpHeader-&gt;getDestinationPort());
    udpCtrl-&gt;setInterfaceId(ipCtrl-&gt;getInterfaceId());
    payload-&gt;setControlInfo(udpCtrl);

    send(payload, <span class="stringliteral">&quot;appOut&quot;</span>, sd-&gt;appGateIndex);
    <a class="code" href="class_u_d_p.html#ab6bee27f7907a894de4173e003adbd69">numPassedUp</a>++;
}
</pre></div>
</div>
</div>
<a class="anchor" id="affa73f57d52206f4aa5bc2539ac63c0f"></a><!-- doxytag: member="UDP::sendUp" ref="affa73f57d52206f4aa5bc2539ac63c0f" args="(cPacket *payload, UDPPacket *udpHeader, IPControlInfo *ctrl, SockDesc *sd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UDP::sendUp </td>
          <td>(</td>
          <td class="paramtype">cPacket *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UDPPacket *&#160;</td>
          <td class="paramname"><em>udpHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_p_control_info.html">IPControlInfo</a> *&#160;</td>
          <td class="paramname"><em>ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_u_d_p_1_1_sock_desc.html">SockDesc</a> *&#160;</td>
          <td class="paramname"><em>sd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a333fddcf308d3c6348c9cc5e6bfa796d">processUDPPacket()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// send payload with UDPControlInfo up to the application -- IPv4 version</span>
    UDPControlInfo *udpCtrl = <span class="keyword">new</span> UDPControlInfo();
    udpCtrl-&gt;setSockId(sd-&gt;sockId);
    udpCtrl-&gt;setUserId(sd-&gt;userId);
    udpCtrl-&gt;setSrcAddr(ipCtrl-&gt;getSrcAddr());
    udpCtrl-&gt;setDestAddr(ipCtrl-&gt;getDestAddr());
    udpCtrl-&gt;setSrcPort(udpHeader-&gt;getSourcePort());
    udpCtrl-&gt;setDestPort(udpHeader-&gt;getDestinationPort());
    udpCtrl-&gt;setInterfaceId(ipCtrl-&gt;getInterfaceId());
    payload-&gt;setControlInfo(udpCtrl);

    send(payload, <span class="stringliteral">&quot;appOut&quot;</span>, sd-&gt;appGateIndex);
    <a class="code" href="class_u_d_p.html#ab6bee27f7907a894de4173e003adbd69">numPassedUp</a>++;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa6d3f6a65fcb255abab778a7f13ca771"></a><!-- doxytag: member="UDP::sendUpErrorNotification" ref="aa6d3f6a65fcb255abab778a7f13ca771" args="(SockDesc *sd, int msgkind, const IPvXAddress &amp;localAddr, const IPvXAddress &amp;remoteAddr, ushort remotePort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UDP::sendUpErrorNotification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_d_p_1_1_sock_desc.html">SockDesc</a> *&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>msgkind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_pv_x_address.html">IPvXAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>localAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_pv_x_address.html">IPvXAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>remoteAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_i_n_e_t_defs_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a>&#160;</td>
          <td class="paramname"><em>remotePort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a8f0e27d03d3e209f437bfa72dd3efe38">processICMPError()</a>.</p>
<div class="fragment"><pre class="fragment">{
    cPacket *notifyMsg = <span class="keyword">new</span> cPacket(<span class="stringliteral">&quot;ERROR&quot;</span>, msgkind);
    UDPControlInfo *udpCtrl = <span class="keyword">new</span> UDPControlInfo();
    udpCtrl-&gt;setSockId(sd-&gt;sockId);
    udpCtrl-&gt;setUserId(sd-&gt;userId);
    udpCtrl-&gt;setSrcAddr(localAddr);
    udpCtrl-&gt;setDestAddr(remoteAddr);
    udpCtrl-&gt;setSrcPort(sd-&gt;localPort);
    udpCtrl-&gt;setDestPort(remotePort);
    notifyMsg-&gt;setControlInfo(udpCtrl);

    send(notifyMsg, <span class="stringliteral">&quot;appOut&quot;</span>, sd-&gt;appGateIndex);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a92b95e9e592cd6beff8f0b20228bc214"></a><!-- doxytag: member="UDP::unbind" ref="a92b95e9e592cd6beff8f0b20228bc214" args="(int sockId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UDP::unbind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sockId</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#ae251c9826aa3b5242ad02d6620ea2616">processCommandFromApp()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// remove from socketsByIdMap</span>
    SocketsByIdMap::iterator it = <a class="code" href="class_u_d_p.html#a7019475e3a2bd786a634fbbe72aa91c6">socketsByIdMap</a>.find(sockId);
    <span class="keywordflow">if</span> (it==<a class="code" href="class_u_d_p.html#a7019475e3a2bd786a634fbbe72aa91c6">socketsByIdMap</a>.end())
        error(<span class="stringliteral">&quot;socket id=%d doesn&#39;t exist (already closed?)&quot;</span>, sockId);
    SockDesc *sd = it-&gt;second;
    <a class="code" href="class_u_d_p.html#a7019475e3a2bd786a634fbbe72aa91c6">socketsByIdMap</a>.erase(it);

    <a class="code" href="_i_n_e_t_defs_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Unbinding socket: &quot;</span> &lt;&lt; *sd &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

    <span class="comment">// remove from socketsByPortMap</span>
    <a class="code" href="class_u_d_p.html#a17d5eac534fa0d896ceef2831cd28d77">SockDescList</a>&amp; list = <a class="code" href="class_u_d_p.html#af6f8ebb75300e83c3b28ba5bd0ed585d">socketsByPortMap</a>[sd-&gt;localPort];
    <span class="keywordflow">for</span> (SockDescList::iterator it=list.begin(); it!=list.end(); ++it)
        <span class="keywordflow">if</span> (*it == sd)
            {list.erase(it); <span class="keywordflow">break</span>;}
    <span class="keywordflow">if</span> (list.empty())
        <a class="code" href="class_u_d_p.html#af6f8ebb75300e83c3b28ba5bd0ed585d">socketsByPortMap</a>.erase(sd-&gt;localPort);
    <span class="keyword">delete</span> sd;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5c2df70abc011c2753a47cbff187a306"></a><!-- doxytag: member="UDP::updateDisplayString" ref="a5c2df70abc011c2753a47cbff187a306" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UDP::updateDisplayString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a79daccc47126abbf6740b029d7a57089">handleMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">char</span> buf[80];
    sprintf(buf, <span class="stringliteral">&quot;passed up: %d pks\nsent: %d pks&quot;</span>, <a class="code" href="class_u_d_p.html#ab6bee27f7907a894de4173e003adbd69">numPassedUp</a>, <a class="code" href="class_u_d_p.html#aa7f7b7568b014af23fb3f7c2efc218c1">numSent</a>);
    <span class="keywordflow">if</span> (<a class="code" href="class_u_d_p.html#ac262e3d6e3c88dbb2ff457c1c8837162">numDroppedWrongPort</a>&gt;0)
    {
        sprintf(buf+strlen(buf), <span class="stringliteral">&quot;\ndropped (no app): %d pks&quot;</span>, <a class="code" href="class_u_d_p.html#ac262e3d6e3c88dbb2ff457c1c8837162">numDroppedWrongPort</a>);
        getDisplayString().setTagArg(<span class="stringliteral">&quot;i&quot;</span>,1,<span class="stringliteral">&quot;red&quot;</span>);
    }
    getDisplayString().setTagArg(<span class="stringliteral">&quot;t&quot;</span>,0,buf);
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a4995c941113ffc075a8a4b6051fb1ca4"></a><!-- doxytag: member="UDP::icmp" ref="a4995c941113ffc075a8a4b6051fb1ca4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_c_m_p.html">ICMP</a>* <a class="el" href="class_u_d_p.html#a4995c941113ffc075a8a4b6051fb1ca4">UDP::icmp</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a63a772449305921a2f57b9066336c389"></a><!-- doxytag: member="UDP::icmpv6" ref="a63a772449305921a2f57b9066336c389" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_c_m_pv6.html">ICMPv6</a>* <a class="el" href="class_u_d_p.html#a63a772449305921a2f57b9066336c389">UDP::icmpv6</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a9ff0a87c6965238d54bb67997d6912ca">initialize()</a>, and <a class="el" href="class_u_d_p.html#a5a411e560693182d2cde11ab5566e1fc">processUndeliverablePacket()</a>.</p>

</div>
</div>
<a class="anchor" id="a277fa200fd58e593bc1263149ce85831"></a><!-- doxytag: member="UDP::lastEphemeralPort" ref="a277fa200fd58e593bc1263149ce85831" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_i_n_e_t_defs_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a> <a class="el" href="class_u_d_p.html#a277fa200fd58e593bc1263149ce85831">UDP::lastEphemeralPort</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a28ca0f88569dadf1b8f5eaad7e039c49">getEphemeralPort()</a>, and <a class="el" href="class_u_d_p.html#a9ff0a87c6965238d54bb67997d6912ca">initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ed09aeb9c434f9c7931dc82d3b2d34c"></a><!-- doxytag: member="UDP::numDroppedBadChecksum" ref="a9ed09aeb9c434f9c7931dc82d3b2d34c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_u_d_p.html#a9ed09aeb9c434f9c7931dc82d3b2d34c">UDP::numDroppedBadChecksum</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a9ff0a87c6965238d54bb67997d6912ca">initialize()</a>, and <a class="el" href="class_u_d_p.html#a333fddcf308d3c6348c9cc5e6bfa796d">processUDPPacket()</a>.</p>

</div>
</div>
<a class="anchor" id="ac262e3d6e3c88dbb2ff457c1c8837162"></a><!-- doxytag: member="UDP::numDroppedWrongPort" ref="ac262e3d6e3c88dbb2ff457c1c8837162" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_u_d_p.html#ac262e3d6e3c88dbb2ff457c1c8837162">UDP::numDroppedWrongPort</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a9ff0a87c6965238d54bb67997d6912ca">initialize()</a>, <a class="el" href="class_u_d_p.html#a5a411e560693182d2cde11ab5566e1fc">processUndeliverablePacket()</a>, and <a class="el" href="class_u_d_p.html#a5c2df70abc011c2753a47cbff187a306">updateDisplayString()</a>.</p>

</div>
</div>
<a class="anchor" id="ab6bee27f7907a894de4173e003adbd69"></a><!-- doxytag: member="UDP::numPassedUp" ref="ab6bee27f7907a894de4173e003adbd69" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_u_d_p.html#ab6bee27f7907a894de4173e003adbd69">UDP::numPassedUp</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a9ff0a87c6965238d54bb67997d6912ca">initialize()</a>, <a class="el" href="class_u_d_p.html#affa73f57d52206f4aa5bc2539ac63c0f">sendUp()</a>, and <a class="el" href="class_u_d_p.html#a5c2df70abc011c2753a47cbff187a306">updateDisplayString()</a>.</p>

</div>
</div>
<a class="anchor" id="aa7f7b7568b014af23fb3f7c2efc218c1"></a><!-- doxytag: member="UDP::numSent" ref="aa7f7b7568b014af23fb3f7c2efc218c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_u_d_p.html#aa7f7b7568b014af23fb3f7c2efc218c1">UDP::numSent</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a9ff0a87c6965238d54bb67997d6912ca">initialize()</a>, <a class="el" href="class_u_d_p.html#a1d2e34c55abb9e373694d77d3bac8f09">processMsgFromApp()</a>, and <a class="el" href="class_u_d_p.html#a5c2df70abc011c2753a47cbff187a306">updateDisplayString()</a>.</p>

</div>
</div>
<a class="anchor" id="a7019475e3a2bd786a634fbbe72aa91c6"></a><!-- doxytag: member="UDP::socketsByIdMap" ref="a7019475e3a2bd786a634fbbe72aa91c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_u_d_p.html#a68d5e94d3be14183856abf7f7ac8002a">SocketsByIdMap</a> <a class="el" href="class_u_d_p.html#a7019475e3a2bd786a634fbbe72aa91c6">UDP::socketsByIdMap</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a7ad4f9f51d27f92e0d23041f9b64a896">bind()</a>, <a class="el" href="class_u_d_p.html#a9fb94355db86e280d8de7b1ef7ced43c">connect()</a>, <a class="el" href="class_u_d_p.html#a9ff0a87c6965238d54bb67997d6912ca">initialize()</a>, <a class="el" href="class_u_d_p.html#a92b95e9e592cd6beff8f0b20228bc214">unbind()</a>, and <a class="el" href="class_u_d_p.html#ac9c6eaf3e5f1bd64ea3ac0552137ca0e">~UDP()</a>.</p>

</div>
</div>
<a class="anchor" id="af6f8ebb75300e83c3b28ba5bd0ed585d"></a><!-- doxytag: member="UDP::socketsByPortMap" ref="af6f8ebb75300e83c3b28ba5bd0ed585d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_u_d_p.html#a829a029b999e1f99838cd59e10eab3a9">SocketsByPortMap</a> <a class="el" href="class_u_d_p.html#af6f8ebb75300e83c3b28ba5bd0ed585d">UDP::socketsByPortMap</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="class_u_d_p.html#a7ad4f9f51d27f92e0d23041f9b64a896">bind()</a>, <a class="el" href="class_u_d_p.html#a28ca0f88569dadf1b8f5eaad7e039c49">getEphemeralPort()</a>, <a class="el" href="class_u_d_p.html#a9ff0a87c6965238d54bb67997d6912ca">initialize()</a>, <a class="el" href="class_u_d_p.html#a8f0e27d03d3e209f437bfa72dd3efe38">processICMPError()</a>, <a class="el" href="class_u_d_p.html#a333fddcf308d3c6348c9cc5e6bfa796d">processUDPPacket()</a>, and <a class="el" href="class_u_d_p.html#a92b95e9e592cd6beff8f0b20228bc214">unbind()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_u_d_p_8h.html">UDP.h</a></li>
<li><a class="el" href="_u_d_p_8cc.html">UDP.cc</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="class_u_d_p.html">UDP</a>      </li>
      <li class="footer">Generated on Fri Nov 18 2011 12:47:17 for INET Framework for OMNeT++/OMNEST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>

</body>
</html>
