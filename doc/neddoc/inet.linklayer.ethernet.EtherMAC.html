<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
      <link rel="stylesheet" type="text/css" href="style.css" />
   </head>
   <body onload="if (top.frames['componentsframe'] == undefined) { s = window.location.toString(); window.location = 'index.html?p=' + s.substring(s.lastIndexOf('/')+1); }">
<h2 class="comptitle">Simple Module <i>EtherMAC</i></h2>
<b>Package:</b> inet.linklayer.ethernet<br/><b>File: <a href="src-linklayer-ethernet-EtherMAC.ned.html">src/linklayer/ethernet/EtherMAC.ned</a></b><br/><p><a href="../doxy/class_ether_m_a_c.html" target="mainframe"><b>C++ definition</b></a></p>

<p>Ethernet MAC layer. MAC performs transmission and reception of frames.
See the <a href="inet.linklayer.IEtherMAC.html">IEtherMAC</a> for the Ethernet MAC layer general informations.
Doesn't do encapsulation/decapsulation; see <a href="inet.linklayer.ethernet.EtherLLC.html">EtherLLC</a> and <a href="inet.linklayer.ethernet.EtherEncap.html">EtherEncap</a> for
that.</p>
<p>Supported variations:</p>
  <ul><li>10Mb Ethernet (duplex and half-duplex, coaxial cable or twisted pair)</li>
  <li>100Mb Ethernet (duplex and half-duplex)</li>
  <li>1Gb Ethernet (duplex and half-duplex)</li>
  <li>10Gb Ethernet</li>
  <li>40Gb Ethernet</li>
  <li>100Gb Ethernet</li></ul>
<p>Supports all three Ethernet frame types. (It handles <a href="EtherFrame.html">EtherFrame</a> message class;
specific frame classes (Ethernet-II, IEEE 802.3) are subclassed from that one.)
RAW mode (only used by the IPX protocol) is not supported.</p>
<p>Expected environment:</p>
  <ul><li>phys$i and phys$o should be connected to the "network"</li>
  <li>upperLayerIn and upperLayerOut are usually connected to <a href="inet.linklayer.ethernet.EtherLLC.html">EtherLLC</a> (in hosts)
  or <a href="inet.linklayer.ethernet.switch.MACRelayUnitPP.html">MACRelayUnitPP</a> (in a switch)</li></ul>
<p><b>Operation</b></p>
<p>Processing of frames received from higher layers:</p>
  <ul><li>if src address in the frame is empty, fill it out</li>
  <li>frames get queued up until transmission</li>
  <li>transmit according to the CSMA/CD protocol</li>
  <li>can send PAUSE message if requested by higher layers (PAUSE protocol,
  used in switches).</li></ul>
<p>Processing of frames incoming from the network:</p>
  <ul><li>receive according to the CSMA/CD protocol</li>
  <li>CRC checking (frames with the error bit set are discarded).</li>
  <li>respond to PAUSE frames</li>
  <li>in promiscuous mode, pass up all received frames;
  otherwise, only frames with matching MAC addresses and
  broadcast frames are passed up.</li></ul>
<p>The module does not perform encapsulation or decapsulation of frames --
this is done by higher layers (<a href="inet.linklayer.ethernet.EtherLLC.html">EtherLLC</a> or <a href="inet.linklayer.ethernet.EtherEncap.html">EtherEncap</a>).</p>
<p>When a frame is received from the higher layers, it must be an <a href="EtherFrame.html">EtherFrame</a>,
and with all protocol fields filled out
(including the destination MAC address). The source address, if left empty,
will be filled in. Then frame is queued and transmitted according
to the CSMA/CD protocol.</p>
<p>Data frames received from the network are EtherFrames. They are passed to
the higher layers without modification.
Also, the module properly responds to PAUSE frames, but never sends them
by itself -- however, it transmits PAUSE frames received from upper layers.
See <a href="ether-pause.html">PAUSE handling</a> for more info.</p>
<p>For more info see <a href="ether-overview.html">Ethernet Model Overview</a>.</p>
<p><b>Disabling and disconnecting</b></p>
<p>If the MAC is not connected to the network ("cable unplugged"), it will
start up in "disabled" mode. A disabled MAC simply discards any messages
it receives. It is currently not supported to dynamically connect/disconnect
a MAC.</p>
<p><b>Queueing</b></p>
<p>In routers, MAC relies on an external queue module (see <a href="inet.linklayer.IOutputQueue.html">IOutputQueue</a>)
to model finite buffer, implement QoS and/or RED, and requests packets
from this external queue one-by-one.</p>
<p>In hosts, no such queue is used, so MAC contains an internal
queue named txQueue to queue up packets waiting for transmission.
Conceptually, txQueue is of infinite size, but for better diagnostics
one can specify a hard limit in the txQueueLimit parameter -- if this is
exceeded, the simulation stops with an error.</p>
<p><b>Physical layer messaging</b></p>
<p>Please see <a href="physical.html">Messaging on the physical layer</a>.</p>
<p><b>See also:</b> <a href="inet.linklayer.ethernet.EtherMACFullDuplex.html">EtherMACFullDuplex</a>, <a href="inet.linklayer.ethernet.EthernetInterface.html">EthernetInterface</a>, <a href="inet.linklayer.IOutputQueue.html">IOutputQueue</a>, <a href="inet.linklayer.ethernet.EtherEncap.html">EtherEncap</a>, <a href="inet.linklayer.ethernet.EtherLLC.html">EtherLLC</a></p>
<p><b>See also:</b> <a href="EtherFrame.html">EtherFrame</a>, <a href="EthernetIIFrame.html">EthernetIIFrame</a>, <a href="EtherFrameWithLLC.html">EtherFrameWithLLC</a>, <a href="Ieee802Ctrl.html">Ieee802Ctrl</a></p>
<img src="inet.linklayer.ethernet.EtherMAC-type.png" ismap="yes" usemap="#type-diagram"/><map name="type-diagram">
<area shape="rect" href="inet.linklayer.ethernet.EtherMAC.html" title="EtherMAC" alt="EtherMAC" coords="0,30,102,70">
</map>
<h3 class="subtitle">Usage diagram:</h3>
<p>The following diagram shows usage relationships between types.
Unresolved types are missing from the diagram.</p>
<img src="inet.linklayer.ethernet.EtherMAC-usage.png" ismap="yes" usemap="#usage-diagram"/><map name="usage-diagram"><area shape="rect" id="node1" href="inet.linklayer.ethernet.EtherMAC.html" title="Simple Module EtherMAC" alt="" coords="5,6,88,34">
</map>
<h3 class="subtitle">Inheritance diagram:</h3>
<p>The following diagram shows inheritance relationships for this type.
Unresolved types are missing from the diagram.</p>
<img src="inet.linklayer.ethernet.EtherMAC-inheritance.png" ismap="yes" usemap="#inheritance-diagram"/><map name="inheritance-diagram"><area shape="rect" id="node1" href="inet.linklayer.ethernet.EtherMAC.html" title="Simple Module EtherMAC" alt="" coords="7,83,89,111">
<area shape="rect" id="node2" href="inet.linklayer.IEtherMAC.html" title="Module Interface IEtherMAC" alt="" coords="5,6,91,34">
</map>
<h3 class="subtitle">Parameters:</h3>
<table class="paramstable">
   <tr>
      <th class="name">Name</th>
      <th class="type">Type</th>
      <th class="defaultvalue">Default value</th>
      <th class="description">Description</th>
   </tr>
<tr class="local">
   <td>promiscuous</td>
   <td>
      <i>bool</i>
   </td>
   <td>false</td>
   <td>
<p>if true, all packets are received, otherwise only the
ones with matching destination MAC address</p>
   </td>
</tr>
<tr class="local">
   <td>address</td>
   <td>
      <i>string</i>
   </td>
   <td>"auto"</td>
   <td>
<p>MAC address as hex string (12 hex digits), or
"auto". "auto" values will be replaced by
a generated MAC address in init stage 0.</p>
   </td>
</tr>
<tr class="local">
   <td>duplexMode</td>
   <td>
      <i>bool</i>
   </td>
   <td>true</td>
   <td>
<p>selects full-duplex (true) or half-duplex (false) operation</p>
   </td>
</tr>
<tr class="local">
   <td>txQueueLimit</td>
   <td>
      <i>int</i>
   </td>
   <td>1000</td>
   <td>
<p>maximum number of frames queued up for transmission in the internal queue (only used if queueModule==""); additional frames cause a runtime error</p>
   </td>
</tr>
<tr class="local">
   <td>queueModule</td>
   <td>
      <i>string</i>
   </td>
   <td>""</td>
   <td>
<p>name of optional external queue module</p>
   </td>
</tr>
<tr class="local">
   <td>frameBursting</td>
   <td>
      <i>bool</i>
   </td>
   <td>true</td>
   <td>
<p>enable/disable frame bursting mode in Gigabit Ethernet</p>
   </td>
</tr>
<tr class="local">
   <td>mtu</td>
   <td>
      <i>int</i>
   </td>
   <td>1500B</td>
   <td>   </td>
</tr>
</table>
<h3 class="subtitle">Properties:</h3>
<table class="propertiestable">
   <tr>
      <th class="name">Name</th>
      <th class="value">Value</th>
      <th class="description">Description</th>
   </tr>
<tr>
   <td>display</td>
   <td><i>i=block/rxtx</i></td>
   <td>
</td>
</tr>
</table>
<h3 class="subtitle">Gates:</h3>
<table class="gatestable">
   <tr>
      <th class="name">Name</th>
      <th class="type">Direction</th>
      <th class="gatesize">Size</th>
      <th class="description">Description</th>
   </tr>
<tr class="local">
   <td>upperLayerIn</xsl:if></td>
   <td><i>input</i></td>
   <td></td>   <td>
<p>to <a href="inet.linklayer.ethernet.EtherLLC.html">EtherLLC</a> or <a href="inet.linklayer.ethernet.EtherEncap.html">EtherEncap</a> or <a href="inet.linklayer.ethernet.switch.MACRelayUnitPP.html">MACRelayUnitPP</a></p>
</td>
</tr>
<tr class="local">
   <td>upperLayerOut</xsl:if></td>
   <td><i>output</i></td>
   <td></td>   <td>
<p>to <a href="inet.linklayer.ethernet.EtherLLC.html">EtherLLC</a> or <a href="inet.linklayer.ethernet.EtherEncap.html">EtherEncap</a> or <a href="inet.linklayer.ethernet.switch.MACRelayUnitPP.html">MACRelayUnitPP</a></p>
</td>
</tr>
<tr class="local">
   <td>phys</xsl:if></td>
   <td><i>inout</i></td>
   <td></td>   <td>
<p>to physical layer or the network</p>
</td>
</tr>
</table>
<h3 class="subtitle">Signals:</h3>
<table class="signalstable">
   <tr>
      <th class="name">Name</th>
      <th class="type">Type</th>
      <th class="unit">Unit</th>
   </tr>
<tr class="local">
   <td>rxPausePkUnits</td>
   <td><i>
long   </i></td>
   <td></td>
</tr>
<tr class="local">
   <td>packetReceivedFromUpper</td>
   <td><i>
<a href="../doxy/class_ether_frame.html" target="mainframe">EtherFrame</a>   </i></td>
   <td></td>
</tr>
<tr class="local">
   <td>backoff</td>
   <td><i>
long   </i></td>
   <td></td>
</tr>
<tr class="local">
   <td>dropPkNotForUs</td>
   <td><i>
<a href="../doxy/class_ether_frame.html" target="mainframe">EtherFrame</a>   </i></td>
   <td></td>
</tr>
<tr class="local">
   <td>rxPkOk</td>
   <td><i>
<a href="../doxy/class_ether_frame.html" target="mainframe">EtherFrame</a>   </i></td>
   <td></td>
</tr>
<tr class="local">
   <td>txPausePkUnits</td>
   <td><i>
long   </i></td>
   <td></td>
</tr>
<tr class="local">
   <td>packetSentToLower</td>
   <td><i>
<a href="../doxy/class_ether_frame.html" target="mainframe">EtherFrame</a>   </i></td>
   <td></td>
</tr>
<tr class="local">
   <td>txPk</td>
   <td><i>
<a href="../doxy/class_ether_frame.html" target="mainframe">EtherFrame</a>   </i></td>
   <td></td>
</tr>
<tr class="local">
   <td>packetSentToUpper</td>
   <td><i>
<a href="../doxy/class_ether_frame.html" target="mainframe">EtherFrame</a>   </i></td>
   <td></td>
</tr>
<tr class="local">
   <td>packetReceivedFromLower</td>
   <td><i>
<a href="../doxy/class_ether_frame.html" target="mainframe">EtherFrame</a>   </i></td>
   <td></td>
</tr>
<tr class="local">
   <td>dropPkIfaceDown</td>
   <td><i>
<a href="../doxy/class_ether_traffic.html" target="mainframe">EtherTraffic</a>   </i></td>
   <td></td>
</tr>
<tr class="local">
   <td>collision</td>
   <td><i>
long   </i></td>
   <td></td>
</tr>
<tr class="local">
   <td>rxPkFromHL</td>
   <td><i>
<a href="../doxy/class_ether_frame.html" target="mainframe">EtherFrame</a>   </i></td>
   <td></td>
</tr>
<tr class="local">
   <td>dropPkBitError</td>
   <td><i>
<a href="../doxy/class_ether_frame.html" target="mainframe">EtherFrame</a>   </i></td>
   <td></td>
</tr>
<tr class="local">
   <td>dropPkFromHLIfaceDown</td>
   <td><i>
<a href="../doxy/class_ether_frame.html" target="mainframe">EtherFrame</a>   </i></td>
   <td></td>
</tr>
</table>
<h3 class="subtitle">Statistics:</h3>
<table class="statisticstable">
   <tr>
      <th class="name">Name</th>
      <th class="title">Title</th>
      <th class="source">Source</th>
      <th class="record">Record</th>
      <th class="unit">Unit</th>
      <th class="interpolationmode">Interpolation Mode</th>
   </tr>
<tr class="local">
   <td>txPausePkUnits</td>
   <td>pause units sent</td>
   <td></td>
   <td>count, sum, vector</td>
   <td></td>
   <td>none</td>
</tr>
<tr class="local">
   <td>txPk</td>
   <td>packets transmitted</td>
   <td>txPk</td>
   <td>count, sum(packetBytes), vector(packetBytes)</td>
   <td></td>
   <td>none</td>
</tr>
<tr class="local">
   <td>droppedPkBitError</td>
   <td>packets dropped/bit error</td>
   <td>dropPkBitError</td>
   <td>count, sum(packetBytes), vector(packetBytes)</td>
   <td></td>
   <td>none</td>
</tr>
<tr class="local">
   <td>droppedPkIfaceDown</td>
   <td>packets dropped/interface down</td>
   <td>dropPkIfaceDown</td>
   <td>count, sum(packetBytes), vector(packetBytes)</td>
   <td></td>
   <td>none</td>
</tr>
<tr class="local">
   <td>rxPausePkUnits</td>
   <td>pause units received</td>
   <td></td>
   <td>count, sum, vector</td>
   <td></td>
   <td>none</td>
</tr>
<tr class="local">
   <td>backoff</td>
   <td>backoff</td>
   <td></td>
   <td>count, vector</td>
   <td></td>
   <td>none</td>
</tr>
<tr class="local">
   <td>droppedPkNotForUs</td>
   <td>packets dropped/not for us</td>
   <td>dropPkNotForUs</td>
   <td>count, sum(packetBytes), vector(packetBytes)</td>
   <td></td>
   <td>none</td>
</tr>
<tr class="local">
   <td>collision</td>
   <td>collision</td>
   <td></td>
   <td>count, vector</td>
   <td></td>
   <td>none</td>
</tr>
<tr class="local">
   <td>rxPkOk</td>
   <td>packets received OK</td>
   <td>rxPkOk</td>
   <td>count, sum(packetBytes), vector(packetBytes)</td>
   <td></td>
   <td>none</td>
</tr>
<tr class="local">
   <td>rxPkFromHL</td>
   <td>packet bytes from higher layer</td>
   <td>rxPkFromHL</td>
   <td>count, sum(packetBytes), vector(packetBytes)</td>
   <td></td>
   <td>none</td>
</tr>
<tr class="local">
   <td>passedUpPk</td>
   <td>packets passed to higher layer</td>
   <td>packetSentToUpper</td>
   <td>count, sum(packetBytes), vector(packetBytes)</td>
   <td></td>
   <td>none</td>
</tr>
</table>
<h3 class="subtitle">Source code:</h3>
<pre class="src"><span style="color: #808080; font-style: italic; ">//
// Ethernet MAC layer. MAC performs transmission and reception of frames.
// See the ~IEtherMAC for the Ethernet MAC layer general informations.
// Doesn't do encapsulation/decapsulation; see ~EtherLLC and ~EtherEncap for
// that.
//
// Supported variations:
// - 10Mb Ethernet (duplex and half-duplex, coaxial cable or twisted pair)
// - 100Mb Ethernet (duplex and half-duplex)
// - 1Gb Ethernet (duplex and half-duplex)
// - 10Gb Ethernet
// - 40Gb Ethernet
// - 100Gb Ethernet
//
// Supports all three Ethernet frame types. (It handles ~EtherFrame message class;
// specific frame classes (Ethernet-II, IEEE 802.3) are subclassed from that one.)
// RAW mode (only used by the IPX protocol) is not supported.
//
// Expected environment:
// - phys$i and phys$o should be connected to the &quot;network&quot;
// - upperLayerIn and upperLayerOut are usually connected to ~EtherLLC (in hosts)
//   or ~MACRelayUnitPP (in a switch)
//
// </span><span style="color: #800000; ">&lt;b&gt;</span><span style="color: #808080; font-style: italic; ">Operation</span><span style="color: #800000; ">&lt;/b&gt;</span><span style="color: #808080; font-style: italic; ">
//
// Processing of frames received from higher layers:
// - if src address in the frame is empty, fill it out
// - frames get queued up until transmission
// - transmit according to the CSMA/CD protocol
// - can send PAUSE message if requested by higher layers (PAUSE protocol,
//   used in switches).
//
// Processing of frames incoming from the network:
// - receive according to the CSMA/CD protocol
// - CRC checking (frames with the error bit set are discarded).
// - respond to PAUSE frames
// - in promiscuous mode, pass up all received frames;
//   otherwise, only frames with matching MAC addresses and
//   broadcast frames are passed up.
//
// The module does not perform encapsulation or decapsulation of frames --
// this is done by higher layers (~EtherLLC or ~EtherEncap).
//
// When a frame is received from the higher layers, it must be an ~EtherFrame,
// and with all protocol fields filled out
// (including the destination MAC address). The source address, if left empty,
// will be filled in. Then frame is queued and transmitted according
// to the CSMA/CD protocol.
//
// Data frames received from the network are EtherFrames. They are passed to
// the higher layers without modification.
// Also, the module properly responds to PAUSE frames, but never sends them
// by itself -- however, it transmits PAUSE frames received from upper layers.
// See </span><span style="color: #800000; ">&lt;a href=&quot;ether-pause.html&quot;&gt;</span><span style="color: #808080; font-style: italic; ">PAUSE handling</span><span style="color: #800000; ">&lt;/a&gt;</span><span style="color: #808080; font-style: italic; "> for more info.
//
// For more info see </span><span style="color: #800000; ">&lt;a href=&quot;ether-overview.html&quot;&gt;</span><span style="color: #808080; font-style: italic; ">Ethernet Model Overview</span><span style="color: #800000; ">&lt;/a&gt;</span><span style="color: #808080; font-style: italic; ">.
//
// </span><span style="color: #800000; ">&lt;b&gt;</span><span style="color: #808080; font-style: italic; ">Disabling and disconnecting</span><span style="color: #800000; ">&lt;/b&gt;</span><span style="color: #808080; font-style: italic; ">
//
// If the MAC is not connected to the network (&quot;cable unplugged&quot;), it will
// start up in &quot;disabled&quot; mode. A disabled MAC simply discards any messages
// it receives. It is currently not supported to dynamically connect/disconnect
// a MAC.
//
//
// </span><span style="color: #800000; ">&lt;b&gt;</span><span style="color: #808080; font-style: italic; ">Queueing</span><span style="color: #800000; ">&lt;/b&gt;</span><span style="color: #808080; font-style: italic; ">
//
// In routers, MAC relies on an external queue module (see ~IOutputQueue)
// to model finite buffer, implement QoS and/or RED, and requests packets
// from this external queue one-by-one.
//
// In hosts, no such queue is used, so MAC contains an internal
// queue named txQueue to queue up packets waiting for transmission.
// Conceptually, txQueue is of infinite size, but for better diagnostics
// one can specify a hard limit in the txQueueLimit parameter -- if this is
// exceeded, the simulation stops with an error.
//
//
// </span><span style="color: #800000; ">&lt;b&gt;</span><span style="color: #808080; font-style: italic; ">Physical layer messaging</span><span style="color: #800000; ">&lt;/b&gt;</span><span style="color: #808080; font-style: italic; ">
//
// Please see </span><span style="color: #800000; ">&lt;a href=&quot;physical.html&quot;&gt;</span><span style="color: #808080; font-style: italic; ">Messaging on the physical layer</span><span style="color: #800000; ">&lt;/a&gt;</span><span style="color: #808080; font-style: italic; ">.
//
// </span><span style="color: #000080; ">@see</span><span style="color: #808080; font-style: italic; "> ~EtherMACFullDuplex, ~EthernetInterface, ~IOutputQueue, ~EtherEncap, ~EtherLLC
// </span><span style="color: #000080; ">@see</span><span style="color: #808080; font-style: italic; "> ~EtherFrame, ~EthernetIIFrame, ~EtherFrameWithLLC, ~Ieee802Ctrl
//
</span><span style="color: #800000; font-weight: bold; ">simple</span><span style="color: #000000; "> </span><span style="color: #000000; ">EtherMAC</span><span style="color: #000000; "> </span><span style="color: #800000; font-weight: bold; ">like</span><span style="color: #000000; "> </span><span style="color: #000000; ">IEtherMAC</span><span style="color: #000000; ">
{
    </span><span style="color: #800000; font-weight: bold; ">parameters</span><span style="color: #000000; ">:
        </span><span style="color: #000080; font-weight: bold; ">bool</span><span style="color: #000000; "> </span><span style="color: #000000; ">promiscuous</span><span style="color: #000000; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #000000; ">(</span><span style="color: #008000; ">false</span><span style="color: #000000; ">);  </span><span style="color: #808080; font-style: italic; ">// if true, all packets are received, otherwise only the
</span><span style="color: #000000; ">                                            </span><span style="color: #808080; font-style: italic; ">// ones with matching destination MAC address
</span><span style="color: #000000; ">        </span><span style="color: #000080; font-weight: bold; ">string</span><span style="color: #000000; "> </span><span style="color: #000000; ">address</span><span style="color: #000000; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #000000; ">(</span><span style="color: #008000; ">&quot;auto&quot;</span><span style="color: #000000; ">);   </span><span style="color: #808080; font-style: italic; ">// MAC address as hex string (12 hex digits), or
</span><span style="color: #000000; ">                                            </span><span style="color: #808080; font-style: italic; ">// &quot;auto&quot;. &quot;auto&quot; values will be replaced by
</span><span style="color: #000000; ">                                            </span><span style="color: #808080; font-style: italic; ">// a generated MAC address in init stage 0.
</span><span style="color: #000000; ">        </span><span style="color: #000080; font-weight: bold; ">bool</span><span style="color: #000000; "> </span><span style="color: #000000; ">duplexMode</span><span style="color: #000000; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #000000; ">(</span><span style="color: #008000; ">true</span><span style="color: #000000; ">);    </span><span style="color: #808080; font-style: italic; ">// selects full-duplex (true) or half-duplex (false) operation
</span><span style="color: #000000; ">        </span><span style="color: #000080; font-weight: bold; ">int</span><span style="color: #000000; "> </span><span style="color: #000000; ">txQueueLimit</span><span style="color: #000000; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #000000; ">(</span><span style="color: #008000; ">1000</span><span style="color: #000000; ">);   </span><span style="color: #808080; font-style: italic; ">// maximum number of frames queued up for transmission in the internal queue (only used if queueModule==&quot;&quot;); additional frames cause a runtime error
</span><span style="color: #000000; ">        </span><span style="color: #000080; font-weight: bold; ">string</span><span style="color: #000000; "> </span><span style="color: #000000; ">queueModule</span><span style="color: #000000; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #000000; ">(</span><span style="color: #008000; ">&quot;&quot;</span><span style="color: #000000; ">);   </span><span style="color: #808080; font-style: italic; ">// name of optional external queue module
</span><span style="color: #000000; ">        </span><span style="color: #000080; font-weight: bold; ">bool</span><span style="color: #000000; "> </span><span style="color: #000000; ">frameBursting</span><span style="color: #000000; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #000000; ">(</span><span style="color: #008000; ">true</span><span style="color: #000000; ">); </span><span style="color: #808080; font-style: italic; ">// enable/disable frame bursting mode in Gigabit Ethernet
</span><span style="color: #000000; ">        </span><span style="color: #000080; font-weight: bold; ">int</span><span style="color: #000000; "> </span><span style="color: #000000; ">mtu</span><span style="color: #000000; "> </span><span style="color: #000000; font-weight: bold; ">@unit</span><span style="color: #000000; ">(</span><span style="color: #008000; ">&quot;B&quot;</span><span style="color: #000000; ">) = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #000000; ">(</span><span style="color: #008000; ">1500</span><span style="color: #000000; ">B</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@display</span><span style="color: #000000; ">(</span><span style="color: #008000; ">&quot;i=block/rxtx&quot;</span><span style="color: #000000; ">);

        </span><span style="color: #000000; font-weight: bold; ">@signal</span><span style="color: #000000; ">[</span><span style="color: #000000; ">txPk</span><span style="color: #000000; ">](</span><span style="color: #000000; ">type</span><span style="color: #000000; ">=</span><span style="color: #000000; ">EtherFrame</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@signal</span><span style="color: #000000; ">[</span><span style="color: #000000; ">rxPkOk</span><span style="color: #000000; ">](</span><span style="color: #000000; ">type</span><span style="color: #000000; ">=</span><span style="color: #000000; ">EtherFrame</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@signal</span><span style="color: #000000; ">[</span><span style="color: #000000; ">txPausePkUnits</span><span style="color: #000000; ">](</span><span style="color: #000000; ">type</span><span style="color: #000000; ">=</span><span style="color: #000000; ">long</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@signal</span><span style="color: #000000; ">[</span><span style="color: #000000; ">rxPausePkUnits</span><span style="color: #000000; ">](</span><span style="color: #000000; ">type</span><span style="color: #000000; ">=</span><span style="color: #000000; ">long</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@signal</span><span style="color: #000000; ">[</span><span style="color: #000000; ">rxPkFromHL</span><span style="color: #000000; ">](</span><span style="color: #000000; ">type</span><span style="color: #000000; ">=</span><span style="color: #000000; ">EtherFrame</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@signal</span><span style="color: #000000; ">[</span><span style="color: #000000; ">dropPkNotForUs</span><span style="color: #000000; ">](</span><span style="color: #000000; ">type</span><span style="color: #000000; ">=</span><span style="color: #000000; ">EtherFrame</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@signal</span><span style="color: #000000; ">[</span><span style="color: #000000; ">dropPkBitError</span><span style="color: #000000; ">](</span><span style="color: #000000; ">type</span><span style="color: #000000; ">=</span><span style="color: #000000; ">EtherFrame</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@signal</span><span style="color: #000000; ">[</span><span style="color: #000000; ">dropPkFromHLIfaceDown</span><span style="color: #000000; ">](</span><span style="color: #000000; ">type</span><span style="color: #000000; ">=</span><span style="color: #000000; ">EtherFrame</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@signal</span><span style="color: #000000; ">[</span><span style="color: #000000; ">dropPkIfaceDown</span><span style="color: #000000; ">](</span><span style="color: #000000; ">type</span><span style="color: #000000; ">=</span><span style="color: #000000; ">EtherTraffic</span><span style="color: #000000; ">);        </span><span style="color: #808080; font-style: italic; ">// emitted at begin of receiving
</span><span style="color: #000000; ">        </span><span style="color: #000000; font-weight: bold; ">@signal</span><span style="color: #000000; ">[</span><span style="color: #000000; ">packetSentToLower</span><span style="color: #000000; ">](</span><span style="color: #000000; ">type</span><span style="color: #000000; ">=</span><span style="color: #000000; ">EtherFrame</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@signal</span><span style="color: #000000; ">[</span><span style="color: #000000; ">packetReceivedFromLower</span><span style="color: #000000; ">](</span><span style="color: #000000; ">type</span><span style="color: #000000; ">=</span><span style="color: #000000; ">EtherFrame</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@signal</span><span style="color: #000000; ">[</span><span style="color: #000000; ">packetSentToUpper</span><span style="color: #000000; ">](</span><span style="color: #000000; ">type</span><span style="color: #000000; ">=</span><span style="color: #000000; ">EtherFrame</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@signal</span><span style="color: #000000; ">[</span><span style="color: #000000; ">packetReceivedFromUpper</span><span style="color: #000000; ">](</span><span style="color: #000000; ">type</span><span style="color: #000000; ">=</span><span style="color: #000000; ">EtherFrame</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@signal</span><span style="color: #000000; ">[</span><span style="color: #000000; ">collision</span><span style="color: #000000; ">](</span><span style="color: #000000; ">type</span><span style="color: #000000; ">=</span><span style="color: #000000; ">long</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@signal</span><span style="color: #000000; ">[</span><span style="color: #000000; ">backoff</span><span style="color: #000000; ">](</span><span style="color: #000000; ">type</span><span style="color: #000000; ">=</span><span style="color: #000000; ">long</span><span style="color: #000000; ">);

        </span><span style="color: #000000; font-weight: bold; ">@statistic</span><span style="color: #000000; ">[</span><span style="color: #000000; ">txPk</span><span style="color: #000000; ">](</span><span style="color: #000000; ">title</span><span style="color: #000000; ">=</span><span style="color: #008000; ">&quot;packets transmitted&quot;</span><span style="color: #000000; ">; </span><span style="color: #000000; ">source</span><span style="color: #000000; ">=</span><span style="color: #000000; ">txPk</span><span style="color: #000000; ">; </span><span style="color: #000000; ">record</span><span style="color: #000000; ">=</span><span style="color: #000000; ">count</span><span style="color: #000000; ">,</span><span style="color: #008000; ">&quot;sum(packetBytes)&quot;</span><span style="color: #000000; ">,</span><span style="color: #008000; ">&quot;vector(packetBytes)&quot;</span><span style="color: #000000; ">; </span><span style="color: #000000; ">interpolationmode</span><span style="color: #000000; ">=</span><span style="color: #000000; ">none</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@statistic</span><span style="color: #000000; ">[</span><span style="color: #000000; ">rxPkOk</span><span style="color: #000000; ">](</span><span style="color: #000000; ">title</span><span style="color: #000000; ">=</span><span style="color: #008000; ">&quot;packets received OK&quot;</span><span style="color: #000000; ">; </span><span style="color: #000000; ">source</span><span style="color: #000000; ">=</span><span style="color: #000000; ">rxPkOk</span><span style="color: #000000; ">; </span><span style="color: #000000; ">record</span><span style="color: #000000; ">=</span><span style="color: #000000; ">count</span><span style="color: #000000; ">,</span><span style="color: #008000; ">&quot;sum(packetBytes)&quot;</span><span style="color: #000000; ">,</span><span style="color: #008000; ">&quot;vector(packetBytes)&quot;</span><span style="color: #000000; ">; </span><span style="color: #000000; ">interpolationmode</span><span style="color: #000000; ">=</span><span style="color: #000000; ">none</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@statistic</span><span style="color: #000000; ">[</span><span style="color: #000000; ">passedUpPk</span><span style="color: #000000; ">](</span><span style="color: #000000; ">title</span><span style="color: #000000; ">=</span><span style="color: #008000; ">&quot;packets passed to higher layer&quot;</span><span style="color: #000000; ">; </span><span style="color: #000000; ">source</span><span style="color: #000000; ">=</span><span style="color: #000000; ">packetSentToUpper</span><span style="color: #000000; ">; </span><span style="color: #000000; ">record</span><span style="color: #000000; ">=</span><span style="color: #000000; ">count</span><span style="color: #000000; ">,</span><span style="color: #008000; ">&quot;sum(packetBytes)&quot;</span><span style="color: #000000; ">,</span><span style="color: #008000; ">&quot;vector(packetBytes)&quot;</span><span style="color: #000000; ">; </span><span style="color: #000000; ">interpolationmode</span><span style="color: #000000; ">=</span><span style="color: #000000; ">none</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@statistic</span><span style="color: #000000; ">[</span><span style="color: #000000; ">txPausePkUnits</span><span style="color: #000000; ">](</span><span style="color: #000000; ">title</span><span style="color: #000000; ">=</span><span style="color: #008000; ">&quot;pause units sent&quot;</span><span style="color: #000000; ">; </span><span style="color: #000000; ">record</span><span style="color: #000000; ">=</span><span style="color: #000000; ">count</span><span style="color: #000000; ">,</span><span style="color: #000000; ">sum</span><span style="color: #000000; ">,</span><span style="color: #000000; ">vector</span><span style="color: #000000; ">; </span><span style="color: #000000; ">interpolationmode</span><span style="color: #000000; ">=</span><span style="color: #000000; ">none</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@statistic</span><span style="color: #000000; ">[</span><span style="color: #000000; ">rxPausePkUnits</span><span style="color: #000000; ">](</span><span style="color: #000000; ">title</span><span style="color: #000000; ">=</span><span style="color: #008000; ">&quot;pause units received&quot;</span><span style="color: #000000; ">; </span><span style="color: #000000; ">record</span><span style="color: #000000; ">=</span><span style="color: #000000; ">count</span><span style="color: #000000; ">,</span><span style="color: #000000; ">sum</span><span style="color: #000000; ">,</span><span style="color: #000000; ">vector</span><span style="color: #000000; ">; </span><span style="color: #000000; ">interpolationmode</span><span style="color: #000000; ">=</span><span style="color: #000000; ">none</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@statistic</span><span style="color: #000000; ">[</span><span style="color: #000000; ">rxPkFromHL</span><span style="color: #000000; ">](</span><span style="color: #000000; ">title</span><span style="color: #000000; ">=</span><span style="color: #008000; ">&quot;packet bytes from higher layer&quot;</span><span style="color: #000000; ">; </span><span style="color: #000000; ">source</span><span style="color: #000000; ">=</span><span style="color: #000000; ">rxPkFromHL</span><span style="color: #000000; ">; </span><span style="color: #000000; ">record</span><span style="color: #000000; ">=</span><span style="color: #000000; ">count</span><span style="color: #000000; ">,</span><span style="color: #008000; ">&quot;sum(packetBytes)&quot;</span><span style="color: #000000; ">,</span><span style="color: #008000; ">&quot;vector(packetBytes)&quot;</span><span style="color: #000000; ">; </span><span style="color: #000000; ">interpolationmode</span><span style="color: #000000; ">=</span><span style="color: #000000; ">none</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@statistic</span><span style="color: #000000; ">[</span><span style="color: #000000; ">droppedPkIfaceDown</span><span style="color: #000000; ">](</span><span style="color: #000000; ">title</span><span style="color: #000000; ">=</span><span style="color: #008000; ">&quot;packets dropped/interface down&quot;</span><span style="color: #000000; ">; </span><span style="color: #000000; ">source</span><span style="color: #000000; ">=</span><span style="color: #000000; ">dropPkIfaceDown</span><span style="color: #000000; ">; </span><span style="color: #000000; ">record</span><span style="color: #000000; ">=</span><span style="color: #000000; ">count</span><span style="color: #000000; ">,</span><span style="color: #008000; ">&quot;sum(packetBytes)&quot;</span><span style="color: #000000; ">,</span><span style="color: #008000; ">&quot;vector(packetBytes)&quot;</span><span style="color: #000000; ">; </span><span style="color: #000000; ">interpolationmode</span><span style="color: #000000; ">=</span><span style="color: #000000; ">none</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@statistic</span><span style="color: #000000; ">[</span><span style="color: #000000; ">droppedPkBitError</span><span style="color: #000000; ">](</span><span style="color: #000000; ">title</span><span style="color: #000000; ">=</span><span style="color: #008000; ">&quot;packets dropped/bit error&quot;</span><span style="color: #000000; ">; </span><span style="color: #000000; ">source</span><span style="color: #000000; ">=</span><span style="color: #000000; ">dropPkBitError</span><span style="color: #000000; ">; </span><span style="color: #000000; ">record</span><span style="color: #000000; ">=</span><span style="color: #000000; ">count</span><span style="color: #000000; ">,</span><span style="color: #008000; ">&quot;sum(packetBytes)&quot;</span><span style="color: #000000; ">,</span><span style="color: #008000; ">&quot;vector(packetBytes)&quot;</span><span style="color: #000000; ">; </span><span style="color: #000000; ">interpolationmode</span><span style="color: #000000; ">=</span><span style="color: #000000; ">none</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@statistic</span><span style="color: #000000; ">[</span><span style="color: #000000; ">droppedPkNotForUs</span><span style="color: #000000; ">](</span><span style="color: #000000; ">title</span><span style="color: #000000; ">=</span><span style="color: #008000; ">&quot;packets dropped/not for us&quot;</span><span style="color: #000000; ">; </span><span style="color: #000000; ">source</span><span style="color: #000000; ">=</span><span style="color: #000000; ">dropPkNotForUs</span><span style="color: #000000; ">; </span><span style="color: #000000; ">record</span><span style="color: #000000; ">=</span><span style="color: #000000; ">count</span><span style="color: #000000; ">,</span><span style="color: #008000; ">&quot;sum(packetBytes)&quot;</span><span style="color: #000000; ">,</span><span style="color: #008000; ">&quot;vector(packetBytes)&quot;</span><span style="color: #000000; ">; </span><span style="color: #000000; ">interpolationmode</span><span style="color: #000000; ">=</span><span style="color: #000000; ">none</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@statistic</span><span style="color: #000000; ">[</span><span style="color: #000000; ">collision</span><span style="color: #000000; ">](</span><span style="color: #000000; ">title</span><span style="color: #000000; ">=</span><span style="color: #008000; ">&quot;collision&quot;</span><span style="color: #000000; ">; </span><span style="color: #000000; ">record</span><span style="color: #000000; ">=</span><span style="color: #000000; ">count</span><span style="color: #000000; ">,</span><span style="color: #000000; ">vector</span><span style="color: #000000; ">; </span><span style="color: #000000; ">interpolationmode</span><span style="color: #000000; ">=</span><span style="color: #000000; ">none</span><span style="color: #000000; ">);
        </span><span style="color: #000000; font-weight: bold; ">@statistic</span><span style="color: #000000; ">[</span><span style="color: #000000; ">backoff</span><span style="color: #000000; ">](</span><span style="color: #000000; ">title</span><span style="color: #000000; ">=</span><span style="color: #008000; ">&quot;backoff&quot;</span><span style="color: #000000; ">; </span><span style="color: #000000; ">record</span><span style="color: #000000; ">=</span><span style="color: #000000; ">count</span><span style="color: #000000; ">,</span><span style="color: #000000; ">vector</span><span style="color: #000000; ">; </span><span style="color: #000000; ">interpolationmode</span><span style="color: #000000; ">=</span><span style="color: #000000; ">none</span><span style="color: #000000; ">);

    </span><span style="color: #800000; font-weight: bold; ">gates</span><span style="color: #000000; ">:
        </span><span style="color: #000080; font-weight: bold; ">input</span><span style="color: #000000; "> </span><span style="color: #000000; ">upperLayerIn</span><span style="color: #000000; "> </span><span style="color: #000000; font-weight: bold; ">@labels</span><span style="color: #000000; ">(</span><span style="color: #000000; ">EtherFrame</span><span style="color: #000000; ">);    </span><span style="color: #808080; font-style: italic; ">// to ~EtherLLC or ~EtherEncap or ~MACRelayUnitPP
</span><span style="color: #000000; ">        </span><span style="color: #000080; font-weight: bold; ">output</span><span style="color: #000000; "> </span><span style="color: #000000; ">upperLayerOut</span><span style="color: #000000; "> </span><span style="color: #000000; font-weight: bold; ">@labels</span><span style="color: #000000; ">(</span><span style="color: #000000; ">EtherFrame</span><span style="color: #000000; ">);  </span><span style="color: #808080; font-style: italic; ">// to ~EtherLLC or ~EtherEncap or ~MACRelayUnitPP
</span><span style="color: #000000; ">        </span><span style="color: #000080; font-weight: bold; ">inout</span><span style="color: #000000; "> </span><span style="color: #000000; ">phys</span><span style="color: #000000; "> </span><span style="color: #000000; font-weight: bold; ">@labels</span><span style="color: #000000; ">(</span><span style="color: #000000; ">EtherFrame</span><span style="color: #000000; ">); </span><span style="color: #808080; font-style: italic; ">// to physical layer or the network
</span><span style="color: #000000; ">}

</span></pre>
   </body>
</html>
