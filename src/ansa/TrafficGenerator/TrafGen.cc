//// Copyright 2011 Martin Danko//// This library is free software, you can redistribute it and/or modify// it under  the terms of the GNU Lesser General Public License// as published by the Free Software Foundation;// either version 2 of the License, or any later version.// The library is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.// See the GNU Lesser General Public License for more details.////#include <stdlib.h>#include <math.h>#include <fstream>#include "TrafGen.h"#include "InterfaceTableAccess.h"#include "IInterfaceTable.h"#include "IPv4InterfaceData.h"Define_Module(TrafGen);/* * initialize():  * Metoda pre inicializaciu modulu. * @param stage - aktualna sekvencia volania */void TrafGen::initialize(int stage){  if (stage == 4)  {          numSent = 0;    numReceived = 0;    counter = 0;    const char *fileName = par("flowDefFile");        // nacitanie konfiguracie tokov          if (fileName == NULL || (!strcmp(fileName, "")) || !LoadFlowsFromXML(fileName))        error("Error reading TrafGen flows from file %s", fileName);        // inicializacne procedury        detectRoles();    initTimers();    bindSockets();    initStats();        cMessage *timer = new cMessage("StatsTimer");    scheduleAt(1.0, timer);        // nastavenie statistik pre graficke rozhranie    WATCH(numSent);    WATCH(numReceived);    WATCH_VECTOR(sentStatistics);    WATCH_VECTOR(receivedStatistics);      }  else if( stage == 5)    installRcvStatIts(); }/* * LoadFlowsFromXML():  * Nacita konfiguraciu tokov zo XML suboru * @filename - nazov XML suboru * @return - vrati true pokial nacitanie prebehlo v poriadku  */bool TrafGen::LoadFlowsFromXML(const char * filename){  cXMLElement* trafgenConfig = ev.getXMLDocument(filename);  if (trafgenConfig == NULL)    error("Cannot read TrafGen flows configuration from file: %s", filename);  std::string nodeName = trafgenConfig->getTagName();  if(nodeName == "trafgen")  {      cXMLElementList flowsConfigList= trafgenConfig->getChildren();    for (cXMLElementList::iterator flowIt = flowsConfigList.begin(); flowIt != flowsConfigList.end(); flowIt++)    {      std::string elName = (*flowIt)->getTagName();      if (elName == "flow" && (*flowIt)->getAttribute("id"))        parseFlow(*(*flowIt));      else        error("Wrong flow definition");    }  }  else    return false;      if(flows.size() == 0)    return false;          return true;}/* * parseFlow():  * Zo XML suvboru rozparsuje a vyhodnoti konfiguraciu jedneho toku * @flowConfig - XML blok s konfiguraciou tokov  */void TrafGen::parseFlow(const cXMLElement& flowConfig){  TG::FlowRecord flw;  cXMLElement* element;    flw.setId(flowConfig.getAttribute("id"));    if(flw.getId() == "" || getFlowById(flw.getId()) != flows.end())  {    error("Missing or duplicate flow ID");    return;  }    element = flowConfig.getFirstChildWithTag("duration");  if(element != NULL)    flw.setDuration(atof(element->getNodeValue()));      element = flowConfig.getFirstChildWithTag("start_time");  if(element != NULL)    flw.setStartTime(atof(element->getNodeValue()));      cXMLElement* ipHeader = flowConfig.getFirstChildWithTag("ip_header");  if(ipHeader != NULL)  {    element = ipHeader->getFirstChildWithTag("source_ip");    if(element != NULL)      flw.setSrcIP(IPAddress(element->getNodeValue()));        element = ipHeader->getFirstChildWithTag("destination_ip");    if(element != NULL)      flw.setDstIP(IPAddress(element->getNodeValue()));        element = ipHeader->getFirstChildWithTag("tos");    if(element != NULL)      flw.setTos(readDscp(element->getNodeValue()));          element = ipHeader->getFirstChildWithTag("ttl");    if(element != NULL)      flw.setTtl(atoi(element->getNodeValue()));          element = ipHeader->getFirstChildWithTag("protocol");    if(element != NULL)    {      std::string prtStr = element->getNodeValue();      if (prtStr == "tcp" || prtStr == "Tcp" || prtStr == "TCP")        flw.setProtocol(IP_PROT_TCP);      else        flw.setProtocol(IP_PROT_UDP);    }  }    cXMLElement* transHeader = flowConfig.getFirstChildWithTag("transport_header");  if(ipHeader != NULL)  {    element = transHeader->getFirstChildWithTag("source_port");    if(element != NULL)      flw.setSrcPort(atoi(element->getNodeValue()));        element = transHeader->getFirstChildWithTag("destination_port");    if(element != NULL)      flw.setDstPort(atoi(element->getNodeValue()));  }    cXMLElement* appEl = flowConfig.getFirstChildWithTag("application");  if(appEl != NULL && appEl->getAttribute("type"))  {    if(!flw.setApplication(*appEl))      error("Wrong application configuration for flow with ID: %s", flw.getId().c_str());  }    if(!isValidFlow(flw))  {    error("Invalid definition of flow with ID: %s", flw.getId().c_str());    return;  }      flows.push_back(flw);}/* * isValidFlow():  * Zisti, ci dany tok je definovavy korektne * @return - Vrati true pokial je tok definovany korektne   */bool TrafGen::isValidFlow(TG::FlowRecord &flw){  if(flw.getSrcIP().get4() == IPAddress::UNSPECIFIED_ADDRESS)    return false;  if(flw.getDstIP().get4() == IPAddress::UNSPECIFIED_ADDRESS)    return false;  if(flw.getTtl() < 1)    return false;  if(flw.getSrcPort() < 1)    return false;  if(flw.getDstPort() < 1)    return false;      return true;    }/* * readDscp():  * Funkcia prevedie string z DSCP hodnotou na 8 bitovu hodotu ToS * @param dscpString	- retazec DSCP hodnoty * @return - Vrati hodnotu ToS zakodovanu v DSCP retazcu   */unsigned char TrafGen::readDscp(std::string dscpString){  if(dscpString.size() == 3)  {    std::string prf = dscpString.substr(0,2);    unsigned char cls = dscpString[2] - '0';    if((prf == "CS" || prf == "Cs" || prf == "cs") && cls > 0 && cls < 8)      return cls*32;   }  else if (dscpString.size() == 4)  {    std::string prf = dscpString.substr(0,2);    unsigned char cls =  dscpString[2] - '0';    unsigned char dp = dscpString[3] - '0';    if((prf == "AF" || prf == "Af" || prf == "af") && cls > 0 && cls < 5 && dp > 0 && dp < 4)      return cls*32 + dp*8;  }  else if(dscpString == "EF" || dscpString == "Ef" || dscpString == "ef")    return 184;  return atoi(dscpString.c_str());}/* * detectRoles():  * Zisti, ci dany modul pre konkretny tok je v ulohe generatora alebo analyzera */void TrafGen::detectRoles(){  IInterfaceTable *ift = InterfaceTableAccess().get();     for(TG::Flows::iterator it =  flows.begin(); it != flows.end(); ++it)  {    for(int i = 0; i < ift->getNumInterfaces(); ++i)    {      if(ift->getInterface(i)->ipv4Data()->getIPAddress() == it->getSrcIP().get4())        it->setGenerating(true);      if(ift->getInterface(i)->ipv4Data()->getIPAddress() == it->getDstIP().get4())        it->setAnalyzing(true);    }  }}/* * initTimers():  * Inicializuje casovace pre planovanie generovania tokov */void TrafGen::initTimers(){  for(TG::Flows::iterator it =  flows.begin(); it != flows.end(); ++it)  {    if(it->isGenerating() && it->getDuration() > 0.0)    {      cMessage *timer = new cMessage(it->getId().c_str());      scheduleAt(it->getStartTime(), timer);    }  }}/* * initStats():  * Inicializuje statistiky tokov */void TrafGen::initStats(){  for(TG::Flows::iterator it =  flows.begin(); it != flows.end(); ++it)  {    if(it->isAnalyzing())    {      TG::RcvFlowRecord rr;      rr.setId(it->getId());      rr.setStartTime(it->getStartTime());      receivedStatistics.push_back(rr);      cOutVector* recVec1 = new cOutVector;      std::string vecName1 = "Flow " + it->getId() + " actual birate";       recVec1->setName(vecName1.c_str());      actBitrateVec[it->getId()] = recVec1;      cOutVector* recVec2 = new cOutVector;      std::string vecName2 = "Flow " + it->getId() + " actual packetrate";       recVec2->setName(vecName2.c_str());      actPacketrateVec[it->getId()] = recVec2;    }    if(it->isGenerating())    {      TG::SntFlowRecord sr;      sr.setId(it->getId());      sr.setStartTime(it->getStartTime());      sentStatistics.push_back(sr);    }  }}/* * bindSockets():  * Vytvori UDP/TCP sokety pre nasluchanie na potrebnom porte  */void TrafGen::bindSockets(){  for(TG::Flows::iterator it =  flows.begin(); it != flows.end(); ++it)  {    if(it->isAnalyzing())    {      if(it->getProtocol() == IP_PROT_UDP)      {        if(!isListening(IP_PROT_UDP, it->getDstPort()))        {          cMessage *msg = new cMessage("UDP_C_BIND", UDP_C_BIND);          UDPControlInfo *ctrl = new UDPControlInfo();          ctrl->setSockId(UDPSocket::generateSocketId());          ctrl->setSrcPort(it->getDstPort());          msg->setControlInfo(ctrl);          send(msg, "udpOut");          udpListenPort.push_back(it->getDstPort());        }      }      else if(it->getProtocol() == IP_PROT_TCP)      {        if(!isListening(IP_PROT_TCP, it->getDstPort()))        {          TCPSocket socket;          socket.setOutputGate(gate("tcpOut"));          socket.bind(it->getDstIP(), it->getDstPort());          socket.listen();          tcpListenPort.push_back(it->getDstPort());        }      }    }  }}/* * installRcvStatIts():  * Ku kazdemu generovanemu toku ziska ukazovatel do statistik prijemcu. * Dovodom je aby prijemca mal informacie o tom kolko paketov odosielatel vygeneroval  */void TrafGen::installRcvStatIts(){  cTopology topology;    topology.extractByNedTypeName(cStringTokenizer("inet.ansa.TrafficGenerator.TrafGen").asVector());    for(TG::Flows::iterator it =  flows.begin(); it != flows.end(); ++it)  {    if(it->isGenerating())    {      bool found = false;      for(int i = 0; i < topology.getNumNodes(); ++i)      {        cTopology::Node *node = topology.getNode(i);        TrafGen *tgpt = check_and_cast<TrafGen*> (node->getModule());        if(tgpt->getFlowById(it->getId())->isAnalyzing())        {          it->setRcvModStatsIt(tgpt->getRcvFlowStatById(it->getId()));          found = true;        }      }      if(!found)        error("Missing receiver for flow with ID: %s", it->getId().c_str());    }  }} /* * createPacket():  * Vygeneruje dalsi paket na odoslanie z daneho toku * @param flowIt - iterator na tok  * @return - Vrati ukazovatel na vytvoreny paket   */cPacket *TrafGen::createPacket(TG::Flows::iterator flowIt){    char msgName[32];    sprintf(msgName,"TrafGenPacket - Flow %s", flowIt->getId().c_str());        int totalDataLen = flowIt->getPApplication()->getPacketSize() + flowIt->getPApplication()->anotherEncapsulationOverhead();    // TrafGenPacket - nesie informacie o ID toku, nazvu aplikacie a casu zaslania    TrafGenPacket *payload = new TrafGenPacket(msgName);    payload->setFlowId(flowIt->getId().c_str());    payload->setApplication((flowIt->getAppName()).c_str());    payload->setSentTime(simTime().dbl());    payload->setByteLength(totalDataLen);    return payload;}/* * sendPacket():  * Funkcia posle paket toku urceneho parametrom * @param flowIt - iterator na tok  * @return - Vrati v pripade uspesneho odoslania   */bool TrafGen::sendPacket(TG::Flows::iterator flowIt){    cPacket *payload;        if (flowIt->getProtocol() == IP_PROT_UDP)    { // vygeneruje UDP paket      if (flowIt->getStartTime() + flowIt->getDuration() < simTime().dbl())        return false; // tok presiahol dobu generovania            // vytvorenie paketu       payload = createPacket(flowIt);            payload->setKind(UDP_C_DATA);      // pripojenie kontrolnych informacii      UDPControlInfo *ctrl = new UDPControlInfo();      ctrl->setSrcAddr(flowIt->getSrcIP());      ctrl->setSrcPort(flowIt->getSrcPort());      ctrl->setDestAddr(flowIt->getDstIP());      ctrl->setDestPort(flowIt->getDstPort());      payload->setControlInfo(ctrl);            send(payload, "udpOut");    }    else if (flowIt->getProtocol() == IP_PROT_TCP)    { // vygeneruje TCP paket      if (flowIt->getStartTime() + flowIt->getDuration() < simTime().dbl())      { // tok presiahol dobu generovania        flowIt->tcpClose();        return false;      }      else        {        if(!flowIt->isTcpConnected())	      { // pripojenie TCP v pripade, ze uz nie je pripojene          flowIt->tcpConnect(gate("tcpOut"));        }        // vytvorenie paketu a odoslanie        payload = createPacket(flowIt);        flowIt->sendTcpPacket(payload);      }    }        return true;    }/* * handleMessage():  * Spracuje prijatu pravu zo siete  * @msg - prijata sprava  */void TrafGen::processPacket(cMessage *msg){  if (msg->getKind() == UDP_I_ERROR && msg->getArrivalGate() == gate("udpIn"))	{ // chybny UDP paket -> je zahodeny		delete msg;	}  else if (msg->getKind()==TCP_I_PEER_CLOSED)  { // TCP spojenie zavrate protistranou    TCPCommand *controlInfo = check_and_cast<TCPCommand *>(msg->getControlInfo());    if(isLocalTcpOrig(controlInfo->getConnId()))    {      delete msg;    }    else    {      msg->setName("close");      msg->setKind(TCP_C_CLOSE);      send(msg, "tcpOut");    }  }  else if (msg->getKind() == UDP_I_DATA || msg->getKind()==TCP_I_DATA || msg->getKind()==TCP_I_URGENT_DATA)  { // paket je OK -> bude spracovany    TrafGenPacket *packet = check_and_cast<TrafGenPacket *>(msg);        // najde tok, do ktoreho paket patri    TG::Flows::iterator flowIt = getFlowById(packet->getFlowId());    if(flowIt != flows.end())    {      // najdes zaznam o statistikach daneho toku      TG::RcvStats::iterator flowStatIt = getRcvFlowStatById(flowIt->getId());      if(flowStatIt != receivedStatistics.end())      { // aktualizuje staisticke informacie toku        double actTime = simTime().dbl();        double delay = actTime - packet->getSentTime();        double jitter;          flowStatIt->setEndTime(actTime);                if(flowStatIt->getTotalRcvPkts() == 0)        {          flowStatIt->setStartTime(actTime);          flowStatIt->setMinDelay(delay);          flowStatIt->setMaxDelay(delay);          jitter = 0.0;        }        else          jitter = fabs(delay - (flowStatIt->getTotalDelay()/flowStatIt->getTotalRcvPkts()));                  if(flowStatIt->getMinDelay() > delay)          flowStatIt->setMinDelay(delay);        if(flowStatIt->getMaxDelay() < delay)          flowStatIt->setMaxDelay(delay);                  flowStatIt->addTotalDelay(delay);        flowStatIt->addTotalJitter(jitter);                      int dataLen = packet->getByteLength() - flowIt->getPApplication()->anotherEncapsulationOverhead();        flowStatIt->updateActVec(simTime().dbl(),dataLen);        flowStatIt->addTotalBytes(dataLen);        flowStatIt->addTotalRcvPkts();        numReceived++;      }    }    delete msg;  }  else  {     delete msg;  }}/* * handleMessage():  * Metoda spracuje prijatu spravu  * @msg - prijata sprava  */void TrafGen::handleMessage(cMessage *msg){   if (msg->isSelfMessage())    {           std::string mName = msg->getName();        if(mName == "StatsTimer")        {          updateActVectorStats();          scheduleAt(simTime() + 0.5 , msg);        }        else        {          // vyprsal timer -> dojde ku generovaniu dalsej spravy          TG::Flows::iterator flowIt = getFlowById(mName);          // vysle paket a naplanuje cas odoslania dalsieho paketu daneho toku          bool scheduleNext = sendPacket(flowIt);          if(scheduleNext)            scheduleAt(simTime()+ flowIt->getPApplication()->getNextPacketTime(), msg);          else            delete msg;        }    }    else    {        // spracuje prichadzajuci paket zo siete        processPacket(msg);    }}/* * finish():  * Metoda po skonceni simulacie vygeneruje statistiky tokov pre, ktore bol modul prijemca  */void TrafGen::finish(){  if(receivedStatistics.size() > 0)  {    std::ofstream outFile;    std::string moduleName = this->getParentModule()->getName();    std::string filename = "results/TrafGen-" + moduleName + ".txt";    outFile.open (filename.c_str());        int numFlows = 0;    double tStartTime = 0.0;    double tEndTime = 0.0;    double tMinDelay = 0.0;    double tMaxDelay = 0.0;    double tTotDelay = 0.0;    double tTotJitter = 0.0;    long tSent = 0;    long tReceived = 0;    long tBytes = 0;    long tDropped = 0;    long dropInFlow = 0;        for(TG::RcvStats::iterator it =  receivedStatistics.begin(); it != receivedStatistics.end(); ++it)    {      TG::Flows::iterator fit = getFlowById(it->getId());       outFile << "----------------------------------------------------------" << std::endl;      outFile << "Flow ID: " << it->getId() << std::endl;      outFile << "From:\t" << fit->getSrcIP().str() << ":" << fit->getSrcPort() << std::endl;      outFile << "To:\t" << fit->getDstIP().str() << ":" << fit->getDstPort() << std::endl;      if(fit->getProtocol() == IP_PROT_TCP)        outFile << "Protocol: TCP" << std::endl;      if(fit->getProtocol() == IP_PROT_UDP)        outFile << "Protocol: UDP" << std::endl;      outFile << "----------------------------------------------------------" << std::endl;      if(it->getTotalRcvPkts() > 0)      {         if(numFlows == 0)        {          tStartTime = it->getStartTime();          tEndTime = it->getEndTime();          tMinDelay = it->getMinDelay();          tMaxDelay = it->getMaxDelay();        }        else        {          if(tStartTime > it->getStartTime())            tStartTime = it->getStartTime();          if(tEndTime < it->getEndTime())            tEndTime = it->getEndTime();          if(tMinDelay > it->getMinDelay())            tMinDelay = it->getMinDelay();          if(tMaxDelay < it->getMaxDelay())            tMaxDelay = it->getMaxDelay();        }        dropInFlow = it->getTotalSentPkts() - it->getTotalRcvPkts();        tSent += it->getTotalSentPkts();        tTotDelay += it->getTotalDelay();        tTotJitter += it->getTotalJitter();        tReceived += it->getTotalRcvPkts();        tBytes += it->getTotalBytes();        tDropped += dropInFlow;        ++numFlows;                double duration = it->getEndTime() - it->getStartTime();        outFile << "Duration                 = " << duration << " s" << std::endl;         outFile << "Received packets         = " << it->getTotalRcvPkts() << std::endl;        outFile << "Minimum delay            = " << it->getMinDelay() << " s" << std::endl;        outFile << "Maximum delay            = " << it->getMaxDelay() << " s" << std::endl;        outFile << "Average delay            = " << it->getTotalDelay() / it->getTotalRcvPkts() << " s" << std::endl;        outFile << "Average jitter           = " << it->getTotalJitter() / it->getTotalRcvPkts() << " s" << std::endl;        outFile << "Bytes received           = " << it->getTotalBytes() << std::endl;        outFile << "Average bitrate          = " << (it->getTotalBytes() * 8)/(duration * 1000) << " Kbit/s" << std::endl;        outFile << "Average packet rate      = " << it->getTotalRcvPkts()/duration << " pkt/s" << std::endl;        outFile << "Packets dropped          = " << dropInFlow << std::endl;        outFile << "Percent dropped          = " << ((double)(dropInFlow* 100)) / it->getTotalSentPkts() << " %"<< std::endl;      }      else      {        outFile << "No received data yet" << std::endl;      }            outFile << "----------------------------------------------------------" << std::endl;          }    outFile << std::endl;       outFile << "__________________________________________________________" << std::endl;    outFile << "****************  TOTAL RESULTS   ******************" << std::endl;    outFile << "__________________________________________________________" << std::endl;    double duration = tEndTime - tStartTime;    outFile << "Number of flows          = " << numFlows << std::endl;    outFile << "Duration                 = " << duration << " s" << std::endl;     outFile << "Received packets         = " << tReceived << std::endl;    outFile << "Minimum delay            = " << tMinDelay << " s" << std::endl;    outFile << "Maximum delay            = " << tMaxDelay << " s" << std::endl;    outFile << "Average delay            = " << tTotDelay / tReceived << " s" << std::endl;    outFile << "Average jitter           = " << tTotJitter / tReceived << " s" << std::endl;    outFile << "Bytes received           = " << tBytes << std::endl;    outFile << "Average bitrate          = " << (tBytes * 8)/(duration * 1000) << " Kbit/s" << std::endl;    outFile << "Average packet rate      = " << tReceived/duration << " pkt/s" << std::endl;    outFile << "Packets dropped          = " << tDropped  << std::endl;    outFile << "Percent dropped          = " << ((double) (tDropped * 100 ))/ tSent << " %"<< std::endl;        outFile << "----------------------------------------------------------" << std::endl;        outFile.close();  }}/* * getFlowById():  * Funkcia najde tok podla jeho identifikatora * @param s_id - identifikator toku   * @return - Vrati itertor na zanam statistik   */TG::Flows::iterator TrafGen::getFlowById(std::string s_id){  for(TG::Flows::iterator it =  flows.begin(); it != flows.end(); ++it)  {    if(it->getId() == s_id)      return it;  }  return  flows.end();}/* * getSntFlowStatById():  * Funkcia najde podla identifikatora statisitiky odoslanych paketov daneho toku * @param s_id - identifikator toku   * @return - Vrati itertor na zanam statistik   */TG::SntStats::iterator TrafGen::getSntFlowStatById(std::string s_id){  for(TG::SntStats::iterator it =  sentStatistics.begin(); it != sentStatistics.end(); ++it)  {    if(it->getId() == s_id)      return it;  }  return  sentStatistics.end();}/* * getRcvFlowStatById():  * Funkcia najde podla identifikatora statisitiky prijatych paketov daneho toku * @param r_id - identifikator toku   * @return - Vrati itertor na zanam statistik   */TG::RcvStats::iterator TrafGen::getRcvFlowStatById(std::string r_id){  for(TG::RcvStats::iterator it =  receivedStatistics.begin(); it != receivedStatistics.end(); ++it)  {    if(it->getId() == r_id)      return it;  }  return  receivedStatistics.end();}/* * getDscpByFlowInfo():  * Funkcia zisti DSCP hodnotu toku podla danych parametrov  * @param srcAdd - zdrojova IP adresa toku * @param destAdd - cielova IP adresa toku  * @param prot - transportny protokol toku * @param srcPort - zdrojovy port toku * @param destPort - cielovy port toku    * @return - Vrati zistenu DSCP hodnotu   */unsigned char TrafGen::getDscpByFlowInfo(IPAddress &srcAdd,IPAddress &destAdd, short prot, int srcPort, int destPort){  for(TG::Flows::iterator it =  flows.begin(); it != flows.end(); ++it)  {    if(it->getSrcIP() == srcAdd && it->getDstIP() == destAdd && it->getProtocol() == prot)      if(it->getSrcPort() == srcPort && it->getDstPort() == destPort)        return it->getTos();  }  return  0;}/* * getTtlByFlowInfo():  * Funkcia zisti TTL hodnotu toku podla danych parametrov  * @param srcAdd - zdrojova IP adresa toku * @param destAdd - cielova IP adresa toku  * @param prot - transportny protokol toku * @param srcPort - zdrojovy port toku * @param destPort - cielovy port toku    * @return - Vrati zistenu ttl hodnotu   */short TrafGen::getTtlByFlowInfo(IPAddress &srcAdd,IPAddress &destAdd, short prot, int srcPort, int destPort){  for(TG::Flows::iterator it =  flows.begin(); it != flows.end(); ++it)  {    if(it->getSrcIP() == srcAdd && it->getDstIP() == destAdd && it->getProtocol() == prot)      if(it->getSrcPort() == srcPort && it->getDstPort() == destPort)        return it->getTtl();  }  return  32;}/* * isLocalTcpOrig():  * Funkcia zisti ci je povodcom TCP spojenie s danym ID  * @param id	- identifikator TCP spojenia * @return - Vrati true pokial je povodcom   */bool TrafGen::isLocalTcpOrig(int id){  for(TG::Flows::iterator it =  flows.begin(); it != flows.end(); ++it)  {    if(it->isSocketCreated())      if(it->getSocketConId() == id)        return true;  }  return false;}/* * isListening():  * Funkcia zisti ci na danm porte uz naslucha  * @param prot	- protokol (TCP/UDP) * @param port - port  * @return - Vrati true uz na dom porte danslucha   */bool TrafGen::isListening(short prot, int port){  std::vector<int>::iterator it;    if (prot == IP_PROT_UDP)  {    for(it=udpListenPort.begin(); it<udpListenPort.end(); ++it)      if(*it == port)        return true;  }  else if (prot == IP_PROT_TCP)  {    for(it=tcpListenPort.begin(); it<tcpListenPort.end(); ++it)      if(*it == port)        return true;  }  return false;  }void TrafGen::updateSentStats(cPacket * payload){  if(payload != NULL)  {    std::string type = payload->getClassName();    if(type == "TrafGenPacket")    {      TrafGenPacket *TGpacket = dynamic_cast<TrafGenPacket*> (payload);      TG::Flows::iterator flowIt = getFlowById(TGpacket->getFlowId());      // aktualizacia statistik odoslanych paketov      int appDataLen = TGpacket->getByteLength() - flowIt->getPApplication()->anotherEncapsulationOverhead();        getSntFlowStatById(flowIt->getId())->addTotalSentPkts();      getSntFlowStatById(flowIt->getId())->addTotalBytes(appDataLen);      flowIt->getRcvModStatsIt()->addTotalSentPkts();      numSent++;    }    delete payload;  }}/* * FlowRecord():  * Konstruktor zaznamu o toku - inicializuje premenne */TG::FlowRecord::FlowRecord(){  id.erase();  startTime = 0.0;  duration = 0.0;  srcIP = IPAddress::UNSPECIFIED_ADDRESS;  dstIP = IPAddress::UNSPECIFIED_ADDRESS;  tos = 0;  ttl = 0;  protocol = 0;  srcPort = 0;  dstPort = 0;    pApplication = NULL;  socket = NULL;    generating = false;  analyzing = false;}/* * setApplication():  * Funkcia pre dany tok vytvori objekt aplikacie a nacita jej konfiguraciu  * @param appConfig	- XML blok s konfiguraciu aplikacie * @return - Vrati true pokial bola aplikacia spravne nastavena   */bool TG::FlowRecord::setApplication(const cXMLElement& appConfig){  appName = appConfig.getAttribute("type");    pApplication = check_and_cast<ITrafGenApplication *>(createOne(appName.c_str()));    if(pApplication != NULL)    return pApplication->loadConfig(appConfig);    return false;    }/* * tcpConnect():  * Funkcia vytvory pre dany tok TCP spojenie  * @param toTcp	- ukazovatel na vystupnu branu k TCP modulu   */void TG::FlowRecord::tcpConnect(cGate *toTcp){  socket = new TCPSocket();  // nastavenie parametrov soketu  socket->bind(srcIP, srcPort);  socket->setOutputGate(toTcp);      // pripojenie TCP soketu   socket->connect(dstIP, dstPort);}/* * RcvFlowRecord():  * Konstruktor zaznomov o prijatych paketoch - nastavi hodnoty na nulu */TG::RcvFlowRecord::RcvFlowRecord(){  startTime = 0.0;  totalSentPkts = 0;  totalRcvPkts = 0;  minDelay = 0.0;  maxDelay = 0.0;  totalDelay = 0.0;  totalJitter = 0.0;  totalBytes = 0.0;}/* * ~TrafGen():  * Destruktor modulu - uvolni vektorove objekty pre zaznam statistik  */TrafGen::~TrafGen(){  std::map<std::string, cOutVector*>::iterator it;    for (it=actBitrateVec.begin(); it!=actBitrateVec.end(); ++it)    delete it->second;    actBitrateVec.clear();    for (it=actPacketrateVec.begin(); it!=actPacketrateVec.end(); ++it)    delete it->second;    actPacketrateVec.clear();  }/* * getActBitrate():  * Funkcia vrati aktualnu prenosovu rychlost za poslednu sekundu * @return - Vrati prenosovy rychlost   */double TG::RcvFlowRecord::getActBitrate(){  actualizeVector();  std::vector<PktRec>::iterator it;  double bitrate = 0.0;   for(it=actStat.begin(); it!=actStat.end(); ++it)    bitrate += it->getLength()*8;    return bitrate/1000;}/* * actualizeVector():  * Aktualizuje vektor pre vypocet aktualnej rychlosti - ostrani zaznamy starsie ako jedna sekunda */void TG::RcvFlowRecord::actualizeVector(){  while((actStat.size() > 0) && (actStat.front().getTime() < (simTime().dbl() - 1.0)))     actStat.erase(actStat.begin());}/* * updateActVectorStats():  * Zapise do vektorovych statistik aktualnu rychlost primania vo vsetkych analyzovanych tokoch */void TrafGen::updateActVectorStats(){  for(TG::Flows::iterator it =  flows.begin(); it != flows.end(); ++it)  {    if(it->isAnalyzing())    {      TG::RcvStats::iterator flowStatIt = getRcvFlowStatById(it->getId());      if(flowStatIt != receivedStatistics.end())      {        actBitrateVec[it->getId()]->record(flowStatIt->getActBitrate());        actPacketrateVec[it->getId()]->record(flowStatIt->getActualPacketrate());       }    }  }}